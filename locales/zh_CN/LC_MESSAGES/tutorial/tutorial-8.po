msgid ""
msgstr ""
"Project-Id-Version: BeeWare 0.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-14 23:09-0400\n"
"PO-Revision-Date: 2025-08-09 01:01+0000\n"
"Last-Translator: John <johnzhou721@gmail.com>\n"
"Language-Team: Chinese (Simplified Han script) <https://hosted.weblate.org/"
"projects/beeware/tutorial/tutorial-8/zh_Hans/>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.15.6\n"

#: docs/en/tutorial/tutorial-8.md:1
msgid "Tutorial 8 - Making it Smooooth { id=\"tutorial-8\" }"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:3
msgid ""
"So far, our application has been relatively simple - displaying GUI widgets, "
"calling a simple third-party library, and displaying output in a dialog. All "
"these operations happen very quickly, and our application remains responsive."
msgstr ""
"到目前为止，我们的应用程序相对简单——显示图形用户界面控件、调用一个简单的第三"
"方库，以及在对话框中显示输出。所有这些操作都非常迅速，我们的应用程序始终保持"
"响应。"

#: docs/en/tutorial/tutorial-8.md:8
msgid ""
"However, in a real world application, we'll need to perform complex tasks or "
"calculations that may take a while to complete - and as those tasks are "
"performed, we want our application to remain responsive. Let's make a change "
"to our application that might take a little time to complete, and see the "
"changes that need to be made to accommodate that behavior."
msgstr ""
"但是，在实际的应用中，我们将需要进行会需要一会儿才能完成的复杂任务。当这些任"
"务进行时，我们想让我们的应用保持响应。让我们更改我们的应用程序，添加一个需要"
"一些时间才能完成的任务，并看看需要怎样更改应用程序，适应这个新的行为。"

#: docs/en/tutorial/tutorial-8.md:15
msgid "Accessing an API"
msgstr "访问 API"

#: docs/en/tutorial/tutorial-8.md:17
msgid ""
"A common time-consuming task an app will need to perform is to make a "
"request on a web API to retrieve data, and display that data to the user. "
"Web APIs sometimes take a second or two to respond, so if we're calling an "
"API like that, we need to ensure our application doesn't become unresponsive "
"while we wait for the web API to return an answer."
msgstr ""
"应用程序需要进行的一个常见的耗时任务时在一个网络 API "
"上请求取回数据，并将数据显示给用户。网络 API 有时需要一两秒才能回应，"
"所以如果我们将要访问这种 API，我们需要确保我们的应用在等待网络 API "
"返回答案时保持响应。"

#: docs/en/tutorial/tutorial-8.md:23
msgid ""
"This is a toy app, so we don't have a *real* API to work with, so we'll use "
"the [{JSON} Placeholder API]{1} as a source of data. The {JSON} Placeholder "
"API has a number of \"fake\" API endpoints you can use as test data. One of "
"those APIs is the `/posts/` endpoint, which returns fake blog posts. If you "
"open `https://jsonplaceholder.typicode.com/posts/42` in your browser, you'll "
"get a JSON payload describing a single post - some [Lorum ipsum]{2} content "
"for a blog post with ID 42."
msgstr ""
"这只是个入门级的应用，我们没有*真正*的API可供调用，所以我们将使用"
"[{JSON}占位符API]{1} "
"作为数据来源。{JSON}占位符API有一系列“虚假”的API端点可以供您作为测试数据调用"
"。其中之一就是`/posts/"
"`端点，它会返回一些虚假的博客推文。如果您在浏览器中访问`https://"
"jsonplaceholder.typicode.com/posts/"
"42`，您将会得到一串看起来像是在发推文的JSON数据——不过内容是ID为42的一些`"
"乱数假文 [Lorum ipsum]{2}。"

#: docs/en/tutorial/tutorial-8.md:33
msgid ""
"The Python standard library contains all the tools you'd need to access an "
"API. However, the built-in APIs are very low level. They are good "
"implementations of the HTTP protocol - but they require the user to manage "
"lots of low-level details, like URL redirection, sessions, authentication, "
"and payload encoding. As a \"normal browser user\" you're probably used to "
"taking these details for granted, as a browser manages them for you."
msgstr ""
"Python 标准库包含了需要访问一个 API 的所有工具，但这些内置 API 非常低级别。"
"它们良好的实现了 HTTP 协议，但它们要求用户管理 URL "
"重定向、会话、身份验证、数据编码等许多低级别细节。作为一个 "
"“普通浏览器用户”，您可能会把这些细节的管理是为理所当然的，因为浏览器帮您管理"
"它们。"

#: docs/en/tutorial/tutorial-8.md:41
msgid ""
"As a result, people have developed third-party libraries that wrap the built-"
"in APIs and provide a simpler API that is a closer match for the everyday "
"browser experience. We're going to use one of those libraries to access the "
"{JSON} Placeholder API - a library called [httpx]{1}. Briefcase uses `httpx` "
"internally, so it's already in your local environment -you don't need to "
"install it separately to use it here."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:49
msgid ""
"Let's add a `httpx` API call to our app. Modify the `requires` setting in "
"our `pyproject.toml` to include the new requirement:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:59
msgid "Add an import to the top of the `app.py` to import `httpx`:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:65
msgid "Then modify the `say_hello()` callback so it looks like this:"
msgstr "然后修改 `say_hello()` 回调，使其看起来像这样:"

#: docs/en/tutorial/tutorial-8.md:83
msgid ""
"This will change the `say_hello()` callback so that when it is invoked, it "
"will:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:86
msgid "make a GET request on the JSON placeholder API to obtain post 42;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:87
msgid "decode the response as JSON;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:88
msgid "extract the body of the post; and"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:89
msgid ""
"include the body of that post as the text of the \"message\" dialog, in "
"place of the text generated by Faker."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:92
msgid ""
"Lets run our updated app in Briefcase developer mode to check that our "
"change has worked. As we've added a new requirement, we need to tell "
"developer mode to reinstall requirements, by using the `-r` argument:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:96
#: docs/en/tutorial/tutorial-8.md:326
msgid "/// tab | macOS"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:107
#: docs/en/tutorial/tutorial-8.md:127
#: docs/en/tutorial/tutorial-8.md:147
msgid ""
"When you enter a name and press the button, you should see a dialog that "
"looks something like:"
msgstr "输入名称并按下按钮后，您会看到一个类似如下的对话框："

#: docs/en/tutorial/tutorial-8.md:114
#: docs/en/tutorial/tutorial-8.md:134
#: docs/en/tutorial/tutorial-8.md:154
#: docs/en/tutorial/tutorial-8.md:161
#: docs/en/tutorial/tutorial-8.md:168
#: docs/en/tutorial/tutorial-8.md:332
#: docs/en/tutorial/tutorial-8.md:340
#: docs/en/tutorial/tutorial-8.md:348
#: docs/en/tutorial/tutorial-8.md:356
#: docs/en/tutorial/tutorial-8.md:364
msgid "///"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:116
#: docs/en/tutorial/tutorial-8.md:334
msgid "/// tab | Linux"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:136
#: docs/en/tutorial/tutorial-8.md:342
msgid "/// tab | Windows"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:156
#: docs/en/tutorial/tutorial-8.md:350
msgid "/// tab | Android"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:158
msgid ""
"You can't run an Android app in developer mode - use the instructions for "
"your chosen desktop platform."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:163
#: docs/en/tutorial/tutorial-8.md:358
msgid "/// tab | iOS"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:165
msgid ""
"You can't run an iOS app in developer mode - use the instructions for your "
"chosen desktop platform."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:170
msgid ""
"Unless you've got a *really* fast internet connection, you may notice that "
"when you press the button, the GUI for your app locks up for a little bit. "
"The operating system may even manifest this with a \"beachball\" or "
"\"spinner\" cursor to indicate that the app is being unresponsive."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:176
#, fuzzy
msgid ""
"This is because the web request we have made is *synchronous*. When our "
"application makes the web request, it waits for the API to return a response "
"before continuing. While it's waiting, it *isn't* allowing the application "
"to redraw - and as a result, the application locks up."
msgstr ""
"除非您的网络连接速度\\ *非常*\\ "
"快，否则您可能会注意到，当您按下按钮时，应用程序的图形用户界面会锁定一会儿。"
"这是因为我们发出的网络请求是\\ *同步*\\ "
"的。当我们的应用程序发出网络请求时，它会等待应用程序接口返回响应，然后再继续"
"。在等待的过程中，应用程序\\ *不*\\ 允许重新绘制，结果导致应用程序锁定。"

#: docs/en/tutorial/tutorial-8.md:181
msgid "GUI Event Loops"
msgstr "图形用户界面事件循环"

#: docs/en/tutorial/tutorial-8.md:183
msgid ""
"To understand why this happens, we need to dig into the details of how a GUI "
"application works. The specifics vary depending on the platform; but the "
"high level concepts are the same, no matter the platform or GUI environment "
"you're using."
msgstr ""
"要理解为什么会出现这种情况，我们需要深入了解图形用户界面应用程序的工作原理。"
"具体细节因平台而异，但无论使用何种平台或图形用户界面环境，高层概念都是相同的"
"。"

#: docs/en/tutorial/tutorial-8.md:188
msgid "A GUI app is, fundamentally, a single loop that looks something like:"
msgstr "从根本上说，图形用户界面应用程序就是一个单一的循环，看起来就像:"

#: docs/en/tutorial/tutorial-8.md:196
#, fuzzy
msgid ""
"This loop is called the *Event Loop*. (These aren't actual method names - "
"it's an illustration of what is going on using \"pseudo-code\")."
msgstr "这个循环被称为 *事件循环*。(这些并不是实际的方法名称，而是 \"伪代码 \""
"的说明）。"

#: docs/en/tutorial/tutorial-8.md:199
#, fuzzy
msgid ""
"When you click on a button, or drag a scroll bar, or type a key, you are "
"generating an \"event\". That \"event\" is put onto a queue, and the app "
"will process the queue of events when it next has the opportunity to do so. "
"The user code that is triggered in response to the event is called an *event "
"handler*. These event handlers are invoked as part of the `process_events()` "
"call."
msgstr ""
"当你点击一个按钮、拖动一个滚动条或输入一个键时，你就产生了一个 \"事件\"。该 "
"\"事件 \""
"被放入一个队列，应用程序将在下一次有机会时处理队列中的事件。为响应事件而触发"
"的用户代码称为*事件处理程序*。这些事件处理程序作为`process_events()`调用的一"
"部分被调用。"

#: docs/en/tutorial/tutorial-8.md:206
msgid ""
"Once an app has processed all the available events, it will `redraw()` the "
"GUI. This takes into account any changes that the events have caused to the "
"display of the app, as well as anything else that is going on in the "
"operating system - for example, the windows of another app may obscure or "
"reveal part of our app's window, and our app's redraw will need to reflect "
"the portion of the window that is currently visible."
msgstr ""
"应用程序处理完所有可用事件后，就会 重绘 "
"（`redraw()`）图形用户界面。这将考虑到事件对应用程序显示所造成的任何变化，以"
"及操作系统中发生的任何其他情况，例如，其他应用程序的窗口可能会遮挡或显示我们"
"应用程序的部分窗口，而我们应用程序的重绘将需要反映当前可见的窗口部分。"

#: docs/en/tutorial/tutorial-8.md:213
#, fuzzy
msgid ""
"The important detail to notice: while an application is processing an event, "
"*it can't redraw*, and *it can't process other events*."
msgstr "需要注意的重要细节是：当应用程序在处理事件时，*不能重绘*，*也不能处理其他事件"
"*。"

#: docs/en/tutorial/tutorial-8.md:216
#, fuzzy
msgid ""
"This means any user logic contained in an event handler needs to complete "
"quickly. Any delay in completing the event handler will be observed by the "
"user as a slowdown (or stop) in GUI updates. If this delay is long enough, "
"your operating system may report this as a problem - the macOS \"beachball\" "
"and Windows \"spinner\" icons are the operating system telling you that your "
"app is taking too long in an event handler."
msgstr ""
"这意味着事件处理程序中包含的任何用户逻辑都需要快速完成。完成事件处理程序的任"
"何延迟都会被用户观察到，表现为图形用户界面更新的减慢（或停止）。如果延迟时间"
"足够长，操作系统可能会将此报告为问题--macOS 的 \"沙滩球 \"和 Windows 的 "
"\"旋转器 \"图标就是操作系统在告诉你，你的应用程序在事件处理程序中耗时过长。"

#: docs/en/tutorial/tutorial-8.md:224
#, fuzzy
msgid ""
"Simple operations like \"update a label\", or "
"\"recompute the total of the inputs\" are easy to complete quickly. However, "
"there are a lot of operations that can't be completed quickly. If you're "
"performing a complex mathematical calculation, or indexing all the files on "
"a file system, or performing a large network request, you can't "
"\"just do it quickly\" - the operations are inherently slow."
msgstr ""
"像 \"更新标签 \"或 \"重新计算输入总和 \""
"这样的简单操作很容易快速完成。然而，有很多操作是无法快速完成的。如果要执行复"
"杂的数学计算，或为文件系统中的所有文件编制索引，或执行大型网络请求，就不能 "
"\"快速完成\"--这些操作本身就很慢。"

#: docs/en/tutorial/tutorial-8.md:231
#, fuzzy
msgid "So - how do we perform long-lived operations in a GUI application?"
msgstr "那么，我们如何在图形用户界面应用程序中执行长期操作呢？"

#: docs/en/tutorial/tutorial-8.md:233
#, fuzzy
msgid "Asynchronous programming"
msgstr "异步编程"

#: docs/en/tutorial/tutorial-8.md:235
#, fuzzy
msgid ""
"What we need is a way to tell an app in the middle of a long-lived event "
"handler that it is OK to temporarily release control back to the event loop, "
"as long as we can resume where we left off. It's up to the app to determine "
"when this release can occur; but if the app releases control to the event "
"loop regularly, we can have a long-running event handler *and* maintain a "
"responsive UI."
msgstr ""
"我们需要的是一种方法，让处于长期事件处理程序中间的应用程序知道，只要我们能从"
"上次中断的地方继续运行，就可以暂时将控制权释放回事件循环。应用程序可以自行决"
"定何时释放控制权；但如果应用程序定期向事件循环释放控制权，我们就可以拥有一个"
"长期运行的事件处理程序，并**保持响应式用户界面。"

#: docs/en/tutorial/tutorial-8.md:242
#, fuzzy
msgid ""
"We can do this by using *asynchronous programming*. Asynchronous programming "
"is a way to describe a program that allows the interpreter to run multiple "
"functions at the same time, sharing resources between all the concurrently "
"running functions."
msgstr "我们可以通过使用*异步编程*来实现这一点。异步编程是一种描述程序的方法，它允许"
"解释器同时运行多个函数，在所有并发运行的函数之间共享资源。"

#: docs/en/tutorial/tutorial-8.md:247
#, fuzzy
msgid ""
"Asynchronous functions (known as *coroutines*) need to be explicitly "
"declared as being asynchronous. They also need to internally declare when an "
"opportunity exists to change context to another coroutine."
msgstr "异步函数（称为 * "
"协同例程*）需要明确声明为异步函数。它们还需要在内部声明何时有机会将上下文切换"
"到另一个共同例程。"

#: docs/en/tutorial/tutorial-8.md:251
#, fuzzy
msgid ""
"In Python, asynchronous programming is implemented using the `async` and "
"`await` keywords, and the [asyncio]{1} module in the standard library. The "
"`async` keyword allows us to declare that a function is an asynchronous "
"coroutine. The `await` keyword provides a way to declare when an opportunity "
"exists to change context to another coroutine. The [asyncio]{2} module "
"provides some other useful tools and primitives for asynchronous coding."
msgstr ""
"在 Python 中，异步编程是通过 `async` 和 `await` 关键字以及标准库中的 "
"[asyncio]{1} 模块来实现的。[async` 关键字允许我们声明一个函数是异步协程。"
"关键字 `await` 提供了一种方法来声明何时有机会将上下文切换到另一个协程。"
"[asyncio]{2} 模块为异步编码提供了一些其他有用的工具和原语。"

#: docs/en/tutorial/tutorial-8.md:261
#, fuzzy
msgid "Making the tutorial asynchronous"
msgstr "使教程异步化"

#: docs/en/tutorial/tutorial-8.md:263
#, fuzzy
msgid ""
"To make our tutorial asynchronous, modify the `say_hello()` event handler so "
"it looks like this:"
msgstr "为了使我们的教程成为异步教程，请修改事件处理程序 \"say_hello()\""
"，使其看起来像这样：："

#: docs/en/tutorial/tutorial-8.md:282
#, fuzzy
msgid ""
"There are only three changes to this callback from the previous version:"
msgstr "与上一版本相比，该代码只有 4 处改动："

#: docs/en/tutorial/tutorial-8.md:284
#, fuzzy
msgid ""
"The client that is created is an asynchronous `AsyncClient()`, rather than a "
"synchronous `Client()`. This tells `httpx` that it should operate in "
"asynchronous mode, rather than synchronous mode."
msgstr ""
"创建的客户端是异步的 `AsyncClient()` 而不是同步的 `Client()[。这就告诉 "
"`httpx` 应在异步模式而非同步模式下运行。"

#: docs/en/tutorial/tutorial-8.md:287
#, fuzzy
msgid ""
"The context manager used to create the client is marked as `async`. This "
"tells Python that there is an opportunity to release control as the context "
"manager is entered and exited."
msgstr "用于创建客户端的上下文管理器被标记为 `async`。这就告诉 "
"Python，当上下文管理器进入和退出时，有机会释放控制。"

#: docs/en/tutorial/tutorial-8.md:290
msgid ""
"The `get` call is made with an `await` keyword. This instructs the app that "
"while we are waiting for the response from the network, the app can release "
"control to the event loop. We've seen this keyword before - we also use "
"`await` when displaying the dialog box. The reason for that usage is the "
"same as it is for the HTTP request - we need to tell the app that while the "
"dialog is displayed, and we're waiting for the user to push a button, it's "
"OK to release control back to the event loop."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:299
msgid ""
"It's also important to note that the handler itself is defined as `async def`"
", rather than just `def`. This tells Python that the method is an "
"asynchronous coroutine. We made this change back in Tutorial 3 when we added "
"the dialog box. You can only use `await` statements inside a method that is "
"declared as `async def`."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:305
#, fuzzy
msgid ""
"Toga allows you to use regular methods or asynchronous coroutines as "
"handlers; Toga manages everything behind the scenes to make sure the handler "
"is invoked or awaited as required."
msgstr "Toga 允许你使用常规方法或异步协程作为处理程序；Toga "
"在幕后管理一切，确保处理程序按要求被调用或等待。"

#: docs/en/tutorial/tutorial-8.md:309
#, fuzzy
msgid ""
"If you save these changes and re-run the app in development mode, there "
"won't be any obvious changes to the app. However, when you click on the "
"button to trigger the dialog, you may notice a number of subtle improvements:"
msgstr ""
"如果保存这些更改并重新运行应用程序（在开发模式下使用 `briefcase dev` "
"或更新并重新运行打包的应用程序），应用程序不会有任何明显的变化。不过，当您点"
"击按钮触发对话框时，您可能会注意到一些细微的改进："

#: docs/en/tutorial/tutorial-8.md:314
#, fuzzy
msgid ""
"The button returns to an \"unclicked\" state, rather than being stuck in a "
"\"clicked\" state."
msgstr "按钮会返回到 \"未点击 \"状态，而不是停留在 \"已点击 \"状态。"

#: docs/en/tutorial/tutorial-8.md:316
msgid "The \"beachball\"/\"spinner\" icon won't appear."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:317
msgid ""
"If you move/resize the app window while waiting for the dialog to appear, "
"the window will redraw."
msgstr "如果在等待对话框出现时移动或调整应用程序窗口的大小，窗口将重新绘制。"

#: docs/en/tutorial/tutorial-8.md:319
#, fuzzy
msgid "If you try to open an app menu, the menu will appear immediately."
msgstr "如果尝试打开应用程序菜单，菜单会立即出现。"

#: docs/en/tutorial/tutorial-8.md:321
msgid ""
"We can now run the full app. However, as we've added an extra requirement "
"(`httpx`) we also need to update our app's requirements; we can do this by "
"passing `-r` to `briefcase run`. This will update our app's requirements, "
"then re-build the app, then launch the app:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:366
msgid ""
"You should see you app running, and remaining responsive when you press the "
"button and network content is retrieved."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:369
msgid "Next steps"
msgstr "下一步"

#: docs/en/tutorial/tutorial-8.md:371
msgid ""
"This has been a taste for what you can do with the tools provided by the "
"BeeWare project. Over the course of this tutorial, you have:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:374
msgid "Created a new GUI app project;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:375
msgid "Run that app in development mode;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:376
msgid "Built the app as a standalone binary for a desktop operating system;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:377
msgid "Packaged that project for distribution to others;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:378
msgid "Run the app on a mobile simulator and/or device;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:379
msgid "Run the app as a web app;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:380
msgid "Added a third-party dependency to your app; and"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:381
msgid "Modified the app so that it remains responsive."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:383
msgid "So - where to from here?"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:385
msgid ""
"If you'd like to go further, there are some additional [topic tutorials]"
"[topics] that go into detail on specific aspects of application development."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:388
msgid ""
"If you'd like to know more about how to build complex user interfaces with "
"Toga, you can dive into [Toga's documentation]{1}. Toga also has its own "
"tutorial [demonstrating how to use various features of the widget toolkit]"
"{2}."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:393
msgid ""
"If you'd like to know more about the capabilities of Briefcase, you can dive "
"into [Briefcase's documentation]{1}."
msgstr ""

#~ msgid "Tutorial 8 - Making it Smooooth"
#~ msgstr "教程 8 - 使其光滑"
