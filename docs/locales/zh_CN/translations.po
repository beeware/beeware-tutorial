msgid ""
msgstr ""
"Project-Id-Version: BeeWare 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-15 23:43+0000\n"
"PO-Revision-Date: 2025-10-15 17:07+0000\n"
"Last-Translator: John <johnzhou721@gmail.com>\n"
"Language-Team: Chinese (Simplified Han script) <https://hosted.weblate.org/"
"projects/beeware/tutorial/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Translate Toolkit 3.16.2\n"

#: docs/en/SUMMARY.md:5
msgid "[Tutorial 0 - Let's get set up!]{1}"
msgstr "[教程 0 - 准备就绪！]{1}"

#: docs/en/SUMMARY.md:6
msgid "[Tutorial 1 - Your first app]{1}"
msgstr "[教程 1 - 您的第一个应用程序]{1}"

#: docs/en/SUMMARY.md:7
msgid "[Tutorial 2 - Making it interesting]{1}"
msgstr "[教程 2 - 使之更有趣]{1}"

#: docs/en/SUMMARY.md:8
msgid "[Tutorial 3 - Packaging for distribution]{1}"
msgstr "[教程 3 - 打包与分发]{1}"

#: docs/en/SUMMARY.md:9
msgid "[Tutorial 4 - Updating your application]{1}"
msgstr "[教程 4 - 更新应用程序]{1}"

#: docs/en/SUMMARY.md:10
msgid "Tutorial 5 - Taking it mobile"
msgstr "教程 5 - 在移动设备上"

#: docs/en/SUMMARY.md:10
msgid "[Tutorial 5 - Taking it mobile]{1}"
msgstr "[教程 5 - 在移动设备上]{1}"

#: docs/en/SUMMARY.md:10
msgid "[Tutorial 5 - Taking it mobile: Android]{1}"
msgstr "[教程 5 - 在移动设备上：Android]{1}"

#: docs/en/SUMMARY.md:10
msgid "[Tutorial 5 - Taking it mobile: iOS]{1}"
msgstr "[教程 5 - 在移动设备上：iOS]{1}"

#: docs/en/SUMMARY.md:14
msgid "[Tutorial 6 - Put it on the web!]{1}"
msgstr "[教程 6 - 把它放上网！]{1}"

#: docs/en/SUMMARY.md:15
msgid "[Tutorial 7 - Get this (third-)party started]{1}"
msgstr "[教程 7 - 使用第三方库]{1}"

#: docs/en/SUMMARY.md:16
msgid "[Tutorial 8 - Making it Smooooth]{1}"
msgstr "[教程 8 - 使其光滑]{1}"

#: docs/en/SUMMARY.md:17
#: docs/en/tutorial/topics/index.md:1
msgid "Going further"
msgstr "更进一步"

#: docs/en/SUMMARY.md:17
msgid "[Going further]{1}"
msgstr "[进一步]{1}"

#: docs/en/SUMMARY.md:17
#: docs/en/tutorial/topics/index.md:5
msgid "[Customizing icons]{1}"
msgstr "[自定义图标]{1}"

#: docs/en/SUMMARY.md:17
#: docs/en/tutorial/topics/index.md:9
msgid "[Using the camera]{1}"
msgstr "[使用相机]{1}"

#: docs/en/SUMMARY.md:17
#: docs/en/tutorial/topics/index.md:13
msgid "[Testing times]{1}"
msgstr "[测试时间]{1}"

#: docs/en/SUMMARY.md:22
msgid "How-to guides"
msgstr "如何...？"

#: docs/en/SUMMARY.md:22
msgid "[Contributing to this tutorial]{1}"
msgstr "[为本教程做出贡献]{1}"

#: docs/en/SUMMARY.md:22
msgid "[Style guide]{1}"
msgstr "[风格指南]{1}"

#: docs/en/how-to/contribute.md:1
msgid "Contributing to this tutorial"
msgstr "为本教程做出贡献"

#: docs/en/how-to/contribute.md:3
msgid ""
"This tutorial is written using [MkDocs and Markdown]{1}. This guide will "
"help you contribute fixes or new content to this tutorial."
msgstr "本教程使用 [MkDocs 和 Markdown]{1} 编写。本指南将帮助您为本教程贡献修复或者新"
"内容。"

#: docs/en/how-to/contribute.md:5
msgid ""
"Translations of this tutorial are managed using [Weblate]{1}. If you'd like "
"to contribute to the translation effort, join the `#translations` channel on "
"[Discord]{2} and introduce yourself!"
msgstr ""
"本教程使用 [Weblate]{1} 进行翻译管理。如果您想参与翻译工作，请加入 [Discord]"
"{2} 上的 `#translations` 频道并介绍自己！"

#: docs/en/how-to/contribute.md:7
msgid "Set up your development environment"
msgstr "设置开发环境"

#: docs/en/how-to/contribute.md:9
msgid ""
"To build the BeeWare tutorial you **must** have a Python 3.12 interpreter "
"installed and available on your path "
"(i.e., `python3` must start a Python 3.12 interpreter)."
msgstr ""
"要编译 BeeWare 教程，path 上**必须**安装有 Python 3.12 解释器（即 `python3` "
"必须启动 Python 3.12 解释器）。"

#: docs/en/how-to/contribute.md:11
#: docs/en/how-to/contribute.md:42
#: docs/en/how-to/contribute.md:77
#: docs/en/how-to/contribute.md:117
#: docs/en/how-to/contribute.md:148
#: docs/en/how-to/contribute.md:177
#: docs/en/how-to/contribute.md:239
#: docs/en/how-to/contribute.md:293
#: docs/en/how-to/contribute.md:323
#: docs/en/how-to/contribute.md:353
#: docs/en/how-to/contribute.md:396
#: docs/en/how-to/contribute.md:426
#: docs/en/how-to/contribute.md:456
#: docs/en/how-to/contribute.md:502
#: docs/en/tutorial/topics/camera-access.md:115
#: docs/en/tutorial/topics/custom-icons.md:19
#: docs/en/tutorial/topics/custom-icons.md:186
#: docs/en/tutorial/topics/custom-icons.md:367
#: docs/en/tutorial/topics/testing.md:19
#: docs/en/tutorial/topics/testing.md:124
#: docs/en/tutorial/topics/testing.md:196
#: docs/en/tutorial/topics/testing.md:315
#: docs/en/tutorial/topics/testing.md:381
#: docs/en/tutorial/tutorial-0.md:9
#: docs/en/tutorial/tutorial-0.md:53
#: docs/en/tutorial/tutorial-0.md:106
#: docs/en/tutorial/tutorial-1.md:9
#: docs/en/tutorial/tutorial-1.md:49
#: docs/en/tutorial/tutorial-1.md:118
#: docs/en/tutorial/tutorial-1.md:165
#: docs/en/tutorial/tutorial-2.md:230
#: docs/en/tutorial/tutorial-2.md:267
#: docs/en/tutorial/tutorial-3.md:13
#: docs/en/tutorial/tutorial-3.md:132
#: docs/en/tutorial/tutorial-3.md:202
#: docs/en/tutorial/tutorial-3.md:289
#: docs/en/tutorial/tutorial-4.md:29
#: docs/en/tutorial/tutorial-4.md:65
#: docs/en/tutorial/tutorial-4.md:160
#: docs/en/tutorial/tutorial-5/android.md:11
#: docs/en/tutorial/tutorial-5/android.md:104
#: docs/en/tutorial/tutorial-5/android.md:176
#: docs/en/tutorial/tutorial-5/android.md:285
#: docs/en/tutorial/tutorial-6.md:17
#: docs/en/tutorial/tutorial-7.md:34
#: docs/en/tutorial/tutorial-7.md:114
#: docs/en/tutorial/tutorial-7.md:183
#: docs/en/tutorial/tutorial-7.md:490
#: docs/en/tutorial/tutorial-8.md:59
#: docs/en/tutorial/tutorial-8.md:213
msgid "/// tab | macOS"
msgstr "/// tab | macOS"

#: docs/en/how-to/contribute.md:18
#: docs/en/how-to/contribute.md:27
#: docs/en/how-to/contribute.md:36
#: docs/en/how-to/contribute.md:49
#: docs/en/how-to/contribute.md:58
#: docs/en/how-to/contribute.md:67
#: docs/en/how-to/contribute.md:87
#: docs/en/how-to/contribute.md:99
#: docs/en/how-to/contribute.md:111
#: docs/en/how-to/contribute.md:124
#: docs/en/how-to/contribute.md:133
#: docs/en/how-to/contribute.md:142
#: docs/en/how-to/contribute.md:155
#: docs/en/how-to/contribute.md:164
#: docs/en/how-to/contribute.md:173
#: docs/en/how-to/contribute.md:195
#: docs/en/how-to/contribute.md:215
#: docs/en/how-to/contribute.md:235
#: docs/en/how-to/contribute.md:253
#: docs/en/how-to/contribute.md:269
#: docs/en/how-to/contribute.md:283
#: docs/en/how-to/contribute.md:299
#: docs/en/how-to/contribute.md:307
#: docs/en/how-to/contribute.md:315
#: docs/en/how-to/contribute.md:329
#: docs/en/how-to/contribute.md:337
#: docs/en/how-to/contribute.md:345
#: docs/en/how-to/contribute.md:359
#: docs/en/how-to/contribute.md:367
#: docs/en/how-to/contribute.md:375
#: docs/en/how-to/contribute.md:402
#: docs/en/how-to/contribute.md:410
#: docs/en/how-to/contribute.md:418
#: docs/en/how-to/contribute.md:432
#: docs/en/how-to/contribute.md:440
#: docs/en/how-to/contribute.md:448
#: docs/en/how-to/contribute.md:462
#: docs/en/how-to/contribute.md:470
#: docs/en/how-to/contribute.md:478
#: docs/en/how-to/contribute.md:508
#: docs/en/how-to/contribute.md:516
#: docs/en/how-to/contribute.md:524
#: docs/en/index.md:13
#: docs/en/index.md:25
#: docs/en/index.md:37
#: docs/en/tutorial/topics/camera-access.md:15
#: docs/en/tutorial/topics/camera-access.md:123
#: docs/en/tutorial/topics/camera-access.md:133
#: docs/en/tutorial/topics/custom-icons.md:36
#: docs/en/tutorial/topics/custom-icons.md:60
#: docs/en/tutorial/topics/custom-icons.md:79
#: docs/en/tutorial/topics/custom-icons.md:117
#: docs/en/tutorial/topics/custom-icons.md:151
#: docs/en/tutorial/topics/custom-icons.md:180
#: docs/en/tutorial/topics/custom-icons.md:210
#: docs/en/tutorial/topics/custom-icons.md:242
#: docs/en/tutorial/topics/custom-icons.md:269
#: docs/en/tutorial/topics/custom-icons.md:313
#: docs/en/tutorial/topics/custom-icons.md:315
#: docs/en/tutorial/topics/custom-icons.md:351
#: docs/en/tutorial/topics/custom-icons.md:357
#: docs/en/tutorial/topics/custom-icons.md:382
#: docs/en/tutorial/topics/custom-icons.md:399
#: docs/en/tutorial/topics/custom-icons.md:416
#: docs/en/tutorial/topics/custom-icons.md:432
#: docs/en/tutorial/topics/custom-icons.md:448
#: docs/en/tutorial/topics/testing.md:42
#: docs/en/tutorial/topics/testing.md:70
#: docs/en/tutorial/topics/testing.md:98
#: docs/en/tutorial/topics/testing.md:141
#: docs/en/tutorial/topics/testing.md:160
#: docs/en/tutorial/topics/testing.md:179
#: docs/en/tutorial/topics/testing.md:228
#: docs/en/tutorial/topics/testing.md:264
#: docs/en/tutorial/topics/testing.md:298
#: docs/en/tutorial/topics/testing.md:333
#: docs/en/tutorial/topics/testing.md:353
#: docs/en/tutorial/topics/testing.md:373
#: docs/en/tutorial/topics/testing.md:423
#: docs/en/tutorial/topics/testing.md:457
#: docs/en/tutorial/topics/testing.md:496
#: docs/en/tutorial/tutorial-0.md:25
#: docs/en/tutorial/tutorial-0.md:37
#: docs/en/tutorial/tutorial-0.md:47
#: docs/en/tutorial/tutorial-0.md:59
#: docs/en/tutorial/tutorial-0.md:90
#: docs/en/tutorial/tutorial-0.md:100
#: docs/en/tutorial/tutorial-0.md:115
#: docs/en/tutorial/tutorial-0.md:126
#: docs/en/tutorial/tutorial-0.md:155
#: docs/en/tutorial/tutorial-0.md:157
#: docs/en/tutorial/tutorial-0.md:165
#: docs/en/tutorial/tutorial-1.md:15
#: docs/en/tutorial/tutorial-1.md:27
#: docs/en/tutorial/tutorial-1.md:29
#: docs/en/tutorial/tutorial-1.md:41
#: docs/en/tutorial/tutorial-1.md:43
#: docs/en/tutorial/tutorial-1.md:55
#: docs/en/tutorial/tutorial-1.md:63
#: docs/en/tutorial/tutorial-1.md:71
#: docs/en/tutorial/tutorial-1.md:131
#: docs/en/tutorial/tutorial-1.md:146
#: docs/en/tutorial/tutorial-1.md:161
#: docs/en/tutorial/tutorial-1.md:171
#: docs/en/tutorial/tutorial-1.md:173
#: docs/en/tutorial/tutorial-1.md:181
#: docs/en/tutorial/tutorial-1.md:183
#: docs/en/tutorial/tutorial-1.md:191
#: docs/en/tutorial/tutorial-1.md:207
#: docs/en/tutorial/tutorial-1.md:209
#: docs/en/tutorial/tutorial-2.md:83
#: docs/en/tutorial/tutorial-2.md:111
#: docs/en/tutorial/tutorial-2.md:166
#: docs/en/tutorial/tutorial-2.md:239
#: docs/en/tutorial/tutorial-2.md:250
#: docs/en/tutorial/tutorial-2.md:261
#: docs/en/tutorial/tutorial-2.md:273
#: docs/en/tutorial/tutorial-2.md:275
#: docs/en/tutorial/tutorial-2.md:283
#: docs/en/tutorial/tutorial-2.md:285
#: docs/en/tutorial/tutorial-2.md:293
#: docs/en/tutorial/tutorial-2.md:295
#: docs/en/tutorial/tutorial-3.md:40
#: docs/en/tutorial/tutorial-3.md:84
#: docs/en/tutorial/tutorial-3.md:86
#: docs/en/tutorial/tutorial-3.md:112
#: docs/en/tutorial/tutorial-3.md:147
#: docs/en/tutorial/tutorial-3.md:177
#: docs/en/tutorial/tutorial-3.md:194
#: docs/en/tutorial/tutorial-3.md:196
#: docs/en/tutorial/tutorial-3.md:225
#: docs/en/tutorial/tutorial-3.md:253
#: docs/en/tutorial/tutorial-3.md:277
#: docs/en/tutorial/tutorial-3.md:326
#: docs/en/tutorial/tutorial-3.md:423
#: docs/en/tutorial/tutorial-3.md:461
#: docs/en/tutorial/tutorial-4.md:35
#: docs/en/tutorial/tutorial-4.md:37
#: docs/en/tutorial/tutorial-4.md:45
#: docs/en/tutorial/tutorial-4.md:47
#: docs/en/tutorial/tutorial-4.md:55
#: docs/en/tutorial/tutorial-4.md:57
#: docs/en/tutorial/tutorial-4.md:79
#: docs/en/tutorial/tutorial-4.md:102
#: docs/en/tutorial/tutorial-4.md:118
#: docs/en/tutorial/tutorial-4.md:128
#: docs/en/tutorial/tutorial-4.md:181
#: docs/en/tutorial/tutorial-4.md:210
#: docs/en/tutorial/tutorial-4.md:228
#: docs/en/tutorial/tutorial-5/android.md:38
#: docs/en/tutorial/tutorial-5/android.md:67
#: docs/en/tutorial/tutorial-5/android.md:96
#: docs/en/tutorial/tutorial-5/android.md:122
#: docs/en/tutorial/tutorial-5/android.md:142
#: docs/en/tutorial/tutorial-5/android.md:162
#: docs/en/tutorial/tutorial-5/android.md:168
#: docs/en/tutorial/tutorial-5/android.md:188
#: docs/en/tutorial/tutorial-5/android.md:202
#: docs/en/tutorial/tutorial-5/android.md:216
#: docs/en/tutorial/tutorial-5/android.md:228
#: docs/en/tutorial/tutorial-5/android.md:238
#: docs/en/tutorial/tutorial-5/android.md:248
#: docs/en/tutorial/tutorial-5/android.md:254
#: docs/en/tutorial/tutorial-5/android.md:264
#: docs/en/tutorial/tutorial-5/android.md:299
#: docs/en/tutorial/tutorial-5/android.md:315
#: docs/en/tutorial/tutorial-5/android.md:331
#: docs/en/tutorial/tutorial-5/android.md:341
#: docs/en/tutorial/tutorial-5/iOS.md:101
#: docs/en/tutorial/tutorial-6.md:11
#: docs/en/tutorial/tutorial-6.md:55
#: docs/en/tutorial/tutorial-6.md:95
#: docs/en/tutorial/tutorial-6.md:135
#: docs/en/tutorial/tutorial-7.md:54
#: docs/en/tutorial/tutorial-7.md:76
#: docs/en/tutorial/tutorial-7.md:98
#: docs/en/tutorial/tutorial-7.md:104
#: docs/en/tutorial/tutorial-7.md:110
#: docs/en/tutorial/tutorial-7.md:127
#: docs/en/tutorial/tutorial-7.md:129
#: docs/en/tutorial/tutorial-7.md:144
#: docs/en/tutorial/tutorial-7.md:146
#: docs/en/tutorial/tutorial-7.md:161
#: docs/en/tutorial/tutorial-7.md:163
#: docs/en/tutorial/tutorial-7.md:169
#: docs/en/tutorial/tutorial-7.md:175
#: docs/en/tutorial/tutorial-7.md:220
#: docs/en/tutorial/tutorial-7.md:222
#: docs/en/tutorial/tutorial-7.md:277
#: docs/en/tutorial/tutorial-7.md:316
#: docs/en/tutorial/tutorial-7.md:318
#: docs/en/tutorial/tutorial-7.md:393
#: docs/en/tutorial/tutorial-7.md:441
#: docs/en/tutorial/tutorial-7.md:511
#: docs/en/tutorial/tutorial-7.md:540
#: docs/en/tutorial/tutorial-7.md:563
#: docs/en/tutorial/tutorial-7.md:582
#: docs/en/tutorial/tutorial-7.md:606
#: docs/en/tutorial/tutorial-7.md:614
#: docs/en/tutorial/tutorial-8.md:76
#: docs/en/tutorial/tutorial-8.md:78
#: docs/en/tutorial/tutorial-8.md:97
#: docs/en/tutorial/tutorial-8.md:99
#: docs/en/tutorial/tutorial-8.md:118
#: docs/en/tutorial/tutorial-8.md:120
#: docs/en/tutorial/tutorial-8.md:126
#: docs/en/tutorial/tutorial-8.md:132
#: docs/en/tutorial/tutorial-8.md:219
#: docs/en/tutorial/tutorial-8.md:227
#: docs/en/tutorial/tutorial-8.md:235
#: docs/en/tutorial/tutorial-8.md:243
#: docs/en/tutorial/tutorial-8.md:251
msgid "///"
msgstr "///"

#: docs/en/how-to/contribute.md:20
#: docs/en/how-to/contribute.md:51
#: docs/en/how-to/contribute.md:89
#: docs/en/how-to/contribute.md:126
#: docs/en/how-to/contribute.md:157
#: docs/en/how-to/contribute.md:197
#: docs/en/how-to/contribute.md:255
#: docs/en/how-to/contribute.md:301
#: docs/en/how-to/contribute.md:331
#: docs/en/how-to/contribute.md:361
#: docs/en/how-to/contribute.md:404
#: docs/en/how-to/contribute.md:434
#: docs/en/how-to/contribute.md:464
#: docs/en/how-to/contribute.md:510
#: docs/en/tutorial/topics/custom-icons.md:38
#: docs/en/tutorial/topics/custom-icons.md:212
#: docs/en/tutorial/topics/custom-icons.md:384
#: docs/en/tutorial/topics/testing.md:44
#: docs/en/tutorial/topics/testing.md:143
#: docs/en/tutorial/topics/testing.md:230
#: docs/en/tutorial/topics/testing.md:335
#: docs/en/tutorial/topics/testing.md:425
#: docs/en/tutorial/tutorial-0.md:27
#: docs/en/tutorial/tutorial-0.md:61
#: docs/en/tutorial/tutorial-0.md:117
#: docs/en/tutorial/tutorial-1.md:17
#: docs/en/tutorial/tutorial-1.md:57
#: docs/en/tutorial/tutorial-1.md:133
#: docs/en/tutorial/tutorial-1.md:175
#: docs/en/tutorial/tutorial-2.md:241
#: docs/en/tutorial/tutorial-2.md:277
#: docs/en/tutorial/tutorial-3.md:42
#: docs/en/tutorial/tutorial-3.md:149
#: docs/en/tutorial/tutorial-3.md:227
#: docs/en/tutorial/tutorial-3.md:328
#: docs/en/tutorial/tutorial-4.md:39
#: docs/en/tutorial/tutorial-4.md:81
#: docs/en/tutorial/tutorial-4.md:183
#: docs/en/tutorial/tutorial-5/android.md:40
#: docs/en/tutorial/tutorial-5/android.md:124
#: docs/en/tutorial/tutorial-5/android.md:190
#: docs/en/tutorial/tutorial-5/android.md:301
#: docs/en/tutorial/tutorial-6.md:57
#: docs/en/tutorial/tutorial-7.md:56
#: docs/en/tutorial/tutorial-7.md:131
#: docs/en/tutorial/tutorial-7.md:224
#: docs/en/tutorial/tutorial-7.md:513
#: docs/en/tutorial/tutorial-8.md:80
#: docs/en/tutorial/tutorial-8.md:221
msgid "/// tab | Linux"
msgstr "/// tab | Linux"

#: docs/en/how-to/contribute.md:29
#: docs/en/how-to/contribute.md:60
#: docs/en/how-to/contribute.md:101
#: docs/en/how-to/contribute.md:135
#: docs/en/how-to/contribute.md:166
#: docs/en/how-to/contribute.md:217
#: docs/en/how-to/contribute.md:271
#: docs/en/how-to/contribute.md:309
#: docs/en/how-to/contribute.md:339
#: docs/en/how-to/contribute.md:369
#: docs/en/how-to/contribute.md:412
#: docs/en/how-to/contribute.md:442
#: docs/en/how-to/contribute.md:472
#: docs/en/how-to/contribute.md:518
#: docs/en/tutorial/topics/custom-icons.md:62
#: docs/en/tutorial/topics/custom-icons.md:244
#: docs/en/tutorial/topics/custom-icons.md:401
#: docs/en/tutorial/topics/testing.md:72
#: docs/en/tutorial/topics/testing.md:162
#: docs/en/tutorial/topics/testing.md:266
#: docs/en/tutorial/topics/testing.md:355
#: docs/en/tutorial/topics/testing.md:459
#: docs/en/tutorial/tutorial-0.md:39
#: docs/en/tutorial/tutorial-0.md:92
#: docs/en/tutorial/tutorial-0.md:128
#: docs/en/tutorial/tutorial-1.md:31
#: docs/en/tutorial/tutorial-1.md:65
#: docs/en/tutorial/tutorial-1.md:148
#: docs/en/tutorial/tutorial-1.md:185
#: docs/en/tutorial/tutorial-2.md:252
#: docs/en/tutorial/tutorial-2.md:287
#: docs/en/tutorial/tutorial-3.md:88
#: docs/en/tutorial/tutorial-3.md:179
#: docs/en/tutorial/tutorial-3.md:255
#: docs/en/tutorial/tutorial-3.md:425
#: docs/en/tutorial/tutorial-4.md:49
#: docs/en/tutorial/tutorial-4.md:104
#: docs/en/tutorial/tutorial-4.md:212
#: docs/en/tutorial/tutorial-5/android.md:69
#: docs/en/tutorial/tutorial-5/android.md:144
#: docs/en/tutorial/tutorial-5/android.md:204
#: docs/en/tutorial/tutorial-5/android.md:317
#: docs/en/tutorial/tutorial-6.md:97
#: docs/en/tutorial/tutorial-7.md:78
#: docs/en/tutorial/tutorial-7.md:148
#: docs/en/tutorial/tutorial-7.md:279
#: docs/en/tutorial/tutorial-7.md:542
#: docs/en/tutorial/tutorial-8.md:101
#: docs/en/tutorial/tutorial-8.md:229
msgid "/// tab | Windows"
msgstr "/// tab | Windows"

#: docs/en/how-to/contribute.md:38
msgid "Create a virtual environment"
msgstr "建立虚拟环境"

#: docs/en/how-to/contribute.md:40
msgid ""
"The recommended way of setting up your development environment for BeeWare "
"is to install a virtual environment, install the required dependencies and "
"start coding. To set up a virtual environment, run:"
msgstr "设置 BeeWare 开发环境的推荐方法是安装虚拟环境、安装所需的依赖项并开始写代码。"
"要设置虚拟环境，请运行："

#: docs/en/how-to/contribute.md:69
msgid "Your prompt should now have a `(.venv)` prefix in front of it."
msgstr "现在，你的提示符前面应该会有 `(.venv)` 前缀。"

#: docs/en/how-to/contribute.md:71
msgid "Clone the BeeWare Tutorial repository"
msgstr "克隆 BeeWare 教程仓库"

#: docs/en/how-to/contribute.md:73
msgid "For updates to BeeWare documentation:"
msgstr "有关 BeeWare 文档的更新："

#: docs/en/how-to/contribute.md:75
msgid ""
"Next, go to [the BeeWare Tutorial page on GitHub]{1}, fork the repository "
"into your own account, and then clone a copy of that repository onto your "
"computer by clicking on \"Clone or Download\". If you have the GitHub "
"desktop application installed on your computer, you can select "
"\"Open in Desktop\"; otherwise, copy the URL provided, and use it to clone "
"using the command line:"
msgstr ""
"接下来，访问 [GitHub 上的 BeeWare 教程页面]{1}，将仓库 fork 到自己的账户中，"
"然后点击 “Clone or Download” 以将仓库克隆到电脑上。如果电脑上安装了 GitHub "
"Desktop 程序，可以选择 “Open in Desktop”；否则，请复制显示的 URL，然后使用命"
"令行克隆："

#: docs/en/how-to/contribute.md:79
#: docs/en/how-to/contribute.md:91
#: docs/en/how-to/contribute.md:103
msgid "Fork the BeeWare Tutorial repository, and then:"
msgstr "Fork BeeWare Tutorial 仓库，然后："

#: docs/en/how-to/contribute.md:85
#: docs/en/how-to/contribute.md:97
#: docs/en/how-to/contribute.md:109
msgid "(substituting your GitHub username)"
msgstr "(用您的 GitHub 用户名代替）"

#: docs/en/how-to/contribute.md:113
msgid "Install BeeWare tutorial docs dependencies"
msgstr "安装 BeeWare 教程文档依赖项"

#: docs/en/how-to/contribute.md:115
msgid ""
"Now that you have the source code, you can install BeeWare docs requirements "
"into your development environment. Since we're installing from source, we "
"can't rely on pip to resolve the dependencies to source packages, so we have "
"to manually install each package:"
msgstr ""
"有了源代码，就可以在开发环境中安装 BeeWare 文档依赖项了。由于我们是从源代码安"
"装，因此不能依靠 pip 来解析源代码包的依赖关系，所以我们必须手动安装每个软件包"
"："

#: docs/en/how-to/contribute.md:144
msgid "Install pre-commit"
msgstr "安装 pre-commit"

#: docs/en/how-to/contribute.md:146
msgid ""
"BeeWare uses a tool called [Pre-Commit]{1} to identify simple issues and "
"standardize code formatting. It does this by installing a git hook that "
"automatically runs a series of code linters prior to finalizing any git "
"commit. To enable pre-commit, run:"
msgstr ""
"BeeWare 使用一个名为 [Pre-Commit]{1} 的工具来识别简单问题并规范代码格式。它通"
"过安装一个 git 钩子，在完成任何 git commit 之前自动运行一系列 linters。要启用"
" pre-commit，请运行："

#: docs/en/how-to/contribute.md:175
msgid ""
"When you commit any change, pre-commit will run automatically. If there are "
"any issues found with the commit, this will cause your commit to fail. Where "
"possible, pre-commit will make the changes needed to correct the problems it "
"has found:"
msgstr ""
"提交任何更改时，pre-commit 会自动运行。如果在提交过程中发现任何问题，都会导致"
"提交失败。在可能的情况下，pre-commit 会对发现的问题进行必要的修改："

#: docs/en/how-to/contribute.md:237
msgid ""
"You can then re-add any files that were modified as a result of the pre-"
"commit checks, and re-commit the change."
msgstr "然后，你可以重新添加任何被 pre-commit 修改的文件，并重新 commit 更改。"

#: docs/en/how-to/contribute.md:285
msgid "Now you are ready to start hacking on BeeWare docs!"
msgstr "现在，您已经准备好为 BeeWare 做贡献了！"

#: docs/en/how-to/contribute.md:287
msgid "Building the BeeWare Tutorial"
msgstr "编译 BeeWare 教程"

#: docs/en/how-to/contribute.md:289
msgid "Build the Tutorial locally"
msgstr "在本地构建教程"

#: docs/en/how-to/contribute.md:291
msgid "Once your development environment is set up, run:"
msgstr "设置好开发环境后，运行："

#: docs/en/how-to/contribute.md:317
msgid ""
"The output of the file should be in the `_build/html` folder. If there are "
"any markup problems, they'll raise an error."
msgstr "该文件的输出应位于 `_build/html` 文件夹中。如果出现任何标记语法问题，它将会引"
"发错误。"

#: docs/en/how-to/contribute.md:319
msgid "Live Tutorial preview"
msgstr "实时教程预览"

#: docs/en/how-to/contribute.md:321
msgid ""
"To support rapid editing of documentation, BeeWare also has a "
"\"live preview\" mode:"
msgstr "为了支持文档的快速编辑，BeeWare 还提供了“实时预览”模式："

#: docs/en/how-to/contribute.md:347
msgid ""
"This will build the documentation, start a web server to serve the build "
"documentation, and watch the file system for any changes to the "
"documentation source. If a change is detected, the documentation will be "
"rebuilt, and any browser viewing the modified page will be automatically "
"refreshed."
msgstr ""
"这将构建文档，启动网络服务器以提供构建文档，并监视是否对文档源进行了任何更改"
"。如果检测到了更改，它将重建文档，并自动刷新查看修改过的页面的任何浏览器。"

#: docs/en/how-to/contribute.md:349
msgid "Tutorial linting"
msgstr "教程 lint"

#: docs/en/how-to/contribute.md:351
msgid ""
"The build process will identify most Markdown problems, but BeeWare performs "
"some additional \"lint\" checks. To run the lint checks:"
msgstr ""
"构建过程会识别出大多数 Markdown 问题，但 BeeWare 还会执行一些额外的 \"lint\" "
"检查。要运行 \"lint\" 检查："

#: docs/en/how-to/contribute.md:377
msgid "This will validate the documentation does not contain:"
msgstr "这将验证文档不包含："

#: docs/en/how-to/contribute.md:379
msgid "dead hyperlinks"
msgstr "死超链接"

#: docs/en/how-to/contribute.md:380
msgid "misspelled words"
msgstr "错别字"

#: docs/en/how-to/contribute.md:382
#, fuzzy
msgid ""
"If a valid spelling of a word is identified as misspelled, then add the word "
"to the list in `docs/spelling_wordlist`. This will add the word to the "
"spellchecker's dictionary. When adding to this list, remember:"
msgstr ""
"如果一个单词的有效拼写被识别为拼写错误，则将该单词添加到 `docs/"
"spelling_wordlist` 中的列表中。这将把该词添加到拼写检查程序的词典中。添加到该"
"列表时，请记住"

#: docs/en/how-to/contribute.md:384
msgid ""
"We prefer US spelling, with some liberties for programming-specific "
"colloquialisms (e.g., \"apps\") and verbing of nouns (e.g., \"scrollable\")"
msgstr "我们倾向于使用美式拼写法，但对程序特定的口语（如 “apps”）和名词的动词化（如 “"
"scrollable”）有一定的自由度"

#: docs/en/how-to/contribute.md:385
msgid ""
"Any reference to a product name should use the product's preferred "
"capitalization. "
"(e.g., \"macOS\", \"GTK\", \"pytest\", \"Pygame\", \"PyScript\")."
msgstr ""
"任何对产品名称的引用都应使用该产品的首选大小写。(例如，“macOS”、“GTK”、"
"“pytest”、“Pygame”、“PyScript”）。"

#: docs/en/how-to/contribute.md:386
msgid ""
"If a term is being used \"as code\", then it should be quoted as inline code "
"rather than being added to the dictionary."
msgstr "如果一个术语是作为代码使用的，那么它应该作为内嵌代码被引用，而不是被添加到词"
"典中。"

#: docs/en/how-to/contribute.md:388
msgid "Translations"
msgstr "翻译"

#: docs/en/how-to/contribute.md:390
#, fuzzy
msgid ""
"The BeeWare tutorial is available in multiple languages, which you can build "
"individually or all at the same time."
msgstr "BeeWare 教程有多种语言版本，您可以单独或同时构建所有语言版本。"

#: docs/en/how-to/contribute.md:392
msgid "Updating translations"
msgstr "更新翻译文件"

#: docs/en/how-to/contribute.md:394
#, fuzzy
msgid ""
"If you have made changes to the English content, the first step to building "
"the translations is to update the translation files. To update the "
"translations:"
msgstr "如果您对英文内容进行了更改，那么构建翻译的第一步就是更新翻译文件。更新翻译文"
"件"

#: docs/en/how-to/contribute.md:420
#, fuzzy
msgid "This will update the"
msgstr "这将更新"

#: docs/en/how-to/contribute.md:422
#, fuzzy
msgid "Building translations"
msgstr "建筑翻译"

#: docs/en/how-to/contribute.md:424
#, fuzzy
msgid ""
"To build a single translation, you run the `docs` command with the language "
"code for the translation you wish to build. For example, to build French:"
msgstr "要编译单个译文，请运行 `docs` 命令，并输入要编译的译文的语言代码。例如，要编"
"译法语："

#: docs/en/how-to/contribute.md:450
#, fuzzy
msgid ""
"The French translation should be built in the `_build/html` folder. If there "
"are any markup problems, they'll raise an error."
msgstr "法文翻译应建在 `_build/html` 文件夹中。如果出现任何标记问题，都会引发错误。"

#: docs/en/how-to/contribute.md:452
#, fuzzy
msgid ""
"An error is also raised if you enter a language code for an unavailable "
"language. If this happens, verify that you are using the proper language "
"code."
msgstr "如果输入了不可用语言的语言代码，也会出现错误。如果出现这种情况，请确认您使用"
"的是正确的语言代码。"

#: docs/en/how-to/contribute.md:454
#, fuzzy
msgid "To build all the translations at the same time:"
msgstr "同时构建所有翻译："

#: docs/en/how-to/contribute.md:480
#, fuzzy
msgid ""
"This will build all available translations in the `_build/html` directory, "
"inside a language-specific subdirectory. For example, the French translation "
"would be available in `_build/html/fr`."
msgstr "这将在 `_build/html`目录下的特定语言子目录内构建所有可用的翻译。例如，法语翻"
"译将放在 `_build/html/fr`。"

#: docs/en/how-to/contribute.md:482
#, fuzzy
msgid "What to work on?"
msgstr "要做什么？"

#: docs/en/how-to/contribute.md:484
#, fuzzy
msgid ""
"If you're looking for specific areas to improve, there are "
"[tickets tagged \"documentation\"]{1} in BeeWare's issue tracker."
msgstr "如果您正在寻找需要改进的具体方面，BeeWare 的问题跟踪器中有[标记为 \"文档 \"的"
"票据]{1}。"

#: docs/en/how-to/contribute.md:486
#, fuzzy
msgid ""
"However, you don't need to be constrained by these tickets. If you can "
"identify an error in the tutorial, or an improvement that can be made, start "
"writing! Anything that improves the experience of the end user is a welcome "
"change."
msgstr "不过，您不必拘泥于这些罚单。如果您能发现教程中的错误或可以改进的地方，请开始"
"撰写！任何能改善最终用户体验的改变都是值得欢迎的。"

#: docs/en/how-to/contribute.md:488
#, fuzzy
msgid "Submitting a pull request"
msgstr "提交拉取请求"

#: docs/en/how-to/contribute.md:490
#, fuzzy
msgid ""
"Before you submit a pull request, there's a few bits of housekeeping to do."
msgstr "在提交拉取请求之前，您需要做一些内务整理。"

#: docs/en/how-to/contribute.md:492
#, fuzzy
msgid "Submit from a feature branch, not your `main` branch"
msgstr "从特性分支提交，而不是从 \"主 \"分支提交"

#: docs/en/how-to/contribute.md:494
#, fuzzy
msgid ""
"Before you start working on your change, make sure you've created a branch. "
"By default, when you clone your repository fork, you'll be checked out on "
"your `main` branch. This is a direct copy of BeeWare's `main` branch. To "
"contribute to BeeWare itself, not the docs, please review the repo README."
msgstr ""
"在你开始修改之前，请确保你已经创建了一个分支。默认情况下，当您克隆您的分叉仓"
"库时，您将在 \"主 \"分支上签出。这是BeeWare \"主 \"分支的直接拷贝。如需对BeeW"
"are本身（而非文档）做出贡献，请查看版本库的README。"

#: docs/en/how-to/contribute.md:496
#, fuzzy
msgid ""
"While you *can* submit a pull request from your `main` branch, it's "
"preferable if you *don't* do this. If you submit a pull request that is "
"*almost* right, the core team member who reviews your pull request may be "
"able to make the necessary changes, rather than giving feedback asking for a "
"minor change. However, if you submit your pull request from your `main` "
"branch, reviewers are prevented from making modifications."
msgstr ""
"虽然您*可以*从您的 \"主 \"分支提交拉取请求，但最好不要*这样做。如果您提交的拉"
"取请求*几乎*正确，那么审查您的拉取请求的核心团队成员可能会做出必要的修改，而"
"不是给出反馈，要求您做细微的改动。但是，如果你从你的 \"主 \"分支提交拉取请求"
"，审查人员就无法进行修改。"

#: docs/en/how-to/contribute.md:498
#, fuzzy
msgid ""
"Instead, you should make your changes on a *feature branch*. A feature "
"branch has a simple name to identify the change that you've made."
msgstr "相反，你应该在*特性分支*上进行修改。特性分支有一个简单的名称，用来标识你所做"
"的改动。"

#: docs/en/how-to/contribute.md:500
#, fuzzy
msgid "To create a feature branch, run:"
msgstr "要创建功能分支，请运行"

#: docs/en/how-to/contribute.md:526
#, fuzzy
msgid ""
"Commit your changes to this branch, then push to GitHub and create a pull "
"request."
msgstr "将更改提交到此分支，然后推送到 GitHub 并创建拉取请求。"

#: docs/en/how-to/style-guide.md:1
#, fuzzy
msgid "-8<- \"style_guide.md\""
msgstr "-8<- \"style_guide.md\""

#: docs/en/index.md:1
#, fuzzy
msgid "Welcome to the BeeWare Tutorial"
msgstr "欢迎来到 BeeWare 教程!"

#: docs/en/index.md:3
msgid "**Write Python. Run Anywhere.**"
msgstr "**用 Python 编写。随处运行。**"

#: docs/en/index.md:5
msgid ""
"Welcome to BeeWare! In this tutorial, we're going to build a graphical user "
"interface using Python, and deploy it as a desktop application, as a mobile "
"application, and as a single page web app. We'll also look at how you can "
"use BeeWare tools to perform some of the common tasks that you'll need to do "
"as an app developer, such as testing your app."
msgstr ""
"欢迎来到 BeeWare！在本教程中，我们将使用 Python 构建一个图形用户界面，并将其"
"部署为桌面应用程序、移动应用程序和单页网页应用程序。我们还将探讨如何使用 "
"BeeWare 工具执行应用程序开发者需要做的一些常见任务，例如测试你的应用。"

#: docs/en/index.md:7
msgid "{% if config.extra.translation_type == \"original\" %}"
msgstr "{% if config.extra.translation_type == \"original\" %}"

#: docs/en/index.md:9
#, fuzzy
msgid "/// admonition | Translations are available"
msgstr "/// admonition |提供翻译"

#: docs/en/index.md:11
msgid ""
"If you're not comfortable with English, translations of this tutorial are "
"available in [Deutsch]{1}, [Español]{2}, [Français]{3}, [Italiano]{4}, "
"[Português]{5}, [中文(简体)]{6}, and [中文(繁體)]{7}."
msgstr ""
"如果您不熟悉中文，本教程提供了以下语言的翻译：[Deutsch]{1} （德语）、"
"[Español]{2} （西班牙语）、[Français]{3} （法语）、[Italiano]{4} （意大利语）"
"、[Português]{5} （葡萄牙语）、[中文(简体)]{6} （中文（简体））和 [中文(繁體)"
"]{7} （中文（繁体））。"

#: docs/en/index.md:15
#: docs/en/index.md:27
#: docs/en/index.md:39
msgid "{% endif %}"
msgstr "{% endif %}"

#: docs/en/index.md:17
msgid "{% if config.extra.translation_type == \"machine\" %}"
msgstr "{% if config.extra.translation_type == \"machine\" %}"

#: docs/en/index.md:19
#, fuzzy
msgid "/// admonition | This is a machine translation!"
msgstr "/// admonition |这是机器翻译！"

#: docs/en/index.md:21
msgid ""
"This version of the tutorial has been generated by machine translation. We "
"know this isn't ideal, but we felt that a bad translation was better than no "
"translation at all."
msgstr "本教程版本由机器翻译生成。我们知道这并不理想，但我们认为糟糕的翻译总比没有翻"
"译好。"

#: docs/en/index.md:23
#: docs/en/index.md:35
msgid ""
"If you'd like the help improve the translation, get in touch! We have a "
"`#translations` channel in [Discord]{1}. Introduce yourself there and we "
"will add you to the translation team."
msgstr ""
"如果您想帮助改进翻译，请联系我们！我们在 [Discord]{1} 中有一个 "
"`#translations` 频道；在那儿介绍自己，我们会邀请您加入翻译团队。"

#: docs/en/index.md:29
msgid "{% if config.extra.translation_type == \"human\" %}"
msgstr "{% if config.extra.translation_type == \"human\" %}"

#: docs/en/index.md:31
#, fuzzy
msgid "/// admonition | This is a translation!"
msgstr "/// admonition |这是译文！"

#: docs/en/index.md:33
msgid ""
"This document is a translation of the English version. The translation has "
"been reviewed by humans, but newer sections may be generated by machine "
"translation, or not translated at all."
msgstr "本文档是英文文档的翻译。翻译已由人工审核，但较新的部分可能是由机器翻译生成的"
"，或者根本未翻译。"

#: docs/en/index.md:41
msgid "What is BeeWare?"
msgstr "什么是 BeeWare？"

#: docs/en/index.md:43
msgid ""
"BeeWare is not a single product, or tool, or library - it's a collection of "
"tools and libraries, each of which works together to help you write cross "
"platform Python applications with a native GUI. It includes:"
msgstr ""
"BeeWare 并不是一个单独的产品、工具或库 (library)，它是一系列工具和库的集合："
"每个工具和库都能协同工作，帮助您编写跨平台、具有本地图形用户界面的 Python 应"
"用程序。它包括:"

#: docs/en/index.md:45
#, fuzzy
msgid "[Toga]{1}, a cross-platform widget toolkit;"
msgstr "[Toga]{1}，一个跨平台部件工具包；"

#: docs/en/index.md:46
msgid ""
"[Briefcase]{1}, a tool for packaging Python projects as distributable "
"artefacts that can be shipped to end users;"
msgstr "[Briefcase]{1}，一个用于将 Python 项目打包为可分发给最终用户的的成品的工具;"

#: docs/en/index.md:47
msgid ""
"Libraries (such as [Rubicon ObjC]{1}) for accessing platform-native "
"libraries;"
msgstr "用于访问平台原生库的库（如 [Rubicon ObjC]{1}）;"

#: docs/en/index.md:48
msgid ""
"Pre-compiled builds of Python that can be used on platforms where official "
"Python installers aren't available."
msgstr "预编译的 Python 版本，可在官方 Python 安装程序不可用的平台上使用。"

#: docs/en/index.md:50
msgid ""
"In this tutorial, we'll be using all these tools, but as a user, you'll only "
"need to interact with the first two (Toga and Briefcase). However, each of "
"the tools can also be used individually - for example, you can use Briefcase "
"to deploy an app without using Toga as a GUI toolkit."
msgstr ""
"在这个教程中，我们将使用所有这些工具，但作为用户，你只需要与前两个（Toga 和 B"
"riefcase）互动。然而，每个工具也可以单独使用 - 例如，你可以使用Briefcase部署"
"应用程序，而不使用 Toga 作为 GUI 工具包。"

#: docs/en/index.md:52
msgid ""
"The BeeWare suite is available on macOS, Windows, Linux (using GTK); on "
"mobile platforms such as Android and iOS; and for the Web."
msgstr ""
"BeeWare 套件可用于 macOS、Windows、Linux（使用GTK）上；在移动平台如 Android "
"和 iOS 上；以及在 Web 上。"

#: docs/en/index.md:54
#, fuzzy
msgid "Let's go"
msgstr "让我们开始吧！"

#: docs/en/index.md:56
#, fuzzy
msgid ""
"Ready to try BeeWare for yourself? "
"[Let's build a cross-platform application in Python!]{1}"
msgstr "准备好亲身体验BeeWare了吗？[让我们用Python构建一个跨平台应用程序！]{1}."

#: docs/en/tutorial/topics/camera-access.md:1
#, fuzzy
msgid "Using the camera"
msgstr "使用相机"

#: docs/en/tutorial/topics/camera-access.md:3
msgid ""
"Almost every modern computing device has a camera of some sort. In this "
"tutorial, we'll write new application that is able to request access to this "
"camera, take a photograph, and then display that photograph in the new "
"application that uses your device's camera."
msgstr ""
"几乎每一台现代计算机都配备某种类型的摄像头。在本教程中，我们将编写一个新程序"
"，使该程序能够请求访问摄像头、拍摄照片，然后在这个新的应用程序当中显示所拍摄"
"的照片。"

#: docs/en/tutorial/topics/camera-access.md:5
#, fuzzy
msgid "/// admonition | This tutorial won't work on all platforms!"
msgstr "/// admonition |本教程并不适用于所有平台！"

#: docs/en/tutorial/topics/camera-access.md:7
msgid ""
"Unfortunately, at present, this tutorial will only work on macOS and Android."
msgstr "遗憾的是，目前本教程仅适用于 macOS 系统和 Android。"

#: docs/en/tutorial/topics/camera-access.md:9
msgid ""
"Although iPhones all have cameras, the iOS *Simulator* doesn't have a "
"working camera. Windows and Linux devices also have cameras, but Toga "
"doesn't currently have the ability to access the camera on these platforms."
msgstr ""
"虽然所有 iPhone 都有摄像头，iOS *虚拟机*\\ 没有正常工作的摄像头。Windows 与 "
"Linux 设备也有摄像头，但 Toga 目前不提供在这些平台上访问摄像头的能力。"

#: docs/en/tutorial/topics/camera-access.md:11
msgid ""
"The code presented here will *run* on Windows or Linux; but it will raise an "
"error when you try to take a photograph."
msgstr "这里展示的代码可以在 Windows 或 Linux 上运行，但是当您尝试照相时，它会报错。"

#: docs/en/tutorial/topics/camera-access.md:13
msgid ""
"The code will work if it is run on an actual iOS device, but will fail to "
"take a photograph if deployed to the iOS simulator."
msgstr "这段代码在 iOS 设备上会正常工作，但部署到 iOS 虚拟器时，它将无法正常拍照。"

#: docs/en/tutorial/topics/camera-access.md:17
#, fuzzy
msgid "Start a new project"
msgstr "启动新项目"

#: docs/en/tutorial/topics/camera-access.md:19
#, fuzzy
msgid ""
"For this tutorial, we're not going to build onto the application from the "
"core tutorial - we're going to start a fresh project. You can use the same "
"virtual environment you used in the first project; but we need to re-run the "
"`briefcase new` wizard."
msgstr ""
"在本教程中，我们不会在核心教程中的应用程序上进行构建，而是要启动一个全新的项"
"目。您可以使用与第一个项目相同的虚拟环境；但我们需要重新运行 \"新建公文包 \""
"向导。"

#: docs/en/tutorial/topics/camera-access.md:21
#, fuzzy
msgid ""
"Change back to the directory that contains the `helloworld` project folder, "
"and start a new project named \"Hello Camera\":"
msgstr "返回包含 `helloworld` 项目文件夹的目录，并启动名为 \"Hello Camera \"的新项目"
"："

#: docs/en/tutorial/topics/camera-access.md:37
#, fuzzy
msgid "Add code to take a photo"
msgstr "添加拍摄照片的代码"

#: docs/en/tutorial/topics/camera-access.md:39
#, fuzzy
msgid ""
"The wizard has generated a new empty Toga project. We can now add the code "
"to take and display a photograph. Edit the `app.py` for the new application "
"so that it has the following content:"
msgstr "向导已经生成了一个新的空 Toga 项目。现在我们可以添加代码来拍摄并显示照片。编"
"辑新应用程序的 `app.py`，使其包含以下内容："

#: docs/en/tutorial/topics/camera-access.md:92
#, fuzzy
msgid ""
"This code has two changes over the default app that is generated by "
"Briefcase. These additions are highlighted above:"
msgstr "与 Briefcase 生成的默认应用程序相比，这段代码有两处改动。上面突出显示了这些新"
"增内容："

#: docs/en/tutorial/topics/camera-access.md:94
#, fuzzy
msgid ""
"The first highlighted code block (in the `startup()` method) adds the two "
"widgets needed to control the camera: an `ImageView` to display a photo; and "
"a `Button` to trigger the camera."
msgstr ""
"第一个突出显示的代码块（在 `startup()` 方法中）添加了控制摄像头所需的两个部件"
"：显示照片的 `ImageView` 和触发摄像头的 `Button` 。"

#: docs/en/tutorial/topics/camera-access.md:95
#, fuzzy
msgid ""
"The second highlighted code block (the `take_photo()` method) defines the "
"event handler when the button is pressed. This handler first confirms if the "
"application has permission to take a photo; if permission doesn't exist, it "
"is requested. Then, a photo is taken. The request for permission and the "
"request to take a photo are both asynchronous requests, so they require the "
"use of `await`; while the app is waiting for the user to confirm permissions "
"or take the photo, the app's event loop can continue in the background."
msgstr ""
"第二个突出显示的代码块（\"take_photo() \"方法）定义了按下按钮时的事件处理程序"
"。该处理程序首先会确认应用程序是否有拍照权限；如果没有权限，则会请求权限。然"
"后拍摄照片。请求权限和请求拍照都是异步请求，因此需要使用 `await`；当应用程序"
"等待用户确认权限或拍照时，应用程序的事件循环可以在后台继续。"

#: docs/en/tutorial/topics/camera-access.md:97
#, fuzzy
msgid ""
"If the camera successfully takes a photo, it will return an `Image` object "
"that can be assigned as the content of the `ImageView`. If the photo request "
"was canceled by the user, the `self.camera.take_photo()` call will return "
"`None`, and the result can be ignored. If the user doesn't grant permission "
"to use the camera, or the camera isn't implemented on the current platform, "
"an error will be raised, and a dialog will be shown to the user."
msgstr ""
"如果相机成功拍摄了照片，它将返回一个 `Image` 对象，该对象可被分配为 "
"`ImageView` 的内容。如果用户取消了拍照请求，`self.camera.take_photo()` 调用将"
"返回`None`，结果可以忽略。如果用户未授予使用相机的权限，或当前平台未实现相机"
"，则会引发错误，并向用户显示对话框。"

#: docs/en/tutorial/topics/camera-access.md:99
msgid "Adding device permissions"
msgstr "添加设备权限"

#: docs/en/tutorial/topics/camera-access.md:101
#, fuzzy
msgid ""
"Part of this code we've just added asks for permission to use the camera. "
"This is a common feature of modern app platforms - you can't access hardware "
"features without explicitly asking the user's permission first."
msgstr "我们刚刚添加的代码中有一部分要求获得使用摄像头的权限。这是现代应用程序平台的"
"一个共同特点--如果不事先明确征求用户许可，就无法访问硬件功能。"

#: docs/en/tutorial/topics/camera-access.md:103
#, fuzzy
msgid ""
"However, this request comes in two parts. The first is in the code we've "
"just seen; but before the app can ask for permissions, it needs to declare "
"the permissions it is going to ask for."
msgstr "不过，这种请求分为两部分。第一部分在我们刚刚看到的代码中；但在应用程序请求权"
"限之前，它需要声明要请求的权限。"

#: docs/en/tutorial/topics/camera-access.md:105
#, fuzzy
msgid ""
"The permissions required by each platform are slightly different, but "
"Briefcase has a cross-platform representation for many common hardware "
"permissions. In the `[tool.briefcase.app.hellocamera]` configuration section "
"of your app's `pyproject.toml` file, add the following "
"(just above the `sources` declaration):"
msgstr ""
"每个平台所需的权限略有不同，但 Briefcase 为许多常见硬件权限提供了跨平台表示。"
"在应用程序的 `pyproject.toml` 文件的 `[tool.briefcase.app.hellocamera]`配置部"
"分，添加以下内容（就在 `sources` 声明的上方）："

#: docs/en/tutorial/topics/camera-access.md:111
#, fuzzy
msgid ""
"This declares that your app needs to access the camera, and provides a short "
"description why the camera is required. This description is needed on some "
"platforms (most notably macOS and iOS) and will be displayed to the user as "
"a additional information when the permission dialog is presented."
msgstr ""
"这将声明您的应用程序需要访问摄像头，并提供一个简短的说明，说明为什么需要使用"
"摄像头。某些平台（尤其是 macOS 和 iOS）需要此说明，并将在权限对话框显示时作为"
"附加信息显示给用户。"

#: docs/en/tutorial/topics/camera-access.md:113
msgid "We can now generate and run the app:"
msgstr "我们现在可以生成并运行应用程序："

#: docs/en/tutorial/topics/camera-access.md:125
#: docs/en/tutorial/topics/custom-icons.md:81
#: docs/en/tutorial/topics/custom-icons.md:271
#: docs/en/tutorial/topics/custom-icons.md:418
#: docs/en/tutorial/tutorial-7.md:100
#: docs/en/tutorial/tutorial-7.md:165
#: docs/en/tutorial/tutorial-7.md:320
#: docs/en/tutorial/tutorial-7.md:565
#: docs/en/tutorial/tutorial-8.md:122
#: docs/en/tutorial/tutorial-8.md:237
msgid "/// tab | Android"
msgstr "/// tab | Android"

#: docs/en/tutorial/topics/camera-access.md:135
#, fuzzy
msgid ""
"When the app runs, you'll be presented with a button. Press the button, and "
"the platform's default camera dialog will be displayed. Take a photo; the "
"camera dialog will disappear, and the photo will be displayed on in the app, "
"just above the button. You could then take another photo; this will replace "
"the first photo."
msgstr ""
"程序运行时，会出现一个按钮。按下按钮后，平台的默认相机对话框就会显示。拍照后"
"，相机对话框将消失，照片将显示在应用程序中，就在按钮上方。然后，您可以再拍一"
"张照片；这张照片将取代第一张照片。"

#: docs/en/tutorial/topics/camera-access.md:137
#, fuzzy
msgid "Adding more permissions"
msgstr "添加设备权限"

#: docs/en/tutorial/topics/camera-access.md:139
#, fuzzy
msgid ""
"Permissions are declared in the files that are generated during the original "
"call to `briefcase create`. Unfortunately, Briefcase can't update these "
"files once they've been initially generated; so if you want to add a new "
"permission to your app, or modify existing permissions, you'll need to re-"
"create the app. You can do this by re-running `briefcase create`; this will "
"warn you that the existing app will be overwritten, and then regenerate the "
"application with the new permissions."
msgstr ""
"权限声明在最初调用 `briefcase create` 时生成的文件中。不幸的是，Briefcase 无"
"法在最初生成这些文件后对其进行更新；因此，如果您想在应用程序中添加新权限或修"
"改现有权限，则需要重新创建应用程序。您可以通过重新运行 `briefcase create` 来"
"做到这一点；这将警告您现有的应用程序将被覆盖，然后用新的权限重新生成应用程序"
"。"

#: docs/en/tutorial/topics/custom-icons.md:1
#, fuzzy
msgid "Customizing icons"
msgstr "自定义图标"

#: docs/en/tutorial/topics/custom-icons.md:3
msgid ""
"The app we developed in the main tutorial uses a default \"gray bee\" icon "
"when it is packaged. Let's personalize this application by configuring it to "
"use our own icon."
msgstr "我们在主教程中开发的应用在打包时使用了默认的 “灰色蜜蜂” 图标。让我们通过配置"
"使用我们自己的图标来个性化此应用程序。"

#: docs/en/tutorial/topics/custom-icons.md:5
msgid "Adding an icon"
msgstr "添加图标"

#: docs/en/tutorial/topics/custom-icons.md:7
msgid ""
"Every platform uses a different format for application icons - and some "
"platforms need *multiple* icons in different sizes and shapes. To account "
"for this, Briefcase provides a shorthand way to configure an icon once, and "
"then have that definition expand in to all the different icons needed for "
"each individual platform."
msgstr ""
"每个平台都使用不同的应用程序图标格式 -- 有些还需要\\ *多个*\\ 不同大小和形状"
"的。为此考虑，Briefcase 提供了一种简短的方法，可以配置一次图标，并让这种定义"
"扩充到每个单个平台的所有所需要的图标。"

#: docs/en/tutorial/topics/custom-icons.md:9
msgid ""
"Edit your `pyproject.toml`, adding a new `icon` configuration item in the `"
"[tool.briefcase.app.helloworld]` configuration section, just above the "
"`sources` definition:"
msgstr ""
"编辑您的 `project.toml`，在 `[tool.briefcase.app.helloworld]` 配置部分中，在 "
"`sources` 的正上方添加一个 `icon` 配置项:"

#: docs/en/tutorial/topics/custom-icons.md:15
msgid ""
"This icon definition doesn't specify any file extension. The value will be "
"used as a prefix; each platform will add additional items to this prefix to "
"build the files needed for each platform. Some platforms require *multiple* "
"icon files; this prefix will be combined with file size and variant "
"modifiers to generate the list of icon files that are used."
msgstr ""
"图标配置时，无需指定任何扩展文件名。这里的值将会被作为前缀使用；每个平台将会"
"在此前缀基础上添加更多项目，以构建在那个平台上所需的文件。有些平台需要\\ *多"
"个*\\ 图标文件；在这种情况下，前缀将与文件大小和变种结合在一起，生成使用的图"
"标列表。"

#: docs/en/tutorial/topics/custom-icons.md:17
msgid ""
"We can now run `briefcase update` again - but this time, we pass in the "
"`--update-resources` flag, telling Briefcase that we want to install new "
"application resources (i.e., the icons):"
msgstr ""
"我们现在可以重新运行 `briefcase update` — 但这次，我们传入 `--update-"
"resources` 标志，以告诉 Briefcase 我们想要安装新的应用资源（图标）："

#: docs/en/tutorial/topics/custom-icons.md:119
#: docs/en/tutorial/topics/custom-icons.md:317
#: docs/en/tutorial/topics/custom-icons.md:434
#: docs/en/tutorial/tutorial-7.md:106
#: docs/en/tutorial/tutorial-7.md:171
#: docs/en/tutorial/tutorial-7.md:395
#: docs/en/tutorial/tutorial-7.md:584
#: docs/en/tutorial/tutorial-8.md:128
#: docs/en/tutorial/tutorial-8.md:245
msgid "/// tab | iOS"
msgstr "/// tab | iOS"

#: docs/en/tutorial/topics/custom-icons.md:153
#, fuzzy
msgid ""
"This reports the specific icon file (or files) that Briefcase is expecting. "
"However, as we haven't provided the actual icon files, the install fails, "
"and Briefcase falls back to a default value (the same \"gray bee\" icon)."
msgstr ""
"这将报告 Briefcase 期望的特定图标文件（或多个文件）。但是，由于我们没有提供实"
"际的图标文件，安装失败，Briefcase 恢复到默认值（相同的 \"灰色蜜蜂 \"图标）。"

#: docs/en/tutorial/topics/custom-icons.md:155
#, fuzzy
msgid ""
"Let's provide some actual icons. Download [this icons.zip bundle]{1}, and "
"unzip it into the root of your project directory. After unzipping, your "
"project directory should look something like:"
msgstr ""
"让我们提供一些实际的图标。下载 [this icons.zip bundle]{1}，并解压到项目目录根"
"目录。解压缩后，你的项目目录应该如下所示："

#: docs/en/tutorial/topics/custom-icons.md:174
#, fuzzy
msgid ""
"There's a *lot* of icons in this folder, but most of them should look the "
"same: a green snake on a light blue background:"
msgstr "这个文件夹中有很多图标，但大多数看起来都一样：浅蓝色背景上有一条绿色的蛇："

#: docs/en/tutorial/topics/custom-icons.md:176
#, fuzzy
msgid "![Icon of green snake with a light blue background]{1}"
msgstr "浅蓝色背景下的绿蛇图标]{1}。"

#: docs/en/tutorial/topics/custom-icons.md:178
#: docs/en/tutorial/tutorial-1.md:169
#: docs/en/tutorial/tutorial-1.md:179
#: docs/en/tutorial/tutorial-1.md:189
#: docs/en/tutorial/tutorial-2.md:271
#: docs/en/tutorial/tutorial-2.md:281
#: docs/en/tutorial/tutorial-2.md:291
#: docs/en/tutorial/tutorial-4.md:33
#: docs/en/tutorial/tutorial-4.md:43
#: docs/en/tutorial/tutorial-4.md:53
#: docs/en/tutorial/tutorial-5/android.md:224
#: docs/en/tutorial/tutorial-5/android.md:234
#: docs/en/tutorial/tutorial-5/android.md:244
#: docs/en/tutorial/tutorial-5/android.md:260
#: docs/en/tutorial/tutorial-5/iOS.md:99
#: docs/en/tutorial/tutorial-7.md:125
#: docs/en/tutorial/tutorial-7.md:142
#: docs/en/tutorial/tutorial-7.md:159
#: docs/en/tutorial/tutorial-7.md:218
#: docs/en/tutorial/tutorial-7.md:314
#: docs/en/tutorial/tutorial-8.md:74
#: docs/en/tutorial/tutorial-8.md:95
#: docs/en/tutorial/tutorial-8.md:116
msgid "/// caption"
msgstr "/// caption"

#: docs/en/tutorial/topics/custom-icons.md:182
#, fuzzy
msgid ""
"The only exception will be the icons with `-adaptive-` in their name; these "
"will have a transparent background. This represents all the different icon "
"sizes and shapes you need to support an app on every platform that Briefcase "
"supports."
msgstr ""
"唯一的例外是名称中带有\"-adaptive-\"的图标；这些图标将有透明背景。这代表了在 "
"Briefcase 支持的每个平台上支持应用程序所需的所有不同图标尺寸和形状。"

#: docs/en/tutorial/topics/custom-icons.md:184
#, fuzzy
msgid ""
"Now that we have icons, we can update the application again. However, `"
"briefcase update` will only copy the updated resources into the build "
"directory; we also want to rebuild the app to make sure the new icon is "
"included, then start the app. We can shortcut this process by passing "
"`--update-resources` to our call to `run` - this will update the app, update "
"the app's resources, and then start the app:"
msgstr ""
"现在我们有了图标，可以再次更新应用程序了。不过，\"briefcase update \"只会将更"
"新后的资源复制到构建目录中；我们还需要重建应用程序以确保包含新图标，然后启动"
"应用程序。我们可以通过在调用 `run` 时传递 `--update-resources`来缩短这一过程"
"，这将更新应用程序，更新应用程序的资源，然后启动应用程序："

#: docs/en/tutorial/topics/custom-icons.md:309
#: docs/en/tutorial/topics/custom-icons.md:353
#: docs/en/tutorial/tutorial-2.md:107
#: docs/en/tutorial/tutorial-2.md:157
#: docs/en/tutorial/tutorial-4.md:124
#: docs/en/tutorial/tutorial-7.md:610
#, fuzzy
msgid "/// note | Note"
msgstr "/// note |备注"

#: docs/en/tutorial/topics/custom-icons.md:311
#, fuzzy
msgid ""
"If you're using a recent version of Android, you may notice that the app "
"icon has been changed to a green snake, but the background of the icon is "
"*white*, rather than light blue. We'll fix this in the next step."
msgstr ""
"如果您使用的是最新版本的安卓系统，您可能会注意到应用程序图标已更改为绿色的蛇"
"形，但图标的背景却是*白色*，而不是浅蓝色。我们将在下一步中解决这个问题。"

#: docs/en/tutorial/topics/custom-icons.md:355
#, fuzzy
msgid ""
"If you get a stack trace referencing `faker` or `httpx` when you run the "
"app, it's possible you missed running your app during step 7 or 8 of the "
"tutorial. Re-run the app, adding the `-r` argument to update the app "
"requirements."
msgstr ""
"如果在运行应用程序时出现引用 `faker` 或 `httpx` 的堆栈跟踪，则有可能是在教程"
"的第 7 或第 8 步中没有运行应用程序。重新运行应用程序，添加 `-r` 参数以更新应"
"用程序需求。"

#: docs/en/tutorial/topics/custom-icons.md:359
#, fuzzy
msgid ""
"When you run the app on iOS or Android, in addition to the icon change, you "
"should also notice that the splash screen incorporates the new icon. "
"However, the light blue background of the icon looks a little out of place "
"against the white background of the splash screen. We can fix this by "
"customizing the background color of the splash screen. Add the following "
"definition to your `pyproject.toml`, just after the `icon` definition:"
msgstr ""
"在 iOS 或 Android 上运行应用程序时，除了图标的变化外，您还会发现闪屏也加入了"
"新图标。不过，图标的淡蓝色背景与闪屏的白色背景显得有些格格不入。我们可以通过"
"自定义闪屏的背景颜色来解决这个问题。将以下定义添加到 `pyproject.toml` 中，就"
"在 icon` 定义之后："

#: docs/en/tutorial/topics/custom-icons.md:365
#, fuzzy
msgid ""
"Unfortunately, Briefcase isn't able to apply this change to an already "
"generated project, as it requires making modifications to one of the files "
"that was generated during the original call to `briefcase create`. To apply "
"this change, we have to re-create the app by re-running `briefcase create`. "
"When we do this, we'll be prompted to confirm that we want to overwrite the "
"existing project:"
msgstr ""
"不幸的是，Briefcase 无法将此更改应用于已生成的项目，因为这需要修改在最初调用 "
"`briefcase create` 时生成的文件之一。要应用这一更改，我们必须通过重新运行 `"
"briefcase create` 来重新创建应用程序。当我们这样做时，系统会提示我们确认是否"
"要覆盖现有项目："

#: docs/en/tutorial/topics/custom-icons.md:450
#, fuzzy
msgid ""
"You can then re-build and re-run the app using `briefcase run`. You won't "
"notice any changes to the desktop app; but the Android or iOS apps should "
"now have a light blue splash screen background."
msgstr ""
"然后，您可以使用 \"briefcase run \"重新构建和运行应用程序。您不会注意到桌面应"
"用程序有任何变化；但安卓或 iOS 应用程序现在应该有一个淡蓝色的闪屏背景。"

#: docs/en/tutorial/topics/custom-icons.md:452
#, fuzzy
msgid ""
"You'll need to re-create the app like this whenever you make a change to "
"your `pyproject.toml` that doesn't relate to source code or dependencies. "
"Any change to descriptions, version numbers, colors, or permissions will "
"require a re-create step. Because of this, while you are developing your "
"project, you shouldn't make any manual changes to the contents of the `build`"
" folder, and you shouldn't add the `build` folder to your version control "
"system. The `build` folder should be considered entirely ephemeral - an "
"output of the build system that can be recreated as needed to reflect the "
"current configuration of your project."
msgstr ""
"每当您对 `pyproject.toml`进行与源代码或依赖关系无关的更改时，都需要像这样重新"
"创建应用程序。对描述、版本号、颜色或权限的任何更改都需要重新创建步骤。因此，"
"在开发项目时，不应手动更改 `build` 文件夹的内容，也不应将 `build` 文件夹添加"
"到版本控制系统中。build \"文件夹应被视为完全短暂的，它是构建系统的输出，可根"
"据需要重新创建，以反映项目的当前配置。"

#: docs/en/tutorial/topics/index.md:3
msgid ""
"Want to go deeper on specific topics? Here are some additional tutorials "
"that explore common aspects of application development. Each tutorial is "
"standalone, and can be completed in any order; but they all assume you've "
"completed the core tutorial."
msgstr "想在一些主题更加深入吗？这里有一些探索应用程序开发的常见方面的教程。教程互相"
"独立，可以任意顺序完成，但它们都假设您已学习了主教程。"

#: docs/en/tutorial/topics/index.md:7
msgid ""
"Customize your application's appearance by replacing the default \"gray bee\""
" icon."
msgstr "替换“灰蜜蜂”图标以自定义您的应用程序的外观。"

#: docs/en/tutorial/topics/index.md:11
msgid ""
"Use the camera on your mobile or desktop device to take and view a picture "
"from within your application."
msgstr "使用在移动或桌面设备上的相机在您的应用程序中拍与查看图片。"

#: docs/en/tutorial/topics/index.md:15
msgid ""
"How do you ensure that your application works, and stays working? By adding "
"a test suite to your project!"
msgstr "怎样确保您的应用程序始终正常工作？向您的项目加入一个测试组！"

#: docs/en/tutorial/topics/testing.md:1
msgid "Testing times"
msgstr "测试时间"

#: docs/en/tutorial/topics/testing.md:3
msgid ""
"Most software development doesn't involve writing new code - it's modifying "
"existing code. Ensuring that existing code continues to work in the way we "
"expect is a key part of the software development process. One way to do "
"ensure the behavior of our app is with a *test suite*."
msgstr ""
"大多数软件开发并不涉及编写新代码，而是修改现有代码。确保现有代码以我们期望的"
"方式继续正常工作是软件开发过程的关键部分。确保应用程序行为的方法之一是使用一"
"个\\ *测试套件*。"

#: docs/en/tutorial/topics/testing.md:5
msgid "Running the test suite"
msgstr "运行测试套件"

#: docs/en/tutorial/topics/testing.md:7
msgid ""
"It turns out the project from the core tutorial already has a test suite! "
"When we originally generated our project, two top-level directories were "
"generated: `src` and `tests`. The `src` folder contains the code for our app;"
" the `tests` folder contains our test suite. Inside the `tests` folder is a "
"file named `test_app.py` with the following content:"
msgstr ""
"原来我们的项目已经有了一个测试套件！我们最初生成项目时，会生成两个顶级目录：["
"`src`\\ 和\\ `tests`。`src`\\ 文件夹包含应用程序的代码；`tests`\\ 文件夹包含"
"测试套件。在\\ `tests`\\ 文件夹中，有一个名为\\ `test_app.py`\\ 的文件，内容"
"如下:"

#: docs/en/tutorial/topics/testing.md:15
#, fuzzy
msgid ""
"This is a [Pytest]{1} *test case* - a block of code that can be executed to "
"verify some behavior of your app. In this case, the test is a placeholder, "
"and doesn't test anything about our app - but it is a test that we can "
"perform."
msgstr ""
"这是一个 [Pytest]{1}*测试用例*--可用于验证应用程序某些行为的代码块。在本例中"
"，该测试是一个占位符，并不测试我们应用程序的任何内容，但我们可以执行该测试。"

#: docs/en/tutorial/topics/testing.md:17
msgid ""
"We can run this test suite using the `--test` option to `briefcase dev`. As "
"this is the first time we are running tests, we also need to pass in the `-r`"
" option to ensure that the test requirements are also installed:"
msgstr ""
"我们可以使用 `briefcase dev` 的 `--test` 选项来运行这个测试套件。由于这是第一"
"次运行测试，我们还需要传递 `-r` 选项，以确保测试以来想也已安装："

#: docs/en/tutorial/topics/testing.md:100
msgid ""
"Success! We've just executed a single test that verifies Python math works "
"in the way we'd expect (What a relief!)."
msgstr "成功了！我们刚刚执行了一个测试，验证了 Python 数学以我们预期的方式运行（真是"
"松了一口气！）。"

#: docs/en/tutorial/topics/testing.md:102
msgid ""
"Let's replace this placeholder test with a test to verify that our "
"`greeting()` method behaves the way we'd expect. Replace the contents of "
"`test_app.py` with the following:"
msgstr ""
"让我们用一个测试来替换这个占位符测试，以验证我们的 `greeting()` 方法是否按照"
"我们预期的方式运行。用以下内容替换 `test_app.py` 中的内容:"

#: docs/en/tutorial/topics/testing.md:120
msgid ""
"This defines two new tests, verifying the two behaviors we expect to see: "
"the output when a name is provided, and the output when the name is empty."
msgstr "这将定义两个新测试，验证我们期望看到的两种行为：提供名称时的输出和名称为空时"
"的输出。"

#: docs/en/tutorial/topics/testing.md:122
msgid ""
"We can now re-run the test suite. This time, we don't need to provided the "
"`-r` option, as the test requirements have already been installed; we only "
"need to use the `--test` option:"
msgstr "现在我们可以重新运行测试套件。这一次，我们不需要提供 `-r` 选项，因为测试需求"
"已经安装完毕；我们只需要使用 `--test` 选项："

#: docs/en/tutorial/topics/testing.md:181
msgid "Excellent! Our `greeting()` utility method is working as expected."
msgstr "非常好！我们的 `greeting()` 实用程序方法如期工作了。"

#: docs/en/tutorial/topics/testing.md:183
msgid "Test driven development"
msgstr "测试驱动开发"

#: docs/en/tutorial/topics/testing.md:185
msgid ""
"Now that we have a test suite, we can use it to drive the development of new "
"features. Let's modify our app to have a special greeting for one particular "
"user. We can start by adding a test case for the new behavior that we'd like "
"to see to the bottom of `test_app.py`:"
msgstr ""
"现在我们有了测试套件，可以用它来推动新功能的开发。让我们修改应用程序，为某位"
"用户添加特殊的问候语。首先，我们可以在 `test_app.py` 的底部为我们希望看到的新"
"行为添加一个测试用例:"

#: docs/en/tutorial/topics/testing.md:194
msgid "Then, run the test suite with this new test:"
msgstr "然后，用这个新测试运行测试套件："

#: docs/en/tutorial/topics/testing.md:300
msgid ""
"This time, we see a test failure - and the output explains the source of the "
"failure: the test is expecting the output \"BeeWare the IDEs of Python!\", "
"but our implementation of `greeting()` is returning \"Hello, Brutus\". Let's "
"modify the implementation of `greeting()` in `src/helloworld/app.py` to have "
"the new behavior:"
msgstr ""
"这一次，我们看到了测试失败--输出结果解释了失败的原因：测试期望输出 "
"\"BeeWare the IDEs of Python!\"，但我们的 `greeting()` 实现却返回 "
"\"Hello, Brutus\"。让我们修改 `src/helloworld/app.py` 中 `greeting()` 的实现"
"，使其具有新的行为:"

#: docs/en/tutorial/topics/testing.md:313
msgid "If we run the tests again, we'll now see our tests pass:"
msgstr "如果我们再次运行测试，就会发现测试通过了："

#: docs/en/tutorial/topics/testing.md:375
msgid "Runtime tests"
msgstr "运行时测试"

#: docs/en/tutorial/topics/testing.md:377
msgid ""
"So far, we've been running the tests in development mode. This is especially "
"useful when you're developing new features, as you can rapidly iterate on "
"adding tests, and adding code to make those tests pass. However, at some "
"point, you'll want to verify that your code also runs correctly when inside "
"the bundle app environment."
msgstr ""
"到目前为止，我们一直在开发模式下运行测试。这在开发新功能时尤其有用，因为您可"
"以快速迭代添加测试，并添加代码使测试通过。不过，在某些情况下，您会希望验证您"
"的代码在捆绑应用程序环境下是否也能正确运行。"

#: docs/en/tutorial/topics/testing.md:379
msgid ""
"The `--test` and `-r` options can also be passed to the `run` command. If "
"you use `briefcase run --test -r`, the same test suite will run, but it will "
"run inside the packaged application bundle rather than your development "
"environment:"
msgstr ""
"`-test` 和 `-r` 选项也可以传递给 `run` 命令。如果使用 `briefcase run --test "
"-r`，将运行相同的测试套件，但它将在打包的应用程序捆绑包内运行，而不是在开发环"
"境中运行："

#: docs/en/tutorial/topics/testing.md:498
msgid ""
"As with `briefcase dev --test`, the `-r` option is only needed the first "
"time you run the test suite to ensure that the test dependencies are "
"present. On subsequent runs, you can omit this option."
msgstr ""
"与 `briefcase dev --test` 一样，只有在第一次运行测试套件时才需要使用 `-r` 选"
"项，以确保测试依赖项的存在。以后运行时，可以省略该选项。"

#: docs/en/tutorial/topics/testing.md:500
msgid ""
"You can also use the `--test` option on mobile backends: - so `briefcase run "
"iOS --test` and `briefcase run android --test` will both work, running the "
"test suite on the mobile device you select."
msgstr ""
"你也可以在移动后端使用 `--test` 选项：`briefcase run iOS --test` 和 `"
"briefcase run android --test`` 都可以在你选择的移动设备上运行测试套件。"

#: docs/en/tutorial/tutorial-0.md:1
#, fuzzy
msgid "Tutorial 0 - Let's get set up!"
msgstr "教程 0 - 准备就绪！"

#: docs/en/tutorial/tutorial-0.md:3
msgid ""
"Before we build our first BeeWare app, we have to make sure we've got all "
"the prerequisites for running BeeWare."
msgstr "在构建第一个使用 BeeWare 的应用程序之前，我们必须确保已具备运行 BeeWare 的所"
"有先决条件。"

#: docs/en/tutorial/tutorial-0.md:5
#, fuzzy
msgid "Install Python { id=\"install-python\" }"
msgstr "安装 Python { id=\"install-python\" }"

#: docs/en/tutorial/tutorial-0.md:7
msgid "The first thing we'll need is a working Python interpreter."
msgstr "首先，我们需要一个正常工作的 Python 解释器。"

#: docs/en/tutorial/tutorial-0.md:11
msgid ""
"If you're on macOS, you can get an official Python installer from "
"[the Python website]{1}. You can use any version of Python from 3.10 or "
"newer (although you should avoid alphas, betas and release candidates). We "
"strongly recommend using Python 3.13 or newer."
msgstr ""
"如果您使用 macOS，您可以从 [Python 网站]{1}_\\ 获取官方安装程序。您可以使用 "
"Python 3.10 以上时任何版本，但避免使用 Alpha、Beta 和候选版本。我们强烈建议使"
"用 Python 3.13 或更新版本。"

#: docs/en/tutorial/tutorial-0.md:13
#, fuzzy
msgid ""
"You can also install Python through [Homebrew]{1}, use [pyenv]{2} to manage "
"multiple Python installs, or use [Anaconda]{3} or [Miniconda]{4}. It doesn't "
"matter *how* you've installed Python - it only matters that you can run "
"`python3` from your terminal and get a working, supported Python interpreter."
msgstr ""
"安装 Python 也有很多其他不同的方法。您可以通过 [homebrew]{1} 安装 Python，或"
"使用 [pyenv]{2}来管理同一台机器上的多个 Python 安装，或使用 [Anaconda]{3} 或 "
"[Miniconda]{4}。*怎么*\\ 安装 Python 并不重要，只要可以从终端运行 `python3` "
"并获取到支持的、正常工作的 Python 解释器即可。"

#: docs/en/tutorial/tutorial-0.md:15
#, fuzzy
msgid ""
"Xcode and the Command-line Developer Tools provide a version of Python; "
"however that Python is version 3.9. Python 3.9 has reached end-of-life, and "
"is no longer supported by Python or BeeWare. You will *not* be able to the "
"Xcode-provided version of Python to run this tutorial."
msgstr ""
"Xcode 和命令行开发工具提供了一个 Python 版本，但该 Python 版本为 3.9。Python "
"3.9 已达到生命周期终点，Python 或 BeeWare 不再支持该版本。您将**无法使用 "
"Xcode 提供的 Python 版本来运行本教程。"

#: docs/en/tutorial/tutorial-0.md:17
#, fuzzy
msgid ""
"To check the version of Python that you have installed, run the following "
"command:"
msgstr "要检查已安装的 Python 版本，请运行以下命令："

#: docs/en/tutorial/tutorial-0.md:23
#, fuzzy
msgid "If Python is installed, you'll see its version number."
msgstr "如果已安装 Python，则会看到其版本号。"

#: docs/en/tutorial/tutorial-0.md:29
msgid ""
"If you're on Linux, you'll install Python using the system package manager "
"(`apt` on Debian/Ubuntu/Mint, `dnf` on Fedora, or `pacman` on Arch)."
msgstr ""
"如果您使用的是 Linux，您将使用系统软件包管理器（Debian/Ubuntu/Mint 上的 `apt`"
"，Fedora 上的 `dnf`，或 Arch 上的 `pacman`）安装 Python。"

#: docs/en/tutorial/tutorial-0.md:31
#, fuzzy
msgid ""
"You should ensure that the system Python is Python 3.10 or newer; if it "
"isn't (e.g., Ubuntu 20.04 ships with Python 3.8), you'll need to upgrade "
"your Linux distribution to something more recent."
msgstr ""
"您应该确保系统 Python 是 Python 3.9 或更高；如果不是（例如，Ubuntu 20.04 附带"
" Python 3.8），您需要将您的 Linux 发行版升级到更新版本。"

#: docs/en/tutorial/tutorial-0.md:33
msgid "Support for Raspberry Pi is limited at this time."
msgstr "目前对 Raspberry Pi 的支持有限。"

#: docs/en/tutorial/tutorial-0.md:35
#, fuzzy
msgid ""
"**Important:** You *must* use the system Python provided by your operating "
"system. Alternative Python installations "
"(pyenv, Anaconda, manually compiled Python, etc.) will prevent you from "
"successfully packaging your application for distribution in later steps of "
"this tutorial."
msgstr ""
"**重要：** 您**必须**使用操作系统提供的系统 Python。其他 Python 安装（pyenv、"
"Anaconda、手动编译的 Python 等）将导致您无法在本教程后面的步骤中成功打包发布"
"应用程序。"

#: docs/en/tutorial/tutorial-0.md:41
#, fuzzy
msgid ""
"If you're on Windows, you can get the official installer from "
"[the Python website]{1}. You can use any version of Python from 3.10 to 3.13 "
"(although you should avoid alphas, betas and release candidates). We "
"strongly recommend using Python 3.13."
msgstr ""
"如果您使用的是 Windows，您可以从 [Python 网站]{1}\\ 获取官方安装程序。您可以"
"使用 Python 3.9 到 3.13 的任何稳定版本。我们还建议避免使用 Alpha、Beta 和候选"
"版本，除非你\\ *真的*\\ 知道自己在做什么。"

#: docs/en/tutorial/tutorial-0.md:43
#, fuzzy
msgid "Support for Windows on ARM64 is limited at this time."
msgstr "目前对 Raspberry Pi 的支持有限。"

#: docs/en/tutorial/tutorial-0.md:45
#, fuzzy
msgid ""
"You can also install Python from the Windows App Store, or use [Anaconda]{1} "
"or [Miniconda]{2}. It doesn't matter *how* you've installed Python - it only "
"matters that you can run `python3` from your command prompt and get a "
"working, supported Python interpreter."
msgstr ""
"安装 Python 也有很多其他不同的方法。您可以通过 [homebrew]{1} 安装 Python，或"
"使用 [pyenv]{2}来管理同一台机器上的多个 Python 安装，或使用 [Anaconda]{3} 或 "
"[Miniconda]{4}。*怎么*\\ 安装 Python 并不重要，只要可以从终端运行 `python3` "
"并获取到支持的、正常工作的 Python 解释器即可。"

#: docs/en/tutorial/tutorial-0.md:49
#, fuzzy
msgid "Install dependencies { id=\"install-dependencies\" }"
msgstr "安装依赖项 { id=\"install-dependencies\" }"

#: docs/en/tutorial/tutorial-0.md:51
msgid ""
"Next, install the additional dependencies needed for your operating system:"
msgstr "接下来，安装您的操作系统所需的其他依赖项："

#: docs/en/tutorial/tutorial-0.md:55
msgid "Building BeeWare apps on macOS requires:"
msgstr "在 macOS 上构建 BeeWare 应用程序需要："

#: docs/en/tutorial/tutorial-0.md:57
msgid ""
"**Git**, a version control system. This is included with Xcode or the "
"command line developer tools, which you installed above. You may need to "
"open Xcode for the first time in order for Git to work in your terminal "
"session. If it still doesn't register that Git is installed, you may need to "
"restart your terminal session."
msgstr ""
"**Git**，一个版本控制系统。上面已安装的 Xcode 或其命令行开发工具已经包含了Git"
"。您可能需要第一次打开 Xcode 以后才能再命令行会话中使Git正常工作。如果仍然无"
"法识别 Git，可能需要重启您的命令行会话。"

#: docs/en/tutorial/tutorial-0.md:63
msgid ""
"To support local development, you'll need to install some system packages. "
"The list of packages required varies depending on your distribution:"
msgstr "为支持本地开发，您将需要安装一些系统软件包。所需的软件包列表因发行版而异："

#: docs/en/tutorial/tutorial-0.md:65
#, fuzzy
msgid "Ubuntu / Debian"
msgstr "**Ubuntu 或 Debian**"

#: docs/en/tutorial/tutorial-0.md:72
#, fuzzy
msgid "Fedora"
msgstr "Fedora"

#: docs/en/tutorial/tutorial-0.md:78
#, fuzzy
msgid "Arch / Manjaro"
msgstr "**Arch 或 Manjaro**"

#: docs/en/tutorial/tutorial-0.md:84
#, fuzzy
msgid "OpenSUSE Tumbleweed"
msgstr "**OpenSUSE Tumbleweed**"

#: docs/en/tutorial/tutorial-0.md:94
msgid "Building BeeWare apps on Windows requires:"
msgstr "在 Windows 上构建 BeeWare 应用程序需要："

#: docs/en/tutorial/tutorial-0.md:96
#, fuzzy
msgid ""
"**Git**, a version control system. You can download Git from from {1}[git-"
"scm.com]{2}."
msgstr "**Git**，一个版本控制系统。您可以从 [git-scm.com]{1} 下载 Git。"

#: docs/en/tutorial/tutorial-0.md:98
msgid ""
"After installing these tools, you should ensure you restart any terminal "
"sessions. Windows will only expose newly installed tools terminals started "
"*after* the install has completed."
msgstr "安装这些工具后，应确保重新启动任何终端会话。Windows 只在安装完成后开始的命令"
"行*才*会暴露新安装的工具。"

#: docs/en/tutorial/tutorial-0.md:102
msgid "Set up a virtual environment"
msgstr "建立虚拟环境"

#: docs/en/tutorial/tutorial-0.md:104
msgid ""
"We're now going to create a virtual environment - a \"sandbox\" that we can "
"use to isolate our work on this tutorial from our main Python installation. "
"If we install packages into the virtual environment, our main Python "
"installation (and any other Python projects on our computer) won't be "
"affected. If we make a complete mess of our virtual environment, we'll be "
"able to simply delete it and start again, without affecting any other Python "
"project on our computer, and without the need to re-install Python."
msgstr ""
"我们现在要创建一个虚拟环境--一个 \"沙箱\"，用来将本教程的工作与我们的主 "
"Python 安装隔离开来。如果我们将软件包安装到虚拟环境中，我们的主 Python 安装（"
"以及计算机上的任何其他 Python 项目）将不会受到影响。如果我们把虚拟环境弄得一"
"团糟，我们可以简单地删除它，然后重新开始，不会影响计算机上的任何其他 Python "
"项目，也不需要重新安装 Python。"

#: docs/en/tutorial/tutorial-0.md:137
msgid ""
"If you're not using Python 3.12, replace the `-3.12` in these instructions "
"with the version number that you are using."
msgstr "如果您不在使用 Python 3.12，将指示中的 `-3.12` 替换为您在使用的版本号。"

#: docs/en/tutorial/tutorial-0.md:139
#, fuzzy
msgid "/// admonition | Errors running PowerShell Scripts"
msgstr "/// admonition |运行 PowerShell 脚本时出现的错误"

#: docs/en/tutorial/tutorial-0.md:141
msgid "If you're using PowerShell, and you receive the error:"
msgstr "如果使用 PowerShell 时收到以下错误信息:"

#: docs/en/tutorial/tutorial-0.md:147
msgid ""
"Your Windows account doesn't have permissions to run scripts. To fix this:"
msgstr "您的 Windows 账户没有运行脚本的权限。要解决这个问题："

#: docs/en/tutorial/tutorial-0.md:149
msgid "Run [Windows PowerShell as Administrator]{1}."
msgstr "[以管理员身份运行 PowerShell]{1}."

#: docs/en/tutorial/tutorial-0.md:150
msgid "Run `set-executionpolicy RemoteSigned`"
msgstr "运行 `set-executionpolicy RemoteSigned`"

#: docs/en/tutorial/tutorial-0.md:151
msgid "Select `Y` to change the execution policy."
msgstr "选择 `Y` 更改执行策略。"

#: docs/en/tutorial/tutorial-0.md:153
msgid ""
"Once you've done this you can rerun `beeware-venv\\Scripts\\activate.ps1` in "
"your original PowerShell session (or a new session in the same directory)."
msgstr ""
"完成后，您就可以在原来的 PowerShell 会话（或同一目录下的新会话）中重新运行 "
"`beeware-venv\\scripts\\activate.ps1`。"

#: docs/en/tutorial/tutorial-0.md:159
msgid ""
"If this worked, your prompt should now be changed - it should have a "
"`(beeware-venv)` prefix. This lets you know that you're currently in your "
"BeeWare virtual environment. Whenever you're working on this tutorial, you "
"should make sure your virtual environment is activated. If it isn't, re-run "
"the last command (the `activate` command) to re-activate your environment."
msgstr ""
"如果这样做成功了，您的提示符现在应该有所改变--它会带有 `(beeware-venv)` 前缀"
"。这样，您就可以知道您当前正处于 BeeWare 虚拟环境中。无论何时运行本教程，都应"
"确保虚拟环境已激活。如果没有激活，请重新执行前一条命令（`activate`）以重新激"
"活虚拟环境。"

#: docs/en/tutorial/tutorial-0.md:161
#, fuzzy
msgid "/// admonition | Alternative virtual environments"
msgstr "/// admonition |替代虚拟环境"

#: docs/en/tutorial/tutorial-0.md:163
#, fuzzy
msgid ""
"If you're using Anaconda or miniconda, you may be more familiar with using "
"conda environments. You might also have heard of `virtualenv`, a predecessor "
"to Python's built in `venv` module. As with Python installs -if you're on "
"macOS or Windows, it doesn't matter *how* you create your virtual "
"environment, as long as you have one. If you're on Linux, you should stick "
"to `venv` and the system Python."
msgstr ""
"如果您使用的是 Anaconda 或 miniconda，您可能更熟悉使用 conda 环境。您可能还听"
"说过 `virtualenv`，它是 Python 内置的 `venv` 模块的前身。就像 Python 的安装一"
"样，如果你使用的是 macOS 或 Windows，那么如何创建虚拟环境并不重要，只要有一个"
"就够了。如果您在 Linux 上，则应坚持使用 `venv` 和系统 Python。"

#: docs/en/tutorial/tutorial-0.md:167
#: docs/en/tutorial/tutorial-1.md:213
#: docs/en/tutorial/tutorial-2.md:301
#: docs/en/tutorial/tutorial-3.md:463
#: docs/en/tutorial/tutorial-4.md:232
#: docs/en/tutorial/tutorial-5/android.md:343
#: docs/en/tutorial/tutorial-5/iOS.md:123
#: docs/en/tutorial/tutorial-6.md:149
#: docs/en/tutorial/tutorial-7.md:630
#: docs/en/tutorial/tutorial-8.md:255
msgid "Next steps"
msgstr "下一步"

#: docs/en/tutorial/tutorial-0.md:169
#, fuzzy
msgid ""
"We've now set up our environment. We're ready to "
"[create our first BeeWare application]{1}."
msgstr "现在我们已经设置好了环境。我们已经准备创建\\ [您的第一个应用程序]{1}\\ 了。"

#: docs/en/tutorial/tutorial-1.md:1
#, fuzzy
msgid "Tutorial 1 - Your first app"
msgstr "教程 1 - 您的第一个应用程序"

#: docs/en/tutorial/tutorial-1.md:3
msgid "We're ready to create our first application."
msgstr "我们准备好创建我们的第一个应用程序了。"

#: docs/en/tutorial/tutorial-1.md:5
msgid "Install the BeeWare tools"
msgstr "安装 BeeWare 工具"

#: docs/en/tutorial/tutorial-1.md:7
#, fuzzy
msgid ""
"First, we need to install **Briefcase**. Briefcase is a BeeWare tool that "
"can be used to package your application for distribution to end users - but "
"it can also be used to bootstrap a new project. Make sure you're in the "
"`beeware-tutorial` directory you created in [Tutorial 0]{1}, with the "
"`beeware-venv` virtual environment activated, and run:"
msgstr ""
"首先，我们需要安装 **Briefcase**。Briefcase 是一款 BeeWare 工具，可用于打包应"
"用程序，以便分发给最终用户；但它也可用于引导新项目。确保您在 [教程0]{1} 中创"
"建的 `beeware-tutorial` 目录中，并已激活 `beeware-venv` 虚拟环境，然后运行："

#: docs/en/tutorial/tutorial-1.md:23
#: docs/en/tutorial/tutorial-1.md:37
#, fuzzy
msgid "/// admonition | Possible errors during installation"
msgstr "/// admonition |安装过程中可能出现的错误"

#: docs/en/tutorial/tutorial-1.md:25
#, fuzzy
msgid ""
"If you see errors during installation, it's almost certainly because some of "
"the system requirements haven't been installed. Make sure you have "
"[installed all the platform pre-requisites][install-dependencies]."
msgstr ""
"如果在安装过程中出现错误，几乎可以肯定是因为某些系统要求尚未安装。请确保已[安"
"装所有平台先决条件][install-dependencies]。"

#: docs/en/tutorial/tutorial-1.md:39
msgid ""
"It is important that you use `python -m pip`, rather than a bare `pip`. "
"Briefcase needs to ensure that it has an up-to-date version of `pip` and "
"`setuptools`, and a bare invocation of `pip` can't self-update. If you want "
"to know more, [Brett Cannon has a detailed blog post about the issue]{1}."
msgstr ""
"请务必使用 `python -m pip`，而不是简单的 `pip`。Briefcase 需要确保它拥有最新"
"版本的 `pip` 和 `setuptools` ，而裸调用的 `pip` 无法自我更新。如果您想了解更"
"多，[Brett Cannon 有一篇关于这个问题的详细博文]{1}。"

#: docs/en/tutorial/tutorial-1.md:45
msgid "Bootstrap a new project"
msgstr "引导新项目"

#: docs/en/tutorial/tutorial-1.md:47
#, fuzzy
msgid ""
"Let's start our first BeeWare project! We're going to use the Briefcase `new`"
" command to create an application called **Hello World**. Run the following "
"from your command prompt:"
msgstr ""
"让我们开始第一个 BeeWare 项目！我们将使用 Briefcase `new` 命令创建一个名为 **"
"Hello World** 的应用程序。在命令提示符下运行以下命令"

#: docs/en/tutorial/tutorial-1.md:73
msgid ""
"Briefcase will ask us for some details of our new application. For the "
"purposes of this tutorial, use the following:"
msgstr "Briefcase会要求我们提供新应用程序的一些详细信息。在本教程中，请使用以下内容："

#: docs/en/tutorial/tutorial-1.md:75
msgid "**Formal Name** - Accept the default value: `Hello World`."
msgstr "**Formal Name** - 接受默认值：`Hello World`。"

#: docs/en/tutorial/tutorial-1.md:76
msgid "**App Name** - Accept the default value: `helloworld`."
msgstr "**App Name** - 接受默认值：`helloworld`。"

#: docs/en/tutorial/tutorial-1.md:77
msgid ""
"**Bundle Identifier** - If you own your own domain, enter that domain in "
"reversed order. (For example, if you own the domain \"cupcakes.com\", enter "
"`com.cupcakes` as the bundle). If you don't own your own domain, accept the "
"default bundle (`com.example`)."
msgstr ""
"**Bundle Identifier（捆绑标识符）** - 如果您拥有自己的域名，请按相反顺序输入"
"该域名。(例如，如果您拥有域名 \"cupcakes.com\"，则输入 `com.cupcakes` 作为捆"
"绑标识符）。如果您没有自己的域名，请接受默认值（`com.example`）。"

#: docs/en/tutorial/tutorial-1.md:78
msgid "**Project Name** - Accept the default value: `Hello World`."
msgstr "**Project Name** - 接受默认值：`Hello World`。"

#: docs/en/tutorial/tutorial-1.md:79
msgid ""
"**Description** - Accept the default value "
"(or, if you want to be really creative, come up with your own description!)"
msgstr "**描述** - 接受默认值（或者，如果您想发挥自己的创造力，也可以提出自己的描述！"
"）"

#: docs/en/tutorial/tutorial-1.md:80
msgid "**Author** - Enter your own name here."
msgstr "**Author** - 在此处输入您自己的名字。"

#: docs/en/tutorial/tutorial-1.md:81
msgid ""
"**Author's Email** - Enter your own email address. This will be used in the "
"configuration file, in help text, and anywhere that an email is required "
"when submitting the app to an app store."
msgstr ""
"**Author's Email** - 输入您自己的电子邮件地址。这将用于配置文件、帮助文本以及"
"向应用程序商店提交应用程序时需要电子邮件的任何地方。"

#: docs/en/tutorial/tutorial-1.md:82
msgid ""
"**Application URL** - The URL of the landing page for your application. "
"Again, if you own your own domain, enter a URL at that domain "
"(including the `https://`). Otherwise, just accept the default URL "
"(`https://example.com/helloworld`). This URL doesn't need to actually exist "
"(for now); it will only be used if you publish your application to an app "
"store."
msgstr ""
"**URL** - 应用程序登陆页面的 URL。同样，如果您拥有自己的域名，请输入该域名的 "
"URL（包括 `https://`）。否则，接受默认 URL (`https://example.com/helloworld`)"
" 即可。此 URL（暂时）不需要实际存在；只有在您将应用程序发布到应用程序商店时才"
"会使用。"

#: docs/en/tutorial/tutorial-1.md:83
msgid ""
"**Project License** - Accept the default license (BSD). This won't affect "
"anything about the operation of the tutorial, though - so if you have "
"particularly strong feelings about license choice, feel free to choose "
"another license."
msgstr ""
"**Project License** (项目许可证) - 接受默认许可证（BSD）。这不会影响本教程的"
"任何操作，因此，如果您对许可证选择有特别强烈的意见，请随意选择其他许可证。"

#: docs/en/tutorial/tutorial-1.md:84
msgid ""
"**GUI framework** - Accept the default option, Toga "
"(BeeWare's own GUI toolkit)."
msgstr "**GUI Framework** - 接受默认选项 Toga（BeeWare 自己的图形用户界面工具包）。"

#: docs/en/tutorial/tutorial-1.md:86
msgid ""
"Briefcase will then generate a project skeleton for you to use. If you've "
"followed this tutorial so far, and accepted the defaults as described, your "
"file system should look something like:"
msgstr ""
"接下来，Briefcase 会生成一个项目骨架供你使用。如果你到目前为止都已经跟着这个"
"教程走的话，并接受了所述的默认设置，那么你的文件系统应该是这样的:"

#: docs/en/tutorial/tutorial-1.md:110
msgid ""
"This skeleton is actually a fully functioning application without adding "
"anything else. The `src` folder contains all the code for the application, "
"the `tests` folder contains an initial test suite, and the `pyproject.toml` "
"file describes how to package the application for distribution. If you open "
"`pyproject.toml` in an editor, you'll see the configuration details you just "
"provided to Briefcase."
msgstr ""
"该骨架实际上是一个功能完备的应用程序，无需添加任何其他内容。`src` 文件夹包含"
"应用程序的所有代码，`tests` 文件夹包含初始测试套件，`pyproject.toml` 文件描述"
"了如何打包发布应用程序。如果您用编辑器打开 `pyproject.toml`，就会看到刚才提供"
"给 Briefcase 的配置详细信息。"

#: docs/en/tutorial/tutorial-1.md:112
msgid ""
"Now that we have a stub application, we can use Briefcase to run the "
"application."
msgstr "现在我们有了一个包含占位代码的应用程序，可以使用 Briefcase 来运行它。"

#: docs/en/tutorial/tutorial-1.md:114
msgid "Run the app in developer mode"
msgstr "在开发者模式下运行应用程序"

#: docs/en/tutorial/tutorial-1.md:116
msgid ""
"Move into the `helloworld` project directory and tell briefcase to start the "
"project in Developer (or `dev`) mode:"
msgstr "移动到 `helloworld` 项目目录，告诉 Briefcase 以开发者（或 `dev`）模式启动项目"
"："

#: docs/en/tutorial/tutorial-1.md:163
#: docs/en/tutorial/tutorial-2.md:265
msgid "This should open a GUI window:"
msgstr "这将打开一个图形用户界面 (GUI) 窗口："

#: docs/en/tutorial/tutorial-1.md:167
#, fuzzy
msgid "![Hello World Tutorial 1 window, on macOS]{1}"
msgstr "Hello World 教程 1 窗口，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-1.md:177
#, fuzzy
msgid "![Hello World Tutorial 1 window, on Linux]{1}"
msgstr "![Hello World 教程 1 窗口，在 Linux 上]{1}!"

#: docs/en/tutorial/tutorial-1.md:187
#, fuzzy
msgid "![Hello World Tutorial 1 window, on Windows]{1}"
msgstr "![Hello World 教程 1 窗口，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-1.md:193
#, fuzzy
msgid "/// admonition | Invalid requirements or pip unable to connect"
msgstr "/// admonition |无效要求或 pip 无法连接"

#: docs/en/tutorial/tutorial-1.md:195
msgid "If you encounter the error:"
msgstr "如果您遇到错误："

#: docs/en/tutorial/tutorial-1.md:203
#, fuzzy
msgid ""
"Confirm that you are running a "
"[version of python that this tutorial supports][install-python]."
msgstr "确认运行的是[本教程支持的 python 版本][install-python]。"

#: docs/en/tutorial/tutorial-1.md:205
msgid ""
"If your version of python is *not* a supported version, you will have to "
"restart the tutorial."
msgstr "如果您的 Python 版本*不*被支持，则需重新开始本教程。"

#: docs/en/tutorial/tutorial-1.md:211
msgid ""
"Close the application - either by pressing the close button on the "
"application window, by selecting Quit/Exit from the application's menu, or "
"by typing **Ctrl+C** in the terminal where you ran `briefcase dev` - and "
"you're done! Congratulations - you've just written a standalone, native "
"application in Python!"
msgstr ""
"关闭应用程序 -- 可以使用应用程序窗口上的关闭按钮、从应用程序的菜单栏选择关闭/"
"退出、或在您运行 `briefcase dev` 的命令行窗口中按 **Ctrl+C** -- 就完成了！恭"
"喜您，您刚刚使用 Python 编写了一个独立、原生的应用程序！"

#: docs/en/tutorial/tutorial-1.md:215
#, fuzzy
msgid ""
"We now have a working application, running in developer mode. Now we can add "
"some logic of our own to make our application do something a little more "
"interesting. In [Tutorial 2]{1}, we'll put a more useful user interface onto "
"our application."
msgstr ""
"现在，我们有了一个在开发者模式下运行的应用程序。现在我们可以添加一些自己的逻"
"辑，让应用程序做更有趣一些的事情。在\\ :doc:`教程 2<tutorial-2>` 中，我们将为"
"应用程序添加一个更有用的用户界面。"

#: docs/en/tutorial/tutorial-2.md:1
#, fuzzy
msgid "Tutorial 2 - Making it interesting"
msgstr "教程 2 - 使之更有趣"

#: docs/en/tutorial/tutorial-2.md:3
#, fuzzy
msgid ""
"In [Tutorial 1]{1}, we generated a stub project that was able to run, but we "
"didn't write any code ourselves. Let's take a look at what was generated for "
"us."
msgstr ""
"在 [教程 1<tutorial-1>` 中，我们生成了一个可以运行的基础项目，但我们自己并没"
"有编写任何代码。让我们看看 Briefcase 为我们生成了什么。"

#: docs/en/tutorial/tutorial-2.md:5
msgid "What was generated"
msgstr "生成的内容"

#: docs/en/tutorial/tutorial-2.md:7
msgid ""
"In the `src/helloworld` directory, you should see 3 files: `__init__.py`, "
"`__main__.py` and `app.py`."
msgstr ""
"在 `src/helloworld` 目录中，你应该看到 3 个文件：`__init__.py`、`__main__.py`"
" 和 `app.py`。"

#: docs/en/tutorial/tutorial-2.md:9
msgid ""
"`__init__.py` marks the `helloworld` directory as an importable Python "
"module. It is an empty file; the very fact it exists tells the Python "
"interpreter that the `helloworld` directory defines a module."
msgstr ""
"`__init__.py` 将 `helloworld` 目录标记为可导入的 Python 模块。这是一个空文件"
"；它的存在告诉 Python 解释器 helloworld 目录定义了一个模块。"

#: docs/en/tutorial/tutorial-2.md:11
#, fuzzy
msgid ""
"`__main__.py` marks the `helloworld` module as a special kind of module -an "
"executable module. If you try to run the `helloworld` module using `python -"
"m helloworld`, the `__main__.py` file is where Python will start executing. "
"The contents of `__main__.py` is relatively simple:"
msgstr ""
"`__main__.py` 将 `helloworld` 模块标记为一种特殊的模块 - 可执行模块。如果使用"
" `python -m helloworld` 试图运行 `helloworld` 模块，`__main__.py` 文件就是 "
"Python 开始执行的地方。`__main__.py` 的内容相对简单："

#: docs/en/tutorial/tutorial-2.md:20
msgid "This file does two things:"
msgstr "此文件做以下两件事："

#: docs/en/tutorial/tutorial-2.md:22
#, fuzzy
msgid "It imports the `main` method from the `helloworld` app."
msgstr "它从 `helloworld` 应用程序导入了 `main` 方法。"

#: docs/en/tutorial/tutorial-2.md:23
msgid ""
"Then, it starts the application’s main loop. The main loop is the way a GUI "
"application listens for user input (like mouse clicks and keyboard presses)."
msgstr "然后，它会开始应用程序的主循环，以便侦听用户输入（例如鼠标点击或键盘按键）。"

#: docs/en/tutorial/tutorial-2.md:25
msgid ""
"The more interesting file is `app.py` - this contains the logic that creates "
"our application window:"
msgstr "更有趣的文件是 `app.py` - 它包含创建我们应用程序窗口的逻辑:"

#: docs/en/tutorial/tutorial-2.md:43
msgid "Let's go through this line by line:"
msgstr "让我们逐行查看:"

#: docs/en/tutorial/tutorial-2.md:50
msgid ""
"First, we import the `toga` widget toolkit, as well as some style-related "
"utility constants. Our code doesn't use these yet - but we'll make use of "
"them shortly."
msgstr "首先，我们导入 `toga` 控件工具包，以及一些与样式相关的实用常量。目前我们的代"
"码还没有使用这些——但我们很快就会用到它们。"

#: docs/en/tutorial/tutorial-2.md:52
msgid "Then, we define a class:"
msgstr "然后，我们定义了一个类 :"

#: docs/en/tutorial/tutorial-2.md:58
msgid ""
"Each Toga application has a single `toga.App` instance, representing the "
"running entity that is the application. The app may end up managing multiple "
"windows; but for simple applications, there will be a single main window."
msgstr ""
"每个 Toga 应用程序都有一个 `toga.App` 实例，代表应用程序的运行实体。应用程序"
"最终可能会管理多个窗口；但是对于简单的应用程序来说，可能只有一个主窗口。"

#: docs/en/tutorial/tutorial-2.md:60
msgid "Next, we define a `startup()` method:"
msgstr "接下来，我们定义一个 `startup()` 方法 (startup意为启动):"

#: docs/en/tutorial/tutorial-2.md:67
msgid ""
"The first thing the startup method does is to define a main box. Toga's "
"layout scheme behaves similar to HTML. You build an application by "
"constructing a collection of boxes, each of which contains other boxes, or "
"actual widgets. You then apply styles to these boxes to define how they will "
"consume the available window space."
msgstr ""
"startup 方法的第一件事是定义一个主盒子 (main box)。Toga 的布局方案类似于 HTML"
"。你通过构造一系列盒子 (box) 来构建应用程序，每个盒子包含其他盒子或实际的控件"
" (widgets)。然后，你对这些盒子应用样式 (styles)，以定义它们将如何消耗可用的窗"
"口空间 (window space)。"

#: docs/en/tutorial/tutorial-2.md:69
msgid ""
"In this application, we define a single box, but we don't put anything into "
"it."
msgstr "在这个应用程序中，我们定义了一个单独的空盒子 (我们没有放任何东西进去)。"

#: docs/en/tutorial/tutorial-2.md:71
msgid "Next, we define a window into which we can put this empty box:"
msgstr "接下来，我们定义一个可以将这个空盒子放入其中的窗口:"

#: docs/en/tutorial/tutorial-2.md:77
msgid ""
"This creates an instance of a `toga.MainWindow`, which will have a title "
"matching the application's name. A Main Window is a special kind of window "
"in Toga - it's a window that is closely bound to the life cycle of the app. "
"When the Main Window is closed, the application exits. The Main Window is "
"also the window that has the application's menu (if you're on a platform "
"like Windows where menu bars are part of the window)."
msgstr ""
"这将创建一个 `toga.MainWindow` 的实例，它的标题 (title) 将与应用程序的名称 "
"(self.formal_name) 匹配。主窗口是 Toga 中的一种特殊窗口——它与应用程序的生命周"
"期 (life cycle) 密切绑定。主窗口关闭，应用程序就退出了。主窗口也具有应用程序"
"菜单（例如类似 Windows 这样的平台上，菜单栏是窗口的一部分）。"

#: docs/en/tutorial/tutorial-2.md:79
#, fuzzy
msgid "/// admonition | Where is my window?"
msgstr "/// admonition |我的窗户在哪里？"

#: docs/en/tutorial/tutorial-2.md:81
msgid ""
"If you have made an error in your code, the main window of the app may not "
"display. If this happens, you can type **Ctrl+C** in the terminal where you "
"started the app. This will stop the app. You can then fix the error and "
"restart the app."
msgstr ""
"如果你写的代码中有错误，app的主窗口可能不会显示。要是真这样了，你可以找到先前"
"启动app的终端窗口，并在其中按下\\ **Ctrl + C**，以终止app运行。之后，你就可以"
"修改代码里的错误，再重启app。"

#: docs/en/tutorial/tutorial-2.md:85
msgid ""
"We then add our empty box as the content of the main window, and instruct "
"the application to show our window:"
msgstr "然后，我们将空盒子作为主窗口的内容，并指示应用程序显示我们的窗口:"

#: docs/en/tutorial/tutorial-2.md:92
msgid ""
"Last of all, we define a `main()` function. This is what creates the "
"instance of our application:"
msgstr "最后，我们定义一个 `main()` 方法。它将创建应用程序的实例:"

#: docs/en/tutorial/tutorial-2.md:99
msgid ""
"This `main()` method is the one that is imported and invoked by `__main__.py`"
". It creates and returns an instance of our `HelloWorld` application."
msgstr "这个 `main()` 方法由 `__main__.py` 导入并调用。它创建并返回我们的 "
"`HelloWorld` 应用程序的实例。"

#: docs/en/tutorial/tutorial-2.md:101
msgid ""
"That's the simplest possible Toga application. Let's put some of our own "
"content into the application, and make the app do something interesting."
msgstr "这是最简单可能的 Toga 应用程序。接下来，让我们在应用程序中加入一些我们自己的"
"内容，使应用程序做一些有趣的事情。"

#: docs/en/tutorial/tutorial-2.md:103
msgid "Adding some content of our own"
msgstr "添加一些我们自己的内容"

#: docs/en/tutorial/tutorial-2.md:105
msgid "Let's do something more interesting with our `HelloWorld` app."
msgstr "对我们的 `HelloWorld` 应用程序，做些更有意思的事吧。"

#: docs/en/tutorial/tutorial-2.md:109
msgid ""
"When you make these changes, make sure you keep the imports at the top of "
"the file, and the `main()` at the bottom of the file. You only need to "
"update the `HelloWorld` class."
msgstr "在做这些更改时，确保不要删除文件顶部的导入 (imports)，也不要删除底部的 "
"`main()`。您只需更新 `HelloWorld` 类。"

#: docs/en/tutorial/tutorial-2.md:113
msgid ""
"Modify your `HelloWorld` class inside `src/helloworld/app.py` so that it "
"looks like this:"
msgstr "修改 `src/helloworld/app.py` 中的 `HelloWorld` 类，使其看起来像这样:"

#: docs/en/tutorial/tutorial-2.md:147
msgid "Let's look in detail at what has changed."
msgstr "让我们详细看看有哪些变化。"

#: docs/en/tutorial/tutorial-2.md:149
msgid "We're still creating a main box; however, we are now applying a style:"
msgstr "我们仍然在创建一个主盒子；然而，现在我们正在应用一个样式:"

#: docs/en/tutorial/tutorial-2.md:155
msgid ""
"Toga's built-in layout system is called \"Pack\". It behaves a lot like CSS. "
"You define objects in a hierarchy - in HTML, the objects are `<div>`, "
"`<span>`, and other DOM elements; in Toga, they're widgets and boxes. You "
"can then assign styles to the individual elements. In this case, we're "
"indicating that this is a `COLUMN` box - that is, it is a box that will "
"consume all the available width, and will expand its height as content is "
"added, but it will try to be as short as possible."
msgstr ""
"Toga 的内置布局系统称为 \"Pack\" (包)。它的行为很像 CSS (Cascading Style Shee"
"ts 层叠样式表)。你可以在一个层次结构中定义对象--在 HTML 中，对象是 `<div>` (d"
"ivision 块级容器)、`<span>` (inline span 内联容器) 和其他 DOM (Document Objec"
"t Model 文档对象模型) 元素；在 Toga 中，对象是控件 (widgets ) 和盒子 (boxes)"
"。然后，您可以为各个元素指定样式。在本例中，我们表示这是一个 `COLUMN` (垂直) "
"框，也就是说，它是一个将占用所有可用宽度 (width) 的框，并会随着内容的添加而扩"
"大高度 (height)，但会尽量使高度更短。"

#: docs/en/tutorial/tutorial-2.md:159
msgid ""
"For more advanced uses, Toga also supports a separate style object, which is "
"used like this:"
msgstr "对于更高级的使用，Toga 也支持可以被这样使用的单独的样式对象:"

#: docs/en/tutorial/tutorial-2.md:168
msgid "Next, we define a couple of widgets:"
msgstr "接下来，我们定义了一些控件:"

#: docs/en/tutorial/tutorial-2.md:178
msgid ""
"Here, we define a Label and a TextInput. Both widgets have styles associated "
"with them; the label will have 5px of margin on its left and right, and no "
"margin on the top and bottom. The TextInput is marked as being flexible - "
"that is, it will absorb all available space in its layout axis."
msgstr ""
"在这里，我们定义了一个标签 (Label) 和一个文本输入框 (TextInput)。这两个控件都"
"有与其相关的样式；标签左右会各有 5px 的填充，上下没有填充。文本输入框是被标记"
"为灵活的——也就是说，它将吸收其布局方向上所有可用的空间。"

#: docs/en/tutorial/tutorial-2.md:180
msgid ""
"The TextInput is assigned as an instance variable of the class. This gives "
"us easy access to the widget instance - something that we'll use in a moment."
msgstr "文本输入框 (TextInput) 被分配为类的实例变量。这使我们能够轻松访问控件 "
"(widget) 实例 - 这是我们马上就会使用的东西。"

#: docs/en/tutorial/tutorial-2.md:182
msgid "Next, we define a box to hold these two widgets:"
msgstr "接下来，我们定义了一个盒子来容纳这两个控件:"

#: docs/en/tutorial/tutorial-2.md:190
msgid ""
"The `name_box` is a box just like the main box; however, this time, it's a "
"`ROW` box. That means content will be added horizontally, and it will try to "
"make its width as narrow as possible. The box also has some margin - 5px on "
"all sides."
msgstr ""
"`name_box` 就像主盒子一样；然而，这次它是一个 `ROW` (水平) 盒子。这意味着内容"
"将会被水平添加，并且它会尽量使其宽度尽可能窄。盒子也有一些空白填充——四周各为 "
"5px。"

#: docs/en/tutorial/tutorial-2.md:192
msgid "Now we define a button:"
msgstr "现在，我们定义一个按钮:"

#: docs/en/tutorial/tutorial-2.md:202
#, fuzzy
msgid ""
"The button also has 5px of margin on all sides. We also define a *handler* - "
"a method to invoke when the button is pressed."
msgstr "按钮四边的边距也是 5px。我们还定义了一个 *handler* - 按钮按下时调用的方法。"

#: docs/en/tutorial/tutorial-2.md:204
msgid "Then, we add the name box and the button to the main box:"
msgstr "然后，我们将 name box 和按钮添加到主盒子中:"

#: docs/en/tutorial/tutorial-2.md:211
msgid ""
"This completes our layout; the rest of the startup method is as it was "
"previously - defining a `MainWindow`, and assigning the main box as the "
"window's content:"
msgstr "这完成了我们的布局；其余的 startup 方法与以前一样 - 定义一个 `MainWindow` ，"
"并将主盒子指定为窗口的内容:"

#: docs/en/tutorial/tutorial-2.md:219
msgid ""
"The last thing we need to do is define the handler for the button. A handler "
"can be any method, generator, or asynchronous coroutine; it accepts the "
"widget that generated the event as an argument, and will be invoked whenever "
"the button is pressed:"
msgstr ""
"我们需要做的最后一件事，就是定义按钮的处理器(handler)——它可以是任何方法、生成"
"器或异步协程，且接受生成事件的控件 (widget) 作为参数。只要按下按钮，就会调用"
"这些处理器:"

#: docs/en/tutorial/tutorial-2.md:226
msgid ""
"The body of the method is a simple print statement - however, it will "
"interrogate the current value of the name input, and use that content as the "
"text that is printed."
msgstr "方法的主体是一个简单的打印语句——然而，它会使用名称输入的当前值，并使用该内容"
"作为打印的文本。"

#: docs/en/tutorial/tutorial-2.md:228
msgid ""
"Now that we've made these changes we can see what they look like by starting "
"the application again. As before, we'll use developer mode:"
msgstr "现在我们已经做了这些更改，我们可以通过再次启动应用程序来看看它们的样子。和以"
"前一样，我们将使用开发者模式："

#: docs/en/tutorial/tutorial-2.md:263
msgid ""
"You'll notice that this time, it *doesn't* install dependencies. Briefcase "
"can detect that the application has been run before, and to save time, will "
"only run the application. If you add new dependencies to your app, you need "
"to make sure that they're installed by passing in a `-r` option when you run "
"`briefcase dev`."
msgstr ""
"你会注意到，这次\\ *没有*\\ 安装依赖项。Briefcase 可以检测到已经被运行过的应"
"用程序 -- 为了节省时间，它只会运行应用程序，而不会安装依赖项。如果你在应用程"
"序中添加了新的依赖项，你可以在运行 `briefcase dev` 时通过 `-r` 选项来确保它们"
"被安装。"

#: docs/en/tutorial/tutorial-2.md:269
#, fuzzy
msgid "![Hello World Tutorial 2 window, on macOS]{1}"
msgstr "Hello World 教程 2 窗口，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-2.md:279
#, fuzzy
msgid "![Hello World Tutorial 2 window, on Linux]{1}"
msgstr "![Hello World 教程 2 窗口，在 Linux 上]{1}!"

#: docs/en/tutorial/tutorial-2.md:289
#, fuzzy
msgid "![Hello World Tutorial 2 window, on Windows]{1}"
msgstr "![Hello World 教程 2 窗口，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-2.md:297
msgid ""
"If you enter a name in the text box, and press the GUI button, you should "
"see output appear in the console where you started the application."
msgstr "如果在文本框中输入名称，并按下图形用户界面中的按钮，就会在启动程序的控制台中"
"看到输出结果。"

#: docs/en/tutorial/tutorial-2.md:299
msgid ""
"Before continuing, close the app. As with Tutorial 1, you can do this by "
"pressing the close button on the application window, by selecting Quit/Exit "
"from the application's menu, or by typing **Ctrl+C** in the terminal where "
"you ran `briefcase dev`."
msgstr ""
"在继续之前，关闭应用程序。和教程 1 一样，您可以使用应用程序窗口上的关闭按钮、"
"从应用程序的菜单栏选择关闭/退出、或在您运行 `briefcase dev` 的命令行窗口中按 "
"**Ctrl+C** 以关闭应用程序。"

#: docs/en/tutorial/tutorial-2.md:303
#, fuzzy
msgid ""
"We've now got an application that does something a little more interesting. "
"But it only runs on our own computer. Let's package this application for "
"distribution. In [Tutorial 3]{1}, we'll wrap our application up as a "
"standalone installer that we could send to a friend, a customer, or upload "
"to an App Store."
msgstr ""
"我们现在有了一个应用程序，它能做一些更有趣的事情。但它只能在我们自己的电脑上"
"运行。让我们将应用程序打包，以便发布。在 [教程 3]{1}中，我们将把应用程序打包"
"成一个独立的安装程序，发送给朋友、客户或上传到应用程序商店。"

#: docs/en/tutorial/tutorial-3.md:1
#, fuzzy
msgid "Tutorial 3 - Packaging for distribution"
msgstr "教程 3 - 打包与分发"

#: docs/en/tutorial/tutorial-3.md:3
msgid ""
"So far, we've been running our application in \"Developer mode\". This makes "
"it easy for us to run our application locally - but what we really want is "
"to be able to give our application to others."
msgstr "到目前为止，我们一直在“开发者模式”下运行应用程序。这可以让我们轻松地在本地运"
"行应用程序，但我们真正想要的是能将我们的应用程序提供给其他人。"

#: docs/en/tutorial/tutorial-3.md:5
msgid ""
"However, we don't want to have to teach our users how to install Python, "
"create a virtual environment, clone a git repository, and run Briefcase in "
"developer mode. We'd rather just give them an installer, and have the "
"application Just Work."
msgstr ""
"但是，我们不想教用户怎样安装 Python、创建虚拟环境、克隆 git 仓库和在开发者模"
"式下运行 Briefcase。我们宁可只给他们一个安装程序，让应用程序能够正常运行。"

#: docs/en/tutorial/tutorial-3.md:7
msgid ""
"Briefcase can be used to package your application for distribution in this "
"way."
msgstr "Briefcase 可用于打包应用程序，以便以这种方式发布。"

#: docs/en/tutorial/tutorial-3.md:9
msgid "Creating your application scaffold"
msgstr "创建应用程序脚手架"

#: docs/en/tutorial/tutorial-3.md:11
msgid ""
"Since this is the first time we're packaging our application, we need to "
"create some configuration files and other scaffolding to support the "
"packaging process. From the `helloworld` directory, run:"
msgstr "由于这是我们第一次打包应用程序，我们需要创建一些配置文件和其他脚手架来支持打"
"包过程。在 `helloworld` 目录中，运行:"

#: docs/en/tutorial/tutorial-3.md:75
#, fuzzy
msgid "/// admonition | Errors about Python versions"
msgstr "/// admonition |有关 Python 版本的错误"

#: docs/en/tutorial/tutorial-3.md:77
msgid "If you receive an error that reads something like:"
msgstr "如果您收到类似如下的错误信息："

#: docs/en/tutorial/tutorial-3.md:79
msgid ""
"The version of Python being used to run Briefcase (3.12) is not the system "
"python3 (3.10)."
msgstr "用于运行 Briefcase 的 Python 版本 (3.12) 不是系统 python3 (3.10)。"

#: docs/en/tutorial/tutorial-3.md:82
msgid ""
"You will need to recreate your virtual environment using the system `python3`"
". Using the system Python is a requirement for packaging your application."
msgstr "您将需要使用系统的 `python3` 重新创建您的虚拟环境。打包您的应用程序要求使用系"
"统 Python。"

#: docs/en/tutorial/tutorial-3.md:114
msgid ""
"You've probably just seen pages of content go past in your terminal... so "
"what just happened? Briefcase has done the following:"
msgstr "您可能刚刚在终端上看到了几页内容滑过......刚刚发生了什么？Briefcase 做了以下"
"工作："

#: docs/en/tutorial/tutorial-3.md:116
#, fuzzy
msgid ""
"It **generated an application template**. There's a lot of files and "
"configurations required to build a native installer, above and beyond the "
"code of your actual application. This extra scaffolding is almost the same "
"for every application on the same platform, except for the name of the "
"actual application being constructed - so Briefcase provides an application "
"template for each platform it supports. This step rolls out the template, "
"substituting the name of your application, bundle ID, and other properties "
"of your configuration file as required to support the platform you're "
"building on. If you're not happy with the template provided by Briefcase, "
"you can provide your own. However, you probably don't want to do this until "
"you've got a bit more experience using Briefcase's default template."
msgstr ""
"它**生成一个应用程序模板**。除了实际应用程序的代码之外，构建本机安装程序还需"
"要许多文件和配置。这些额外的脚手架对于同一平台上的每个应用程序几乎都是一样的"
"，除了正在构建的实际应用程序的名称--因此，Briefcase 为其支持的每个平台提供了"
"一个应用程序模板。这一步将推出模板，根据需要替换应用程序名称、捆绑 ID 和配置"
"文件的其他属性，以支持正在构建的平台。如果对 Briefcase 提供的模板不满意，可以"
"提供自己的模板。不过，在使用 Briefcase 的默认模板积累更多经验之前，您可能不想"
"这样做。"

#: docs/en/tutorial/tutorial-3.md:118
#, fuzzy
msgid ""
"It **downloaded and installed a support package**. The packaging approach "
"taken by Briefcase is best described as "
"\"the simplest thing that could possibly work\" - it ships a complete, "
"isolated Python interpreter as part of every application it builds "
"(except for Linux native system package builds). This is slightly space "
"inefficient - if you have 5 applications packaged with Briefcase, you'll "
"have 5 copies of the Python interpreter. However, this approach guarantees "
"that every application is completely independent, using a specific version "
"of Python that is known to work with the application. Again, Briefcase "
"provides a default support package for each platform; if you want, you can "
"provide your own support package, and have that package included as part of "
"the build process. You may want to do this if you have particular options in "
"the Python interpreter that you need to have enabled, or if you want to "
"strip modules out of the standard library that you don't need at runtime. "
"Briefcase maintains a local cache of support packages, so once you've "
"downloaded a specific support package, that cached copy will be used on "
"future builds. As noted above, when Briefcase packages an app as a native "
"Linux system package (the default package format for Linux), a support "
"package is not included with the app. Instead, the app will use the Python "
"that is provided by the distribution of Linux being targeted."
msgstr ""
"它**下载并安装了一个支持包**。Briefcase 所采用的打包方法被描述为 \"最简单可行"
"的方法\"--它将一个完整、独立的 Python 解释器作为其构建的每个应用程序的一部分"
"（Linux 本机系统包构建除外）。这在空间利用上略显不足--如果有 5 个应用程序打包"
"到 Briefcase 中，就会有 5 份 Python 解释器副本。但是，这种方法保证了每个应用"
"程序都是完全独立的，使用的 Python 版本是已知的可与应用程序一起工作的特定版本"
"。同样，Briefcase 为每个平台提供了默认的支持包；如果需要，您可以提供自己的支"
"持包，并将该包作为构建过程的一部分。如果您需要启用 Python 解释器中的特定选项"
"，或者如果您想从标准库中剥离运行时不需要的模块，您可能需要这样做。公文包会维"
"护支持包的本地缓存，因此一旦下载了特定的支持包，该缓存副本将在未来的构建中使"
"用。如上所述，当 Briefcase 将应用程序打包为本地 Linux 系统包（Linux 的默认包"
"格式）时，支持包不会随应用程序一起提供。相反，应用程序将使用目标 Linux 发行版"
"提供的 Python。"

#: docs/en/tutorial/tutorial-3.md:120
msgid ""
"It **installed application requirements**. Your application can specify any "
"third-party modules that are required at runtime. These will be installed "
"using `pip` into your application's installer."
msgstr ""
"它\\ **安装应用程序的依赖项**。您的应用程序可以指定运行时所需的任何第三方模块"
"。这些模块将会被用 `pip` 安装到应用程序的安装程序中。"

#: docs/en/tutorial/tutorial-3.md:122
msgid ""
"It **Installed your application code**. Your application will have its own "
"code and resources (e.g., images that are needed at runtime); these files "
"are copied into the installer."
msgstr "它\\ **安装您的应用程序代码**。您的应用程序将有自己的代码和资源（如运行时需要"
"的图像）；这些文件会被复制到安装程序中。"

#: docs/en/tutorial/tutorial-3.md:124
msgid ""
"It **installed your resources needed by your application.** Lastly, it adds "
"any additional resources that are needed by the installer itself. This "
"includes things like icons that need to be attached to the final application "
"and splash screen images."
msgstr "最后，它还会\\ **添加安装程序本身所需的其他资源**。这包括需要附加到最终应用程"
"序的图标和启动画面等。"

#: docs/en/tutorial/tutorial-3.md:126
msgid ""
"Once this completes, if you look in the project directory, you should now "
"see a directory corresponding to your platform "
"(`macOS`, `linux`, or `windows`) that contains additional files. This is the "
"platform-specific packaging configuration for your application."
msgstr ""
"完成上述操作后，如果查看项目目录，就会发现一个与平台（`macOS`, `linux`，或\\ "
"`windows`）相对应的目录，其中包含附加文件。这就是应用程序的平台具体的打包配置"
"。"

#: docs/en/tutorial/tutorial-3.md:128
msgid "Building your application"
msgstr "构建您的应用程序"

#: docs/en/tutorial/tutorial-3.md:130
msgid ""
"You can now compile your application. This step performs any binary "
"compilation that is necessary for your application to be executable on your "
"target platform."
msgstr "现在可以编译应用程序了。此步骤将执行任何使应用程序在目标平台上可执行所必须的"
"二进制编译。"

#: docs/en/tutorial/tutorial-3.md:145
msgid ""
"On macOS, the `build` command doesn't need to *compile* anything, but it "
"does need to sign the contents of binary so that it can be executed. This "
"signature is an *ad hoc* signature - it will only work on *your* machine; if "
"you want to distribute the application to others, you'll need to provide a "
"full signature."
msgstr ""
"在 macOS 上，` build`\\ 命令不需要\\ *编译*\\ 任何内容，但需要对二进制文件的"
"内容进行（数字）签名，以便执行。这种签名是一种\\ *临时 (ad hoc)*\\ 签名--它只"
"能在\\ *你的*\\ 机器上工作；如果你想将应用程序发布给其他人，就需要提供完整的"
"签名。"

#: docs/en/tutorial/tutorial-3.md:175
msgid ""
"Once this step completes, the `build` folder will contain a "
"`helloworld-0.0.1` folder that contains a mirror of a Linux `/usr` file "
"system. This file system mirror will contain a `bin` folder with a "
"`helloworld` binary, plus `lib` and `share` folders needed to support the "
"binary."
msgstr ""
"此步骤完成后，[build`\\ 文件夹将包含一个\\ `helloworld-0.0.1`\\ 文件夹，其中"
"包含一个 Linux `/usr` 文件系统的镜像。这个文件系统镜像将包含一个\\ `bin`\\ 文"
"件夹，里面有一个\\ `helloworld`\\ 二进制文件，以及支持二进制文件所需的\\ "
"`lib`\\ 和\\ `share`\\ 文件夹。"

#: docs/en/tutorial/tutorial-3.md:188
msgid ""
"On Windows, the `build` command doesn't need to *compile* anything, but it "
"does need to write some metadata so that the application knows its name, "
"version, and so on."
msgstr "在 Windows 上，`build` 命令不需要\\ *编译*\\ 任何东西，但它确实需要写入一些元"
"数据，以便应用程序知道它的名称、版本等。"

#: docs/en/tutorial/tutorial-3.md:190
#, fuzzy
msgid "/// admonition | Triggering antivirus"
msgstr "/// admonition |触发杀毒软件"

#: docs/en/tutorial/tutorial-3.md:192
msgid ""
"Since this metadata is being written directly in to the pre-compiled binary "
"rolled out from the template during the `create` command, this may trigger "
"antivirus software running on your machine and prevent the metadata from "
"being written. In that case, instruct the antivirus to allow the tool "
"(named `rcedit-x64.exe`) to run and re-run the command above."
msgstr ""
"由于这些元数据是在 `create` 命令中直接写入从模板推出的预编译二进制文件的，因"
"此可能会触发机器上运行的杀毒软件，从而阻止元数据的写入。在这种情况下，请指示"
"杀毒软件允许工具（名为 `rcedit-x64.exe`）运行，并重新运行上述命令。"

#: docs/en/tutorial/tutorial-3.md:198
msgid "Running your app"
msgstr "运行应用程序"

#: docs/en/tutorial/tutorial-3.md:200
msgid "You can now use Briefcase to run your application:"
msgstr "现在您可以使用 Briefcase 运行应用程序了："

#: docs/en/tutorial/tutorial-3.md:279
msgid ""
"This will start to run your native application, using the app bundle created "
"by the `build` command."
msgstr "这将使用 `build` 命令的输出开始运行原生应用程序。"

#: docs/en/tutorial/tutorial-3.md:281
msgid ""
"You might notice some small differences in the way your application looks "
"when it's running. For example, icons and the name displayed by the "
"operating system may be slightly different to those you saw when running "
"under developer mode. This is also because you're using the packaged "
"application, not just running Python code. From the operating system's "
"perspective, you're now running \"an app\", not \"a Python program\", and "
"this is reflected in how the application appears."
msgstr ""
"你可能会注意到应用程序运行时的外观有一些细微差别。例如，操作系统显示的图标和"
"名称可能与在开发者模式下运行时略有不同。这也是因为您使用的是打包的应用程序，"
"而不仅仅是运行 Python 代码。从操作系统的角度来看，您现在运行的是“一个应用程序"
"”，而不是“一个 Python 程序\"”，这也反映在应用程序的显示方式上。"

#: docs/en/tutorial/tutorial-3.md:283
msgid ""
"Before continuing, close the app. As with previous tutorial steps, you can "
"do this by pressing the close button on the application window, by selecting "
"Quit/Exit from the application's menu, or by typing **Ctrl+C** in the "
"terminal where you ran `briefcase run`."
msgstr ""
"在继续之前，关闭应用程序。和之前的教程步骤一样，您可以使用应用程序窗口上的关"
"闭按钮、从应用程序的菜单栏选择关闭/退出、或在您运行 `briefcase dev` 的命令行"
"窗口中按 **Ctrl+C** 以关闭应用程序。"

#: docs/en/tutorial/tutorial-3.md:285
msgid "Building your installer"
msgstr "创建安装程序"

#: docs/en/tutorial/tutorial-3.md:287
msgid ""
"You can now package your application for distribution, using the `package` "
"command. The package command does any compilation that is required to "
"convert the scaffolded project into a final, distributable product. "
"Depending on the platform, this may involve compiling an installer, "
"performing code signing, or doing other pre-distribution tasks."
msgstr ""
"现在，您可以使用 `package` 命令打包应用程序，以便发布。打包命令会执行将脚手架"
"项目转换为最终可发布产品所需的编译工作。根据平台的不同，这可能涉及编译安装程"
"序、执行代码签名或执行其他发布前任务。"

#: docs/en/tutorial/tutorial-3.md:320
#, fuzzy
msgid ""
"The `dist` folder will contain a file named `Hello World-0.0.1.dmg`. If you "
"locate this file in the Finder, and double-click on its icon, you'll mount "
"the DMG, giving you a copy of the Hello World app, and a link to your "
"Applications folder for easy installation. Drag the app file into "
"Applications, and you've installed your application. Send the DMG file to a "
"friend, and they should be able to do the same."
msgstr ""
"`dist` 文件夹将包含一个名为 `Hello World-0.0.1.dmg` 的文件。如果在 Finder 中"
"找到该文件，并双击其图标，就会加载 DMG，从而获得 Hello World 应用程序的副本，"
"并链接到 `Applications` 文件夹以方便安装。将应用程序文件拖入 Applications，就"
"安装好了应用程序。将 DMG 文件发送给朋友，他们应该也能完成同样的操作。"

#: docs/en/tutorial/tutorial-3.md:322
msgid ""
"In this example, we've used the `--adhoc-sign` option - that is, we're "
"signing our application with *ad hoc* credentials - temporary credentials "
"that will only work on your machine. We've done this to keep the tutorial "
"simple. Setting up code signing identities is a little fiddly, and they're "
"only *required* if you're intending to distribute your application to "
"others. If we were publishing a real application for others to use, we would "
"need to specify real credentials."
msgstr ""
"在本例中，我们使用了 `--adhoc-sign` 选项--也就是说，我们使用 *ad hoc* 凭据（"
"仅在你的机器上有效的临时凭据）来签署我们的应用程序。我们这样做是为了让教程简"
"单明了。设置代码签名身份有点麻烦，而且只有当你打算将应用程序发布给他人时\\ *"
"才*\\ 需要。如果我们要发布一个真正的应用程序供他人使用，我们就需要指定真实的"
"凭据。"

#: docs/en/tutorial/tutorial-3.md:324
#, fuzzy
msgid ""
"When you're ready to publish a real application, check out the Briefcase How-"
"To guide on [Setting up a macOS code signing identity]{1}."
msgstr "当你准备发布一个真正的应用程序时，请查看公文包操作指南中的 [设置 macOS 代码签"
"名身份]{1}。"

#: docs/en/tutorial/tutorial-3.md:330
msgid ""
"The output of the package step will be slightly different depending on your "
"Linux distribution. If you're on a Debian-derived distribution, you'll see:"
msgstr "软件包步骤的输出会因 Linux 发行版的不同而略有不同。如果你使用的是 Debian 衍生"
"发行版，你会看到:"

#: docs/en/tutorial/tutorial-3.md:350
msgid "The `dist` folder will contain the `.deb` file that was generated."
msgstr "`dist` 文件夹将包含生成的 `.deb` 文件。"

#: docs/en/tutorial/tutorial-3.md:352
msgid "If you're on a RHEL-based distribution, you'll see:"
msgstr "如果你使用的是基于 RHEL 的发行版，你就会看到："

#: docs/en/tutorial/tutorial-3.md:379
msgid "The `dist` folder will contain the `.rpm` file that was generated."
msgstr "`dist` 文件夹将包含生成的 `.rpm` 文件。"

#: docs/en/tutorial/tutorial-3.md:381
msgid "If you're on an Arch-based distribution, you'll see:"
msgstr "如果你使用的是基于 Arch 的发行版，你就会看到："

#: docs/en/tutorial/tutorial-3.md:399
msgid ""
"The `dist` folder will contain the `.pkg.tar.zst` file that was generated."
msgstr "`dist` 文件夹将包含生成的 `.pkg.tar.zst` 文件。"

#: docs/en/tutorial/tutorial-3.md:401
msgid "Other Linux distributions aren't currently supported for packaging."
msgstr "目前不支持其他 Linux 发行版的打包。"

#: docs/en/tutorial/tutorial-3.md:403
msgid ""
"If you want to build a package for a Linux distribution other than the one "
"you're using, Briefcase can also help - but you'll need to install Docker."
msgstr "如果你想为你正在使用的 Linux 发行版之外的其他发行版构建软件包，Briefcase 也能"
"提供帮助，但你需要安装 Docker。"

#: docs/en/tutorial/tutorial-3.md:405
msgid ""
"Official installers for [Docker Engine]{1} are available for a range of Unix "
"distributions. Follow the instructions for your platform; however, ensure "
"you don't install Docker in \"rootless\" mode."
msgstr ""
"[Docker Engine]{1} 的官方安装程序适用于一系列 Unix 发行版。请按照您所在平台的"
"说明进行操作；不过，请确保不要在 rootless 模式下安装 Docker。"

#: docs/en/tutorial/tutorial-3.md:407
msgid ""
"Once you've installed Docker, you should be able to start an Linux container "
"- for example:"
msgstr "安装好 Docker 后，你就可以启动 Linux 容器了，例如:"

#: docs/en/tutorial/tutorial-3.md:413
msgid ""
"will show you a Unix prompt (something like `root@84444e31cff9:/#`) inside "
"an Ubuntu 22.04 Docker container. Type Ctrl-D to exit Docker and return to "
"your local shell."
msgstr ""
"将显示 Ubuntu 22.04 Docker 容器中的 Unix 提示符（类似于 `root@84444e31cff9:/#"
"`）。键入 Ctrl-D 退出 Docker 并返回本地 shell。"

#: docs/en/tutorial/tutorial-3.md:415
msgid ""
"Once you've got Docker installed, you can use Briefcase to build a package "
"for any Linux distribution that Briefcase supports by passing in a Docker "
"image as an argument. For example, to build a DEB package for Ubuntu 22.04 "
"(Jammy), regardless of the operating system you're on, you can run:"
msgstr ""
"一旦安装了 Docker，只要将 Docker 镜像作为参数传递，就可以使用 Briefcase 为 "
"Briefcase 支持的任何 Linux 发行版构建软件包。例如，要为 Ubuntu 22.04 (Jammy) "
"构建一个 DEB 包，无论你使用的是哪种操作系统，你都可以运行:"

#: docs/en/tutorial/tutorial-3.md:421
msgid ""
"This will download the Docker image for your selected operating system, "
"create a container that is able to run Briefcase builds, and build the app "
"package inside the image. Once it's completed, the `dist` folder will "
"contain the package for the target Linux distribution."
msgstr ""
"这将下载所选操作系统的 Docker 镜像，创建一个能够运行 Briefcase 构建的容器，并"
"在镜像中构建应用程序软件包。完成后，`dist` 文件夹将包含目标 Linux 发行版的软"
"件包。"

#: docs/en/tutorial/tutorial-3.md:455
msgid ""
"In this example, we're not signing our app. As a result, when you use the "
"installer, you'll get a system warning that the application comes from an "
"unknown developer. We've done this to keep the tutorial simple. Setting up "
"code signing identities is a little fiddly, and they're only *required* if "
"you're intending to distribute your application to others. If we were "
"publishing a real application for others to use, we would need to specify a "
"real signing identity; when that signed app is installed, the system will "
"notify the user that the application is from the known identity associated "
"with the certificate."
msgstr ""
"在本例中，我们没有签署我们的应用程序。因此，当您使用安装程序时，您将收到系统"
"警告，该应用程序来自未知开发人员。我们这样做是为了保持教程的简单性。设置代码"
"签名身份比较复杂，只有当您打算将您的应用程序分发给其他人时，它们才*需要*。如"
"果我们发布一个真实的应用程序供其他人使用，我们需要指定一个真实的签名身份；当"
"该签名的应用程序安装时，系统将通知用户该应用程序来自与证书关联的已知身份。"

#: docs/en/tutorial/tutorial-3.md:457
#, fuzzy
msgid ""
"When you're ready to publish a real application, check out the Briefcase How-"
"To guide on [Setting up a Windows code signing identity]{1}."
msgstr "当您准备发布实际应用程序时，请查看公文包操作指南中的 [设置 Windows 代码签名身"
"份]{1}。"

#: docs/en/tutorial/tutorial-3.md:459
msgid ""
"Once this step completes, the `dist` folder will contain a file named "
"`Hello_World-0.0.1.msi`. If you double click on this installer to run it, "
"you should go through a familiar Windows installation process. Once this "
"installation completes, there will be a \"Hello World\" entry in your start "
"menu."
msgstr ""
"此步骤完成后，`dist` 文件夹中将包含一个名为 `Hello_World-0.0.1.msi`` 的文件。"
"如果双击运行该安装程序，就会进入熟悉的 Windows 安装过程。安装完成后，开始菜单"
"中将出现 \"Hello World \"条目。"

#: docs/en/tutorial/tutorial-3.md:465
#, fuzzy
msgid ""
"We now have our application packaged for distribution on desktop platforms. "
"But what happens when we need to update the code in our application? How do "
"we get those updates into our packaged application? Turn to [Tutorial 4]{1} "
"to find out..."
msgstr ""
"现在，我们已将应用程序打包发布到桌面平台上。但是，当我们需要更新应用程序中的"
"代码时该怎么办？我们如何将这些更新添加到打包的应用程序中？请参阅 [教程 4]{1} "
"了解详情..."

#: docs/en/tutorial/tutorial-4.md:1
#, fuzzy
msgid "Tutorial 4 - Updating your application"
msgstr "教程 4 - 更新应用程序"

#: docs/en/tutorial/tutorial-4.md:3
msgid ""
"In the last tutorial, we packaged our application as a native application. "
"If you're dealing with a real-world app, that isn't going to be the end of "
"the story - you'll likely do some testing, discover problems, and need to "
"make some changes. Even if your application is perfect, you'll eventually "
"want to publish version 2 of your application with improvements."
msgstr ""
"在上一教程中，我们将应用程序打包为本地应用程序。如果您面对的是一个真实世界的"
"应用程序，这并不是故事的结束--您可能会进行一些测试，发现一些问题，并需要进行"
"一些修改。即使您的应用程序是完美的，您最终还是希望发布改进后的第二版应用程序"
"。"

#: docs/en/tutorial/tutorial-4.md:5
msgid "So - how do you update your installed app when you make code changes?"
msgstr "那么，在更改代码时如何更新已安装的应用程序？"

#: docs/en/tutorial/tutorial-4.md:7
msgid "Updating application code"
msgstr "更新应用程序代码"

#: docs/en/tutorial/tutorial-4.md:9
msgid ""
"Our application currently prints to the console when you press the button. "
"However, GUI applications shouldn't really use the console for output. They "
"need to use dialogs to communicate with users."
msgstr "目前，我们的应用程序会在您按下按钮时打印到控制台。但是，图形用户界面应用程序"
"实际上不应该使用控制台进行输出。它们需要使用对话框与用户交流。"

#: docs/en/tutorial/tutorial-4.md:11
msgid ""
"Let's add a dialog box to say hello, instead of writing to the console. "
"Modify the `say_hello` callback so it looks like this:"
msgstr "让我们添加一个对话框来说 \"你好\"，而不是写入控制台。修改 `say_hello` 回调，"
"使它看起来像这样：："

#: docs/en/tutorial/tutorial-4.md:23
#, fuzzy
msgid ""
"We need to make the method `async` so that when we display the dialog, the "
"rest of the application continues to run. Don't worry about this detail too "
"much right now - we'll give a more detailed explanation in [Tutorial 8]{1}."
msgstr ""
"我们需要使用 \"async \"方法，以便在显示对话框时，应用程序的其他部分能够继续运"
"行。现在不用太在意这个细节，我们会在【教程 8】{1}中给出更详细的解释。"

#: docs/en/tutorial/tutorial-4.md:25
msgid ""
"This directs Toga to open a modal dialog box when the button is pressed."
msgstr "这将指示 Toga 在按下按钮时打开一个模态对话框。"

#: docs/en/tutorial/tutorial-4.md:27
msgid ""
"If you run `briefcase dev`, enter a name, and press the button, you'll see "
"the new dialog box:"
msgstr "如果运行 `briefcase dev`，输入名称并按下按钮，就会看到新的对话框："

#: docs/en/tutorial/tutorial-4.md:31
#, fuzzy
msgid "![Hello World Tutorial 4 dialog, on macOS]{1}"
msgstr "你好世界教程 4 对话框，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-4.md:41
#, fuzzy
msgid "![Hello World Tutorial 4 dialog, on Linux]{1}"
msgstr "![Hello World 教程 4 对话框，在 Linux 上]{1}。"

#: docs/en/tutorial/tutorial-4.md:51
#, fuzzy
msgid "![Hello World Tutorial 4 dialog, on Windows]{1}"
msgstr "![Hello World 教程 4 对话，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-4.md:59
msgid "However, if you run `briefcase run`, the dialog box won't appear."
msgstr "但是，如果运行\\ `briefcase run`，对话框就不会出现。"

#: docs/en/tutorial/tutorial-4.md:61
#, fuzzy
msgid ""
"Why is this? Well, `briefcase dev` operates by running your code in place - "
"it tries to produce as realistic runtime environment for your code as "
"possible, but it doesn't provide or use any of the platform infrastructure "
"for wrapping your code as an application. Part of the process of packaging "
"your app involves copying your code *into* the application bundle - and at "
"the moment, your application still has the old code in it."
msgstr ""
"为什么会这样？简易开发包 \"的运行方式是在原地运行您的代码--它试图为您的代码提"
"供尽可能逼真的运行环境，但并不提供或使用任何平台基础架构来将您的代码包装成应"
"用程序。打包应用程序的部分过程包括将您的代码复制到应用程序捆绑包中，目前，您"
"的应用程序中仍有旧代码。"

#: docs/en/tutorial/tutorial-4.md:63
msgid ""
"So - we need to tell briefcase to update your app, copying in the new "
"version of the code. We *could* do this by deleting the old platform "
"directory and starting from scratch. However, Briefcase provides an easier "
"way - you can update the code for your existing bundled application:"
msgstr ""
"因此，我们需要告诉 Briefcase 让它更新应用程序，复制新版本的代码。我们\\ *可以"
"*\\ 删除旧的平台目录，然后从头开始。不过，Briefcase 提供了一种更简单的方法--"
"您可以更新现有捆绑的应用程序的代码："

#: docs/en/tutorial/tutorial-4.md:120
msgid ""
"If Briefcase can't find the scaffolded template, it will automatically "
"invoke `create` to generate a fresh scaffold."
msgstr "如果 Briefcase 找不到脚手架模板，它会自动调用 `create` 生成一个新的脚手架。"

#: docs/en/tutorial/tutorial-4.md:122
msgid ""
"Now that we've updated the installer code, we can then run `briefcase build` "
"to re-compile the app, `briefcase run` to run the updated app, and `"
"briefcase package` to repackage the application for distribution."
msgstr ""
"更新了安装程序代码后，我们就可以运行 `briefcase build` 来重新编译应用程序，运"
"行 `briefcase run` 来运行更新后的应用程序，并运行 `briefcase package` 来重新"
"打包应用程序以便分发。"

#: docs/en/tutorial/tutorial-4.md:126
#, fuzzy
msgid ""
"macOS users, remember that as noted in [Tutorial 3]{1}, for the tutorial we "
"recommend running `briefcase package` with the `--adhoc-sign` flag to avoid "
"the complexity of setting up a code signing identity and keep the tutorial "
"as simple as possible."
msgstr ""
"(macOS 用户请记住，正如 [Tutorial 3<tutorial-3>` 中所述，我们建议在运行 `"
"briefcase package` 时使用 `--adhoc-sign` 标志，以避免设置代码签名身份的复杂性"
"，并使教程尽可能简单）"

#: docs/en/tutorial/tutorial-4.md:130
msgid "Update and run in one step"
msgstr "更新和运行一步到位"

#: docs/en/tutorial/tutorial-4.md:132
msgid ""
"If you're rapidly iterating code changes, you'll likely want to make a code "
"change, update the application, and immediately re-run your application. For "
"most purposes, developer mode (`briefcase dev`) will be the easiest way to "
"do this sort of rapid iteration; however, if you're testing something about "
"how your application runs as a native binary, or hunting a bug that only "
"manifests when your application is in packaged form, you may need to use "
"repeated calls to `briefcase run`. To simplify the process of updating and "
"running the bundled app, Briefcase has a shortcut to support this usage "
"pattern - the `-u` (or `--update`) option on the `run` command."
msgstr ""
"如果要快速迭代代码更改，很可能需要更改代码、更新应用程序并立即重新运行应用程"
"序。对于大多数情况来说，开发人员模式 (`briefcase dev`) 是进行这种快速迭代的最"
"简单方法；但是，如果您要测试应用程序作为原生二进制文件的运行，或查找一个只有"
"在应用程序打包时才会出现的错误，您可能需要反复调用 `briefcase run`。为了简化"
"更新和运行打包应用程序的过程，Briefcase 提供了支持这种使用模式的快捷方式 - "
"`run` 命令上的 `-u`（或 `--update`）选项。"

#: docs/en/tutorial/tutorial-4.md:134
msgid ""
"Let's try making another change. You may have noticed that if you don't type "
"a name in the text input box, the dialog will say \"Hello, \". Let's modify "
"the `say_hello` function again to handle this edge case."
msgstr ""
"让我们尝试做另一个改动。您可能已经注意到，如果您不在文本输入框中输入姓名，对"
"话框就会显示 \"Hello, \"。 让我们再次修改 `say_hello` 函数，以处理这种边缘情"
"况。"

#: docs/en/tutorial/tutorial-4.md:136
msgid ""
"At the top of the file, between the imports and the `class HelloWorld` "
"definition, add a utility method to generate an appropriate greeting "
"depending on the value of the name that has been provided:"
msgstr "在文件顶部，在导入和 `class HelloWorld` 定义之间，添加一个实用程序方法，以根"
"据所提供的名称值生成适当的问候语:"

#: docs/en/tutorial/tutorial-4.md:146
msgid "Then, modify the `say_hello` callback to use this new utility method:"
msgstr "然后，修改 `say_hello` 回调，以使用这个新的实用程序方法:"

#: docs/en/tutorial/tutorial-4.md:158
msgid ""
"Run your app in development mode (with `briefcase dev`) to confirm that the "
"new logic works; then update, build and run the app with one command:"
msgstr "在开发模式下运行应用程序（使用 `briefcase dev`），以确认新逻辑是否有效；然后"
"使用一条命令更新、构建和运行应用程序："

#: docs/en/tutorial/tutorial-4.md:230
msgid ""
"The package command also accepts the `-u` argument, so if you make a change "
"to your application code and want to repackage immediately, you can run `"
"briefcase package -u`."
msgstr ""
"package 命令也接受 `-u` 参数，因此如果你修改了应用程序代码并希望立即重新打包"
"，可以运行 `briefcase package -u`。"

#: docs/en/tutorial/tutorial-4.md:234
msgid ""
"We now have our application packaged for distribution on desktop platforms, "
"and we've been able to update the code in our application."
msgstr "现在，我们的应用程序已经打包，可以在桌面平台上发布，我们也可以更新应用程序中"
"的代码。"

#: docs/en/tutorial/tutorial-4.md:236
#, fuzzy
msgid ""
"But what about mobile? In [Tutorial 5]{1}, we'll convert our application "
"into a mobile application, and deploy it onto a device simulator, and onto a "
"phone."
msgstr "那么移动应用呢？在 [教程 5]{1} 中，我们将把应用程序转换为移动应用程序，并将其"
"部署到设备模拟器和手机上。"

#: docs/en/tutorial/tutorial-5/android.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it mobile: Android"
msgstr "教程 5 - 在移动设备上：安卓"

#: docs/en/tutorial/tutorial-5/android.md:3
msgid ""
"Now, we're going to take our application, and deploy it as an Android "
"application."
msgstr "现在，我们要将应用程序部署为 Android 应用程序。"

#: docs/en/tutorial/tutorial-5/android.md:5
msgid ""
"The process of deploying an application to Android is very similar to the "
"process for deploying as a desktop application. Briefcase handles installing "
"dependencies for Android, including the Android SDK, the Android emulator, "
"and a Java compiler."
msgstr ""
"将应用程序部署到 Android 的过程与部署为桌面应用程序的过程非常相似。Briefcase "
"会处理 Android 上的依赖项的安装，包括 Android SDK、Android 模拟器，和一个 "
"Java 编译器。"

#: docs/en/tutorial/tutorial-5/android.md:7
msgid "Create an Android app and compile it"
msgstr "创建并编译 Android 应用程序"

#: docs/en/tutorial/tutorial-5/android.md:9
msgid ""
"First, run the `create` command. This downloads an Android app template and "
"adds your Python code to it."
msgstr "首先，运行 `create` 命令。这会下载一个 Android 应用程序模板，并在其中添加您的"
" Python 代码。"

#: docs/en/tutorial/tutorial-5/android.md:98
msgid ""
"When you run `briefcase create android` for the first time, Briefcase "
"downloads a Java JDK, and the Android SDK. File sizes and download times can "
"be considerable; this may take a while "
"(10 minutes or longer, depending on the speed of your Internet connection). "
"When the download has completed, you will be prompted to accept Google's "
"Android SDK license. There's a number of licenses you'll need to agree too - "
"keep entering `y` at the prompt to review and accept each of the necessary "
"the license agreements."
msgstr ""
"首次运行 `briefcase create android` 时，Briefcase 会下载 Java JDK 和 Android "
"SDK。文件大小较大，且下载时间可能会较长（10 分钟或更长，取决于您的互联网连接"
"速度）。下载完成后，您将会被提示接受 Google 的 Android SDK 许可证。还有一些需"
"要同意的许可证 -- 在提示符不停的按 `y` 以查看与接受所有所需的许可证协议。"

#: docs/en/tutorial/tutorial-5/android.md:100
msgid ""
"Once this completes, we'll have a `build\\helloworld\\android\\gradle` "
"directory in our project, which will contain an Android project with a "
"Gradle build configuration. This project will contain your application code, "
"and a support package containing the Python interpreter."
msgstr ""
"完成后，我们的项目中就会有一个\\ `build/helloworld/android/gradle`\\ 目录，其"
"中包含一个带有 Gradle 构建配置的 Android 项目。这个项目将包含您的应用代码，以"
"及一个包含 Python 解释器的支持包。"

#: docs/en/tutorial/tutorial-5/android.md:102
msgid ""
"We can then use Briefcase's `build` command to compile this into an Android "
"APK app file."
msgstr "然后我们可以使用 Briefcase 的 `build` 命令将其编译为 Android APK 应用程序文件"
"。"

#: docs/en/tutorial/tutorial-5/android.md:164
#, fuzzy
msgid "/// admonition | Gradle may look stuck"
msgstr "/// admonition |Gradle 可能看起来卡住了"

#: docs/en/tutorial/tutorial-5/android.md:166
msgid ""
"During the `briefcase build android` step, Gradle "
"(the Android platform build tool) will print `CONFIGURING: 100%`, and appear "
"to be doing nothing. Don't worry, it's not stuck - it's downloading more "
"Android SDK components. Depending on your Internet connection speed, this "
"may take another 10 minutes (or longer). This lag should only happen the "
"very first time you run `build`; the tools are cached, and on your next "
"build, the cached versions will be used."
msgstr ""
"在 `briefcase build android` 步骤中，Gradle（Android 平台构建工具）会打印 \\ "
"`CONFIGURING: 100%`，似乎什么也没做。别担心，这不是卡住了，而是在下载更多的 "
"Android SDK 组件。根据您的网络连接速度，这可能还需要 10 分钟（或更长时间）。"
"只有在第一次运行 `build` 时才会出现这种滞后现象；这些工具将会被缓存，下次构建"
"时将使用缓存版本。"

#: docs/en/tutorial/tutorial-5/android.md:170
msgid "Run the app on a virtual device"
msgstr "在虚拟设备上运行应用程序"

#: docs/en/tutorial/tutorial-5/android.md:172
msgid ""
"We're now ready to run our application. You can use Briefcase's `run` "
"command to run the app on an Android device. Let's start by running on an "
"Android emulator."
msgstr ""
"现在我们可以运行应用程序了。您可以使用 Briefcase 的 `run` 命令在 Android 设备"
"上运行应用程序。让我们从在 Android 模拟器上运行开始。"

#: docs/en/tutorial/tutorial-5/android.md:174
msgid ""
"To run your application, run `briefcase run android`. When you do this, "
"you'll be prompted with a list of devices that you could run the app on. The "
"last item will always be an option to create a new Android emulator."
msgstr ""
"要运行应用程序，请运行 `briefcase run android`。运行时，系统会提示你可以在哪"
"些设备上运行应用程序。最后一项总会是创建新安卓模拟器的选项。"

#: docs/en/tutorial/tutorial-5/android.md:218
msgid ""
"We can now choose our desired device. Select the "
"\"Create a new Android emulator\" option, and accept the default choice for "
"the device name (`beePhone`)."
msgstr ""
"现在我们可以选择想要的设备。选择 \"Create a new Android emulator\" 选项，并接"
"受默认的设备名称（`beePhone`）。"

#: docs/en/tutorial/tutorial-5/android.md:220
msgid ""
"Briefcase `run` will automatically boot the virtual device. When the device "
"is booting, you will see the Android logo:"
msgstr "Briefcase `run` 将自动启动虚拟设备。设备启动时，您将看到 Android 徽标："

#: docs/en/tutorial/tutorial-5/android.md:222
#, fuzzy
msgid "![Android virtual device booting]{1}"
msgstr "安卓虚拟设备启动]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:226
#, fuzzy
msgid "Android virtual device booting"
msgstr "启动安卓虚拟设备"

#: docs/en/tutorial/tutorial-5/android.md:230
msgid ""
"Once the device has finished booting, Briefcase will install your app on the "
"device. You will briefly see a launcher screen:"
msgstr "设备启动完成后，Briefcase 将在设备上安装您的应用程序。您将短暂看到一个启动页"
"面："

#: docs/en/tutorial/tutorial-5/android.md:232
#, fuzzy
msgid "![Android virtual device fully started, on the launcher screen]{1}"
msgstr "安卓虚拟设备已完全启动，显示在启动器屏幕上]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:236
#, fuzzy
msgid "Android virtual device fully started, on the launcher screen"
msgstr "安卓虚拟设备已完全启动，显示在启动器屏幕上"

#: docs/en/tutorial/tutorial-5/android.md:240
msgid ""
"The app will then start. You'll see a splash screen while the app starts up:"
msgstr "然后，应用程序就会启动。程序启动时，你会看到一个闪屏："

#: docs/en/tutorial/tutorial-5/android.md:242
#, fuzzy
msgid "![App splash screen]{1}"
msgstr "应用程序闪屏]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:246
#, fuzzy
msgid "App splash screen"
msgstr "应用程序闪屏"

#: docs/en/tutorial/tutorial-5/android.md:250
#, fuzzy
msgid "/// admonition | The emulator didn't start!"
msgstr "/// admonition |模拟器没有启动！"

#: docs/en/tutorial/tutorial-5/android.md:252
msgid ""
"The Android emulator is a complex piece of software that relies on a number "
"of hardware and operating system features - features that may not be "
"available or enabled on older machines. If you experience any difficulties "
"starting the Android emulator, consult the [Requirements and recommendations]"
"{1} section of the Android developer documentation."
msgstr ""
"安卓模拟器是一个复杂的软件，依赖于许多硬件和操作系统功能，这些功能在旧机器上"
"可能无法使用或启用。如果在启动 Android 模拟器时遇到任何困难，请查阅 Android "
"开发人员文档中的\\ [要求和建议]{1} 部分。"

#: docs/en/tutorial/tutorial-5/android.md:256
msgid ""
"The first time the app starts, it needs to unpack itself onto the device. "
"This may take a few seconds. Once it's unpacked, you'll see the Android "
"version of our desktop app:"
msgstr "首次启动应用程序时，它需要将自己解压缩到设备上。这可能需要几秒钟。解压完成后"
"，您将看到桌面应用程序的 Android 版本："

#: docs/en/tutorial/tutorial-5/android.md:258
#, fuzzy
msgid "![Demo app fully launched]{1}"
msgstr "演示程序已完全启动]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:262
#, fuzzy
msgid "Demo app fully launched"
msgstr "演示应用程序全面启动"

#: docs/en/tutorial/tutorial-5/android.md:266
#, fuzzy
msgid ""
"If you fail to see your app launching, you may need to check your terminal "
"where you ran `briefcase run` and look for any error messages."
msgstr "如果看不到应用程序启动，可能需要检查运行 `briefcase run` 的终端，查看是否有错"
"误信息。"

#: docs/en/tutorial/tutorial-5/android.md:268
#, fuzzy
msgid ""
"While the app is running, you'll see a lot of messages being streamed in the "
"console. This is a stream of the application's logs from the emulator. "
"Typing Ctrl+C into the terminal will halt the streamed information in the "
"console, but it will not close the emulator. This is so you can test new "
"changes without restarting the emulator."
msgstr ""
"程序运行时，你会在控制台中看到大量信息流。这是来自模拟器的应用程序日志流。在"
"终端输入 Ctrl+C 将停止控制台中的信息流，但不会关闭模拟器。这样你就可以在不重"
"启模拟器的情况下测试新的更改。"

#: docs/en/tutorial/tutorial-5/android.md:270
#, fuzzy
msgid ""
"In future, if you want to run on this device without using the menu, you can "
"provide the emulator's name to Briefcase, using `briefcase run android -d "
"\"@beePhone\"` to run on the virtual device directly."
msgstr ""
"今后，如果想在该设备上运行而不使用菜单，可以向 Briefcase 提供模拟器名称，使用"
" `briefcase run android -d @beePhone` 直接在虚拟设备上运行。"

#: docs/en/tutorial/tutorial-5/android.md:272
#, fuzzy
msgid "Run the app on a physical device"
msgstr "在实体设备上运行应用程序"

#: docs/en/tutorial/tutorial-5/android.md:274
#, fuzzy
msgid ""
"If you have a physical Android phone or tablet, you can connect it to your "
"computer with a USB cable, and then use the Briefcase to target your "
"physical device."
msgstr "如果您有实体安卓手机或平板电脑，可以用 USB 线缆将其连接到电脑，然后使用公文包"
"来定位您的实体设备。"

#: docs/en/tutorial/tutorial-5/android.md:276
#, fuzzy
msgid ""
"Android requires that you prepare your device before it can be used for "
"development. You will need to make 2 changes to the options on your device:"
msgstr "Android 要求您在设备用于开发前做好准备。您需要对设备上的选项进行两项更改："

#: docs/en/tutorial/tutorial-5/android.md:278
#, fuzzy
msgid "Enable developer options"
msgstr "启用开发人员选项"

#: docs/en/tutorial/tutorial-5/android.md:279
#, fuzzy
msgid "Enable USB debugging"
msgstr "启用 USB 调试"

#: docs/en/tutorial/tutorial-5/android.md:281
#, fuzzy
msgid ""
"Details on how to make these changes can be found "
"[in the Android developer documentation]{1}."
msgstr "有关如何进行这些更改的详细信息，请参阅 Android 开发人员文档]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:283
#, fuzzy
msgid ""
"Once these steps have been completed, your device should appear in the list "
"of available devices when you run `briefcase run android`."
msgstr "完成这些步骤后，在运行 `briefcase run android` 时，您的设备应出现在可用设备列"
"表中。"

#: docs/en/tutorial/tutorial-5/android.md:333
#, fuzzy
msgid ""
"Here we can see a new physical device with it's serial number on the "
"deployment list - in this case, a Pixel 3a. In the future, if you want to "
"run on this device without using the menu, you can provide the phone's "
"serial number to Briefcase "
"(in this case, `briefcase run android -d 94ZZY0LNE8`). This will run on the "
"device directly, without prompting."
msgstr ""
"在这里，我们可以在部署列表中看到一个带有序列号的新物理设备--在本例中是 Pixel "
"3a。将来，如果你想不使用菜单而在该设备上运行，可以向 Briefcase 提供手机序列号"
"（本例中为 `briefcase run android -d 94ZZY0LNE8`）。这将直接在设备上运行，无"
"需提示。"

#: docs/en/tutorial/tutorial-5/android.md:335
#, fuzzy
msgid "/// admonition | My device doesn't appear!"
msgstr "/// admonition |我的设备没有出现！"

#: docs/en/tutorial/tutorial-5/android.md:337
#, fuzzy
msgid ""
"If your device doesn't appear on this list at all, either you haven't "
"enabled USB debugging, (or the device isn't plugged in!)."
msgstr "如果你的设备根本没有出现在这个列表中，要么是你没有启用 USB 调试（要么是设备没"
"有插上电源！）。"

#: docs/en/tutorial/tutorial-5/android.md:339
#, fuzzy
msgid ""
"If your device appears, but is listed as "
"\"Unknown device (not authorized for development)\", developer mode hasn't "
"been correctly enabled. Re-run [the steps to enable developer options]{1}, "
"and re-run `briefcase run android`."
msgstr ""
"如果你的设备出现了，但却被列为 \"未知设备（未授权开发）\"，那么开发者模式尚未"
"正确启用。重新运行 [启用开发者选项的步骤]{1}，并重新运行 "
"\"briefcase run android\"。"

#: docs/en/tutorial/tutorial-5/android.md:345
#: docs/en/tutorial/tutorial-5/iOS.md:125
#, fuzzy
msgid ""
"We've now got an application on our phone! Is there anywhere else we can "
"deploy a BeeWare app? Turn to [Tutorial 6]{1} to find out..."
msgstr "我们现在已经在手机上安装了应用程序！还有其他地方可以部署 BeeWare 应用程序吗？"
"转到[教程6]{1}就知道了..."

#: docs/en/tutorial/tutorial-5/iOS.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it mobile: iOS"
msgstr "教程 5 - 在移动设备上：iOS"

#: docs/en/tutorial/tutorial-5/iOS.md:3
msgid ""
"To compile iOS applications we'll need Xcode, which is available for free "
"from [the macOS App Store]{1}. Once Xcode is installed, launch it from "
"Applications and accept the Xcode License Agreement. Next, Xcode will show "
"which components are built-in, and which components you may download. Select "
"the checkbox next to iOS (followed by the current version number), and then "
"click \"Download and Install\" to install it. Xcode will install the system "
"components, followed by the iOS Simulator."
msgstr ""
"编译 iOS 应用程序需要 Xcode，可从 [macOS App Store]{1} 免费下载。当 Xcode 完"
"成安装时，从“应用程序”打开它并接受 Xcode 许可协议。接下来，Xcode 会展示哪些模"
"拟器运行时已内置，哪些可以下载。选择 iOS 模拟器运行时旁边的复选框，并点击“继"
"续”来下载和安装它。"

#: docs/en/tutorial/tutorial-5/iOS.md:5
msgid ""
"Once we've got Xcode and the iOS simulator installed, we can take our "
"application and deploy it as an iOS app."
msgstr "安装好 Xcode 与 iOS 模拟器后，我们就可以将应用程序作为 iOS 应用程序进行部署。"

#: docs/en/tutorial/tutorial-5/iOS.md:7
#, fuzzy
msgid ""
"The process of deploying an application to iOS is very similar to the "
"process for deploying as a desktop application. First, you run the `create` "
"command - but this time, we specify that we want to create an iOS "
"application:"
msgstr ""
"将应用程序部署到 iOS 的过程与部署桌面应用程序的过程非常相似。首先，运行 "
"`create` 命令，但这次我们指定要创建一个 iOS 应用程序："

#: docs/en/tutorial/tutorial-5/iOS.md:34
msgid ""
"Once this completes, we'll have a `build/helloworld/ios/xcode` directory "
"containing an Xcode project, as well as the support libraries and the "
"application code needed for the application."
msgstr ""
"完成此操作后，我们将拥有一个包含 Xcode 项目、支持库和应用程序所需应用程序代码"
"的 `build/helloworld/ios/xcode` 目录。"

#: docs/en/tutorial/tutorial-5/iOS.md:36
msgid ""
"You can then use Briefcase to compile your app using `briefcase build iOS`:"
msgstr "然后，您可以使用 `briefcase build iOS` 来编译应用程序："

#: docs/en/tutorial/tutorial-5/iOS.md:51
msgid ""
"We're now ready to run our application, using `briefcase run iOS`. You'll be "
"prompted to select a device to compile for; if you've got simulators for "
"multiple iOS SDK versions installed, you may also be asked which iOS version "
"you want to target. The options you are shown may differ from the options "
"show in this output - at the very least, the list of devices will likely be "
"different. For our purposes, it doesn't matter which simulator you pick."
msgstr ""
"现在我们可以使用 `briefcase run iOS` 运行应用程序了。Briefcase 会提示你选择要"
"编译的设备；如果你安装了多个 iOS SDK 版本的模拟器，可能还会询问你要针对哪个 "
"iOS 版本。所显示的选项可能与此输出中显示的选项不同，至少设备列表可能不同。就"
"我们而言，选择哪个模拟器并不重要。"

#: docs/en/tutorial/tutorial-5/iOS.md:95
msgid ""
"This will start the iOS simulator, install your app, and start it. You "
"should see the simulator start, and eventually open your iOS application:"
msgstr "这将启动 iOS 模拟器，安装你的应用程序并启动它。你应该能看到模拟器启动，并最终"
"打开你的 iOS 应用程序："

#: docs/en/tutorial/tutorial-5/iOS.md:97
#, fuzzy
msgid "![Hello World Tutorial 5 window, on iOS]{1}"
msgstr "![Hello World 教程 5 窗口，在 iOS 上]{1}。"

#: docs/en/tutorial/tutorial-5/iOS.md:103
msgid ""
"While the app is running, you'll see a series of Simulator log output "
"messages in the console. Typing Ctrl+C into the terminal will halt the "
"messages in the console, but it will not close the simulator. This is so you "
"can test new changes without restarting the simulator."
msgstr ""
"当应用程序运行时，您会在控制台中看到一系列模拟器输出信息。向命令行中按 Ctrl +"
" C 会停止控制台中的信息，但不会关闭模拟器。这样，您无需重启模拟器，也能可以继"
"续测试新更改。"

#: docs/en/tutorial/tutorial-5/iOS.md:105
msgid ""
"If you know ahead of time which iOS simulator you want to target, you can "
"tell Briefcase to use that simulator by providing a `-d` (or `--device`) "
"option. Using the name of the device you selected when you built your "
"application, run:"
msgstr ""
"如果事先知道要使用哪个 iOS 模拟器，可以通过提供 `-d`（或 `--device`）选项告诉"
" Briefcase 使用该模拟器。使用创建应用程序时选择的设备名称，运行:"

#: docs/en/tutorial/tutorial-5/iOS.md:111
msgid ""
"If you have multiple iOS versions available, Briefcase will pick the highest "
"iOS version; if you want to pick a particular iOS version, you tell it to "
"use that specific version:"
msgstr "如果你有多个 iOS 版本，Briefcase 会选择最高的 iOS 版本；如果你想选择某个 iOS "
"版本，你可以告诉它使用该特定版本："

#: docs/en/tutorial/tutorial-5/iOS.md:117
msgid "Or, you can name a specific device UDID:"
msgstr "或者，您也可以命名一个特定的设备 UDID："

#: docs/en/tutorial/tutorial-5/index.md:1
msgid "Tutorial 5 - Taking it Mobile"
msgstr "教程 5 - 在移动设备上"

#: docs/en/tutorial/tutorial-5/index.md:3
msgid ""
"So far, we've been running and testing our application on the desktop. "
"However, BeeWare also supports mobile platforms - and the application we've "
"written can be deployed to your mobile device, too!"
msgstr "到目前为止，我们一直在电脑上运行和测试应用程序。不过，BeeWare 同样支持移动平"
"台，我们编写的应用程序也可以部署到您的移动设备上！"

#: docs/en/tutorial/tutorial-5/index.md:5
#, fuzzy
msgid "[Android]{1}"
msgstr "[Android]{1}"

#: docs/en/tutorial/tutorial-5/index.md:7
msgid "Android applications can be compiled on macOS, Windows or Linux."
msgstr "安卓应用程序可在 macOS、Windows 或 Linux 上编译。"

#: docs/en/tutorial/tutorial-5/index.md:9
#, fuzzy
msgid "[iOS]{1}"
msgstr "[iOS]{1}"

#: docs/en/tutorial/tutorial-5/index.md:11
msgid "iOS applications can only be compiled on macOS."
msgstr "iOS 应用程序只能在 macOS 上编译。"

#: docs/en/tutorial/tutorial-6.md:1
msgid "Tutorial 6 - Put it on the web!"
msgstr "教程 6 - 把它放上网！"

#: docs/en/tutorial/tutorial-6.md:3
msgid ""
"In addition to supporting mobile platforms, the Toga widget toolkit also "
"supports the web! Using the same API that you used to deploy your desktop "
"and mobile applications, you can deploy your application as a single-page "
"web app."
msgstr "除了支持移动平台，Toga 控件工具包还支持网络！使用与部署桌面和移动应用程序相同"
"的应用程序接口，您可以将应用程序部署为单页网页应用程序。"

#: docs/en/tutorial/tutorial-6.md:5
msgid "/// admonition | Proof of Concept"
msgstr "/// admonition | 概念验证"

#: docs/en/tutorial/tutorial-6.md:7
msgid ""
"The Toga Web backend is the least mature of all the Toga backends. It's "
"mature enough to show off a few features, but it's likely to be buggy, and "
"will be missing many of the widgets that are available on other platforms. "
"At this point in time, Web deployment should be considered a "
"\"Proof of Concept\" - enough to demonstrate what can be done, but not "
"enough to be relied on for serious development."
msgstr ""
"Toga Web 后端是所有 Toga 后端中最不成熟的一个。它已经足够成熟，可以展示一些功"
"能，但很可能会有问题，而且会缺少许多其他平台上可用的控件。目前，Web 部署应被"
"视为“概念验证”--足以展示可以做什么，但还不足以作为严肃开发的依据。"

#: docs/en/tutorial/tutorial-6.md:9
msgid ""
"If you have problems with this step of the tutorial, you can skip to the "
"next page."
msgstr "如果您在教程的这一步遇到问题，可以跳到下一页。"

#: docs/en/tutorial/tutorial-6.md:13
msgid "Deploying as a web app"
msgstr "作为网页应用程序部署"

#: docs/en/tutorial/tutorial-6.md:15
msgid ""
"The process of deploying as a single-page web app follows the same familiar "
"pattern - you create the application, then build the application, then run "
"it. However, Briefcase can be a little bit smart; if you attempt to run an "
"application, and Briefcase determines that it hasn't been created or built "
"for the platform being targeted, it will do the create and build steps for "
"you. Since this is our first time running the app for the web, we can "
"perform all three steps with one command:"
msgstr ""
"作为单页面 Web 应用程序部署的过程遵循相同的熟悉模式--创建应用程序，然后构建应"
"用程序，然后运行它。不过，Briefcase 也有一点小聪明；如果您尝试运行应用程序，"
"而 Briefcase 确定该应用程序尚未针对目标平台创建或构建，那么它会为您执行创建和"
"构建步骤。由于这是我们第一次为网络运行应用程序，我们可以用一条命令执行所有三"
"个步骤："

#: docs/en/tutorial/tutorial-6.md:137
#, fuzzy
msgid "This will open a web browser, pointing at {1}:"
msgstr "这将打开一个网络浏览器，指向 {1}："

#: docs/en/tutorial/tutorial-6.md:139
#, fuzzy
msgid "![Hello World Tutorial 6 dialog, in a browser]{1}"
msgstr "![浏览器中的 \"你好世界教程 6 \"对话框]{1}。"

#: docs/en/tutorial/tutorial-6.md:141
msgid "If you enter your name and click the button, a dialog will appear."
msgstr "如果输入您的姓名并点击按钮，就会出现一个对话框。"

#: docs/en/tutorial/tutorial-6.md:143
msgid "How does this work?"
msgstr "这是怎么工作的？"

#: docs/en/tutorial/tutorial-6.md:145
msgid ""
"This web app is a static website - a single HTML source page, with some CSS "
"and other resources. Briefcase has started a local web server to serve this "
"page so your browser can view the page. If you wanted to put this web page "
"into production, you could copy the contents of the `www` folder onto any "
"web server that can serve static content."
msgstr ""
"此网络应用程序是一个静态网站 -- 一个 HTML 源页面，包含一些 CSS 和其他资源。"
"Briefcase 启动了一个本地网络服务器来提供该页面，以便您的浏览器可以查看该页面"
"。如果您想将此网页进入生产，可以将 `www` 文件夹中的内容复制到任何可以提供静态"
"内容的网络服务器上。"

#: docs/en/tutorial/tutorial-6.md:147
#, fuzzy
msgid ""
"But when you press the button, you're running Python code... how does that "
"work? Toga uses [PyScript]{1} to provide a Python interpreter in the "
"browser. Briefcase packages your app's code as wheels that PyScript can load "
"in the browser. When the page is loaded, the application code runs in the "
"browser, building the UI using the browser DOM. When you click a button, "
"that button runs the event handling code in the browser."
msgstr ""
"但是，当你按下按钮时，你运行的是 Python 代码......这是怎么做到的呢？Toga 使用"
" [PyScript]{1} 在浏览器中提供 Python 解释器。公文包将应用程序的代码打包成 "
"PyScript 可以在浏览器中加载的轮子。加载页面时，应用代码会在浏览器中运行，并使"
"用浏览器 DOM 构建用户界面。当您点击按钮时，该按钮会在浏览器中运行事件处理代码"
"。"

#: docs/en/tutorial/tutorial-6.md:151
#, fuzzy
msgid ""
"Although we've now deployed this app on desktop, mobile and the web, the app "
"is fairly simple, and doesn't involve any third-party libraries. Can we "
"include libraries from the Python Package Index (PyPI) in our app? Turn to "
"[Tutorial 7]{1} to find out..."
msgstr ""
"虽然我们现在已经在桌面、手机和网络上部署了这个应用程序，但该应用程序相当简单"
"，不涉及任何第三方库。我们可以在应用程序中包含 Python 包索引 (PyPI) 中的库吗"
"？请访问 [教程7]{1} 了解详情..."

#: docs/en/tutorial/tutorial-7.md:1
#, fuzzy
msgid "Tutorial 7 - Get this (third-)party started"
msgstr "教程 7 - 使用第三方库"

#: docs/en/tutorial/tutorial-7.md:3
msgid ""
"So far, the app we've built has only used our own code, plus the code "
"provided by BeeWare. However, in a real-world app, you'll likely want to use "
"a third-party library, downloaded from the Python Package Index (PyPI)."
msgstr ""
"到目前为止，我们构建的应用程序只使用了我们自己的代码和 BeeWare 提供的代码。不"
"过，在实际应用中，您很可能需要使用从 Python 软件包索引（PyPI）下载的第三方库"
"。"

#: docs/en/tutorial/tutorial-7.md:5
msgid "Let's modify our app to include a third-party library."
msgstr "让我们修改应用程序，加入第三方库。"

#: docs/en/tutorial/tutorial-7.md:7
msgid "Adding a package"
msgstr "添加软件包"

#: docs/en/tutorial/tutorial-7.md:9
msgid ""
"Let's modify our application to say a little bit more than just "
"\"Hi, there!\"."
msgstr "让我们修改我们的应用程序，使其能够显示比“你好！”更丰富的内容。"

#: docs/en/tutorial/tutorial-7.md:11
#, fuzzy
msgid ""
"To generate some more interesting text for the dialog, we're going to use a "
"library called [Faker]{1}. Faker is a Python package that generates fake "
"content, including names and text blocks. The names and words in the text "
"block are generated from an arbitrary list of words provided by Faker. We're "
"going to use Faker to construct a fake message, as if someone is responding "
"to the user."
msgstr ""
"为了给对话框生成一些更有趣的文本，我们将使用一个名为 [Faker]{1} 的库。Faker "
"是一个 Python 软件包，用于生成虚假内容，包括名称和文本块。文本块中的名称和单"
"词由 Faker 提供的任意单词列表生成。我们将使用 Faker 构建一条虚假信息，就像有"
"人在回复用户一样。"

#: docs/en/tutorial/tutorial-7.md:13
msgid ""
"We start by adding `faker` to our app. Add an import to the top of the "
"`app.py` to import `faker`:"
msgstr "我们开始吧 `faker` 添加到我们的应用程序中。在 `app.py` 的最上方加入一个导入，"
"用于导入 `faker`:"

#: docs/en/tutorial/tutorial-7.md:19
#: docs/en/tutorial/tutorial-8.md:32
msgid "Then modify the `say_hello()` callback so it looks like this:"
msgstr "然后修改 `say_hello()` 回调，使其看起来像这样:"

#: docs/en/tutorial/tutorial-7.md:32
msgid ""
"Let's run our updated app in Briefcase developer mode to check that our "
"change has worked."
msgstr "让我们在 Briefcase 开发者模式下运行更新后的应用程序，检查我们的更改是否有效。"

#: docs/en/tutorial/tutorial-7.md:102
#: docs/en/tutorial/tutorial-7.md:167
#: docs/en/tutorial/tutorial-8.md:124
#, fuzzy
msgid ""
"You can't run an Android app in developer mode - use the instructions for "
"your chosen desktop platform."
msgstr "您无法在开发者模式下运行 Android 应用程序，请使用所选桌面平台的说明。"

#: docs/en/tutorial/tutorial-7.md:108
#: docs/en/tutorial/tutorial-7.md:173
#: docs/en/tutorial/tutorial-8.md:130
#, fuzzy
msgid ""
"You can't run an iOS app in developer mode - use the instructions for your "
"chosen desktop platform."
msgstr "您无法在开发者模式下运行 iOS 应用程序，请使用所选桌面平台的说明。"

#: docs/en/tutorial/tutorial-7.md:112
msgid ""
"What happened? We've added `faker` to our *code*, but we haven't added it to "
"our development virtual environment. We can fix this by installing `faker` "
"with `pip`, and then re-running `briefcase dev`:"
msgstr ""
"发生了什么？我们已经将 `faker` 添加到我们的\\ *代码*\\ 中，但我们还没有将它添"
"加到我们的开发虚拟环境中。要解决这个问题，我们可以用 `pip` 安装 `faker`，然后"
"重新运行 `briefcase dev`："

#: docs/en/tutorial/tutorial-7.md:121
#: docs/en/tutorial/tutorial-7.md:138
#: docs/en/tutorial/tutorial-7.md:155
#: docs/en/tutorial/tutorial-8.md:70
#: docs/en/tutorial/tutorial-8.md:91
#: docs/en/tutorial/tutorial-8.md:112
msgid ""
"When you enter a name and press the button, you should see a dialog that "
"looks something like:"
msgstr "输入名称并按下按钮后，您会看到一个类似如下的对话框："

#: docs/en/tutorial/tutorial-7.md:123
#, fuzzy
msgid "![Hello World Tutorial 7 dialog, on macOS]{1}"
msgstr "Hello World 教程 7 对话框，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:140
#, fuzzy
msgid "![Hello World Tutorial 7 dialog, on Linux]{1}"
msgstr "![Hello World 教程 7 对话框，在 Linux 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:157
#, fuzzy
msgid "![Hello World Tutorial 7 dialog, on Windows]{1}"
msgstr "![Hello World 教程 7 对话框，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-7.md:177
msgid ""
"We've now got a working app, using a third party library, running in "
"development mode!"
msgstr "现在，我们已经有了一个可正常运行的应用程序，它使用第三方库，并以开发模式运行"
"！"

#: docs/en/tutorial/tutorial-7.md:179
msgid "Running the updated app"
msgstr "运行更新后的应用程序"

#: docs/en/tutorial/tutorial-7.md:181
#, fuzzy
msgid ""
"Let's get this updated application code packaged as a standalone app. Since "
"we've made code changes, we need to follow the same steps as in [Tutorial 4]"
"{1}:"
msgstr ""
"让我们将更新后的应用程序代码打包为独立应用程序。由于我们对代码进行了修改，因"
"此需要遵循 [Tutorial 4<tutorial-4>` 中的相同步骤："

#: docs/en/tutorial/tutorial-7.md:185
#: docs/en/tutorial/tutorial-7.md:226
#: docs/en/tutorial/tutorial-7.md:281
#: docs/en/tutorial/tutorial-7.md:322
#: docs/en/tutorial/tutorial-7.md:397
#, fuzzy
msgid "Update the code in the packaged app:"
msgstr "更新打包应用程序中的代码："

#: docs/en/tutorial/tutorial-7.md:196
#: docs/en/tutorial/tutorial-7.md:237
#: docs/en/tutorial/tutorial-7.md:292
#: docs/en/tutorial/tutorial-7.md:333
#: docs/en/tutorial/tutorial-7.md:408
#, fuzzy
msgid "Rebuild the app:"
msgstr "重建应用程序："

#: docs/en/tutorial/tutorial-7.md:205
#: docs/en/tutorial/tutorial-7.md:251
#: docs/en/tutorial/tutorial-7.md:301
#, fuzzy
msgid "And finally, run the app:"
msgstr "最后，运行应用程序："

#: docs/en/tutorial/tutorial-7.md:214
#: docs/en/tutorial/tutorial-7.md:310
#, fuzzy
msgid ""
"However, when the app runs, you'll see an error in the console, plus a crash "
"dialog:"
msgstr "但是，当程序运行时，你会在控制台中看到一个错误，还有一个崩溃对话框："

#: docs/en/tutorial/tutorial-7.md:216
#, fuzzy
msgid "![Hello World Tutorial 7 app crash, on macOS]{1}"
msgstr "你好世界教程 7》应用程序崩溃，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:260
#: docs/en/tutorial/tutorial-7.md:352
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console:"
msgstr "但是，当应用程序运行时，您会在控制台中看到一个错误："

#: docs/en/tutorial/tutorial-7.md:312
#, fuzzy
msgid "![Hello World Tutorial 7 app crash, on Windows]{1}"
msgstr "Hello World教程7应用程序崩溃，在Windows上]{1}。"

#: docs/en/tutorial/tutorial-7.md:343
#: docs/en/tutorial/tutorial-7.md:418
#, fuzzy
msgid "And finally, run the app (selecting a simulator when prompted):"
msgstr "最后，运行应用程序（根据提示选择模拟器）："

#: docs/en/tutorial/tutorial-7.md:428
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console"
msgstr "但是，当应用程序运行时，您会在控制台中看到一个错误："

#: docs/en/tutorial/tutorial-7.md:443
#, fuzzy
msgid ""
"Once again, the app has failed to start because `faker` has not been "
"installed - but why? Haven't we already installed `faker`?"
msgstr "又一次，应用程序无法启动，因为`faker`尚未安装--但为什么呢？我们不是已经安装了"
" `faker`吗？"

#: docs/en/tutorial/tutorial-7.md:445
#, fuzzy
msgid ""
"We have - but only in the development environment. Your development "
"environment is entirely local to your machine - and is only enabled when you "
"explicitly activate it. Although Briefcase has a development mode, the main "
"reason you'd use Briefcase is to package up your code so you can give it to "
"someone else."
msgstr ""
"我们有，但仅限于开发环境。你的开发环境完全在你的机器本地，只有当你明确激活它"
"时才会启用。虽然公文包有开发模式，但使用公文包的主要原因是打包你的代码，这样"
"你就可以把它交给别人。"

#: docs/en/tutorial/tutorial-7.md:447
#, fuzzy
msgid ""
"The only way to guarantee that someone else will have a Python environment "
"that contains everything it needs is to build a completely isolated Python "
"environment. This means there's a completely isolated Python install, and a "
"completely isolated set of dependencies. This is what Briefcase is building "
"when you run `briefcase build` - an isolated Python environment. This also "
"explains why `faker` isn't installed - it has been installed in your "
"*development* environment, but not in the packaged app."
msgstr ""
"要保证别人的 Python 环境包含它所需要的一切，唯一的办法就是构建一个完全隔离的 "
"Python 环境。这意味着有一个完全独立的 Python 安装，和一套完全独立的依赖关系。"
"这就是当你运行 `briefcase build` 时，Briefcase 正在构建的 - 一个隔离的 "
"Python 环境。这也解释了为什么没有安装 `httpx` - 它已经安装在你的开发环境中，"
"但没有安装在打包的应用程序中。"

#: docs/en/tutorial/tutorial-7.md:449
#, fuzzy
msgid "So - we need to tell Briefcase that our app has an external dependency."
msgstr "因此，我们需要告诉 Briefcase，我们的应用程序有一个外部依赖关系。"

#: docs/en/tutorial/tutorial-7.md:451
#, fuzzy
msgid "Updating dependencies"
msgstr "更新依赖项"

#: docs/en/tutorial/tutorial-7.md:453
#, fuzzy
msgid ""
"In the root directory of your app, there is a file named `pyproject.toml`. "
"This file contains all the app configuration details that you provided when "
"you originally ran `briefcase new`."
msgstr ""
"在应用程序的根目录中，有一个名为 `pyproject.toml` 的文件。该文件包含您最初运"
"行 `briefcase new` 时提供的所有应用程序配置详细信息。"

#: docs/en/tutorial/tutorial-7.md:455
#, fuzzy
msgid ""
"`pyproject.toml` is broken up into sections; one of the sections describes "
"the settings for your app:"
msgstr "pyproject.toml \"分为多个部分，其中一部分描述了应用程序的设置：："

#: docs/en/tutorial/tutorial-7.md:467
#, fuzzy
msgid ""
"The `requires` option describes the dependencies of our application. It is a "
"list of strings, specifying libraries (and, optionally, versions) of "
"libraries that you want to be included with your app."
msgstr "requires \"选项描述了应用程序的依赖关系。它是一个字符串列表，其中指定了您希望"
"应用程序包含的库（以及可选的版本）。"

#: docs/en/tutorial/tutorial-7.md:469
#, fuzzy
msgid "Modify the `requires` setting so that it reads:"
msgstr "修改 `requires` 设置为：："

#: docs/en/tutorial/tutorial-7.md:477
#, fuzzy
msgid ""
"By adding this setting, we're telling Briefcase \"when you build my app, run "
"`pip install faker` into the application bundle\". Anything that would be "
"legal input to `pip install` can be used here - so, you could specify:"
msgstr ""
"通过添加此设置，我们告诉 Briefcase \"当你构建我的应用程序时，运行 `pip instal"
"l httpx` 到应用程序捆绑包中\"。任何可以合法输入到 `pip install` 的内容都可以"
"在这里使用--因此，你可以指定："

#: docs/en/tutorial/tutorial-7.md:479
#, fuzzy
msgid "A specific library version (e.g., `\"faker==37.3.0\"`);"
msgstr "特定的库版本（例如， `\"httpx===0.19.0\"` ）;"

#: docs/en/tutorial/tutorial-7.md:480
#, fuzzy
msgid "A range of library versions (e.g., `\"faker>=37\"`);"
msgstr "一系列库版本（例如， `\"httpx>=0.19\"` ）;"

#: docs/en/tutorial/tutorial-7.md:481
#, fuzzy
msgid ""
"A path to a git repository (e.g., `\"git+https://github.com/joke2k/faker/\"`)"
"; or"
msgstr "指向 git 仓库的路径（例如，`\"git+https://github.com/encode/httpx\"`）；或"

#: docs/en/tutorial/tutorial-7.md:482
msgid ""
"A local file path (However - be warned: if you give your code to someone "
"else, this path probably won't exist on their machine!)"
msgstr "本地文件路径（不过需要注意的是：如果你把代码交给别人，这个路径很可能不存在于"
"他们的机器上！）"

#: docs/en/tutorial/tutorial-7.md:484
#, fuzzy
msgid ""
"Further down in `pyproject.toml`, you'll notice other sections that are "
"operating system dependent, like `[tool.briefcase.app.helloworld.macOS]` and "
"`[tool.briefcase.app.helloworld.windows]`. These sections *also* have a "
"`requires` setting. These settings allow you to define additional platform-"
"specific dependencies - so, for example, if you need a platform-specific "
"library to handle some aspect of your app, you can specify that library in "
"the platform-specific `requires` section, and that setting will only be used "
"for that platform. You will notice that the `toga` libraries are all "
"specified in the platform-specific `requires` section - this is because the "
"libraries needed to display a user interface are platform specific."
msgstr ""
"在 `pyproject.toml` 中的更下面部分，你会注意到与操作系统相关的其他部分，如 `"
"[tool.briefcase.app.helloworld.macOS]` 和 `"
"[tool.briefcase.app.helloworld.windows]`。这些部分**也有一个 `requires` 设置"
"。这些设置允许你定义额外的特定平台依赖关系，例如，如果你需要一个特定平台的库"
"来处理应用程序的某些方面，你可以在特定平台的 `requires` 部分中指定该库，而该"
"设置将仅用于该平台。你会注意到，所有的 `toga` 库都是在特定平台的 `requires` "
"部分中指定的，这是因为显示用户界面所需的库都是特定平台的。"

#: docs/en/tutorial/tutorial-7.md:486
#, fuzzy
msgid ""
"In our case, we want `faker` to be installed on all platforms, so we use the "
"app-level `requires` setting. The app-level dependencies will always be "
"installed; the platform-specific dependencies are installed *in addition* to "
"the app-level ones."
msgstr ""
"在我们的例子中，我们希望 `httpx` 安装在所有平台上，因此使用了应用程序级的 "
"`requires` 设置。应用程序级的依赖项始终会被安装；特定平台的依赖项会在应用程序"
"级的依赖项之外*安装。"

#: docs/en/tutorial/tutorial-7.md:488
#, fuzzy
msgid ""
"Now that we've told Briefcase about our additional requirements, we can try "
"packaging our app again. Ensure that you've saved your changes to "
"`pyproject.toml`, and then update your app again - this time, passing in the "
"`-r` flag. This tells Briefcase to update requirements in the packaged app:"
msgstr ""
"既然我们已经告诉了 Briefcase 我们的额外需求，那么我们就可以再次尝试打包应用程"
"序了。确保已将更改保存到 `pyproject.toml`，然后再次更新应用程序--这一次，传递"
" `-r` 标志。这将告诉 Briefcase 更新打包应用程序中的需求："

#: docs/en/tutorial/tutorial-7.md:608
#, fuzzy
msgid ""
"Once you've updated, you can run `briefcase build` and `briefcase run` - and "
"you should see your packaged app, with the new dialog behavior."
msgstr ""
"更新完成后，您可以运行 `briefcase build` 和 `briefcase run` - 您应该会看到打"
"包后的应用程序，并带有新的对话框行为。"

#: docs/en/tutorial/tutorial-7.md:612
#, fuzzy
msgid ""
"The `-r` option for updating requirements is also honored by the `build` and "
"`run` command, so if you want to update, build, and run in one step, you "
"could use `briefcase run -u -r`."
msgstr ""
"用于更新需求的 `-r` 选项也会被 `build` 和 `run` 命令接受，因此如果你想一步完"
"成更新、编译和运行，可以使用 `briefcase run -u -r`。"

#: docs/en/tutorial/tutorial-7.md:616
#, fuzzy
msgid "Third-Party Python Packages for Mobile and Web"
msgstr "用于移动和网络的第三方 Python 软件包"

#: docs/en/tutorial/tutorial-7.md:618
#, fuzzy
msgid ""
"Faker is just one example of a third-party Python package - a collection of "
"code that isn't part what Python provides out of the box. These third-party "
"packages are most commonly distributed using the "
"[Python Package Index (PyPI)]{1}, and installed into your local virtual "
"environment. We've been using `pip` in this tutorial, but there are other "
"options."
msgstr ""
"Faker 只是第三方 Python 软件包的一个例子，它是 Python 开箱即用之外的代码集合"
"。这些第三方软件包通常使用 [Python Package Index (PyPI)]{1} 发布，并安装到本"
"地虚拟环境中。我们在本教程中使用了 `pip`，但也有其他选择。"

#: docs/en/tutorial/tutorial-7.md:620
#, fuzzy
msgid ""
"On desktop platforms (macOS, Windows, Linux), essentially any package on "
"PyPI package can be installed into your virtual environment, or added to "
"your app's requirements. However, when building an app for mobile or web "
"platforms, [your options are slightly limited]{1}."
msgstr ""
"在桌面平台（macOS、Windows、Linux）上，任何可安装的 \"pip \"都可以添加到您的"
"需求中。在移动和网络平台上，[您的选择略显有限]{1}。"

#: docs/en/tutorial/tutorial-7.md:622
#, fuzzy
msgid ""
"In short; any *pure Python* package "
"(i.e. any package created from a project written *only* in Python) can be "
"used without difficulty. Some packages, though, are created from projects "
"that contain both Python and other languages (e.g. C, C++, Rust, etc). Code "
"written in those languages needs to be compiled to platform-specific binary "
"modules before it can be used, and those pre-compiled binary modules are "
"only available on specific platforms. Mobile and web platforms have very "
"different requirements than \"standard\" desktop platforms. At this time, "
"most Python packages don't provide pre-compiled binaries for mobile and web "
"platforms."
msgstr ""
"简而言之，任何*纯 Python* 包（即从*仅*用 Python 编写的项目中创建的包）都可以"
"毫无困难地使用。不过，有些软件包是由包含 Python 和其他语言（如 C、C++、Rust "
"等）的项目创建的。使用这些语言编写的代码需要编译成特定平台的二进制模块才能使"
"用，而这些预编译的二进制模块只能在特定平台上使用。移动平台和网络平台的要求与 "
"\"标准 \"桌面平台截然不同。目前，大多数 Python 软件包都没有为移动平台和网络平"
"台提供预编译二进制文件。"

#: docs/en/tutorial/tutorial-7.md:624
#, fuzzy
msgid ""
"On PyPI, packages are often provided in a pre-built distribution format "
"called *wheels*. To check whether a package is pure Python, look at the PyPI "
"downloads page for the project. If the wheels provided have a `-py3-none-"
"any.whl` suffix (e.g., [Faker]{1}), then they are pure Python wheels. "
"However, if the wheels have version and platform-specific extensions (e.g., "
"[Pillow]{2}, which has wheels with suffixes like "
"`-cp313-cp313-macosx_11_0_arm64.whl` and `-cp39-cp39-win_amd64.whl`), then "
"the wheel *contains a binary component*. That package cannot be installed on "
"mobile or web platforms unless a wheel compatible with those platforms has "
"been provided."
msgstr ""
"在 PyPI 上，软件包通常以一种名为 *wheels* 的预构建发布格式提供。要检查某个软"
"件包是否是纯 Python，请查看该项目的 PyPI 下载页面。如果提供的轮子后缀是 `-py3"
"-none-any.whl`（例如 [Faker]{1}），那么它们就是纯 Python 轮子。但是，如果这些"
"轮子有特定版本和平台的扩展（例如 [Pillow]{2}，它的轮子后缀是 "
"`-cp313-cp313-macosx_11_0_arm64.whl` 和 `cp39-cp39-win_amd64.whl`），那么这个"
"轮子*包含一个二进制组件*。除非提供了与移动或网络平台兼容的滚轮，否则该软件包"
"无法安装在这些平台上。"

#: docs/en/tutorial/tutorial-7.md:626
#, fuzzy
msgid ""
"At this time, *most* binary packages on PyPI don't provide mobile- or web-"
"compatible wheels. To fill this gap, BeeWare provides binaries for some "
"popular binary modules (including `numpy`, `pandas`, and `cryptography`). "
"These wheels are *not* distributed on PyPI, but Briefcase will install those "
"wheels if they're available."
msgstr ""
"目前，PyPI上**多的二进制包都没有提供移动或网络兼容的轮子。为了填补这一空白，"
"BeeWare 为一些流行的二进制模块（包括 `numpy`、`pandas` 和 `cryptography`）提"
"供了二进制文件。这些轮子**没有发布在 PyPI 上，但如果这些轮子可用，Briefcase "
"会安装它们。"

#: docs/en/tutorial/tutorial-7.md:628
msgid ""
"It's *usually* possible to compile binary packages for mobile platforms, but "
"it's not easy to set up -- well outside the scope of an introductory "
"tutorial like this one."
msgstr "*通常*\\ 可以为移动平台编译二进制软件包，但是不容易设置，且远超出了本教程这样"
"的入门教程涵盖的范围。"

#: docs/en/tutorial/tutorial-7.md:632
#, fuzzy
msgid ""
"We've now got an app that uses a third-party library! In [Tutorial 8]{1} "
"we'll learn how to ensure our app remains responsive as we add more complex "
"application logic."
msgstr "我们现在有了一个使用第三方库的应用程序！在 [教程 8]{1} 中，我们将学习如何在添"
"加更复杂的应用程序逻辑时确保应用程序保持响应。"

#: docs/en/tutorial/tutorial-8.md:1
#, fuzzy
msgid "Tutorial 8 - Making it Smooooth"
msgstr "教程 8 - 使其光滑"

#: docs/en/tutorial/tutorial-8.md:3
msgid ""
"So far, our application has been relatively simple - displaying GUI widgets, "
"calling a simple third-party library, and displaying output in a dialog. All "
"these operations happen very quickly, and our application remains responsive."
msgstr ""
"到目前为止，我们的应用程序相对简单——显示图形用户界面控件、调用一个简单的第三"
"方库，以及在对话框中显示输出。所有这些操作都非常迅速，我们的应用程序始终保持"
"响应。"

#: docs/en/tutorial/tutorial-8.md:5
msgid ""
"However, in a real world application, we'll need to perform complex tasks or "
"calculations that may take a while to complete - and as those tasks are "
"performed, we want our application to remain responsive. Let's make a change "
"to our application that might take a little time to complete, and see the "
"changes that need to be made to accommodate that behavior."
msgstr ""
"但是，在实际的应用中，我们将需要进行会需要一会儿才能完成的复杂任务。当这些任"
"务进行时，我们想让我们的应用保持响应。让我们更改我们的应用程序，添加一个需要"
"一些时间才能完成的任务，并看看需要怎样更改应用程序，适应这个新的行为。"

#: docs/en/tutorial/tutorial-8.md:7
msgid "Accessing an API"
msgstr "访问 API"

#: docs/en/tutorial/tutorial-8.md:9
msgid ""
"A common time-consuming task an app will need to perform is to make a "
"request on a web API to retrieve data, and display that data to the user. "
"Web APIs sometimes take a second or two to respond, so if we're calling an "
"API like that, we need to ensure our application doesn't become unresponsive "
"while we wait for the web API to return an answer."
msgstr ""
"应用程序需要进行的一个常见的耗时任务时在一个网络 API 上请求取回数据，并将数据"
"显示给用户。网络 API 有时需要一两秒才能回应，所以如果我们将要访问这种 API，我"
"们需要确保我们的应用在等待网络 API 返回答案时保持响应。"

#: docs/en/tutorial/tutorial-8.md:11
msgid ""
"This is a toy app, so we don't have a *real* API to work with, so we'll use "
"the [{JSON} Placeholder API]{1} as a source of data. The {JSON} Placeholder "
"API has a number of \"fake\" API endpoints you can use as test data. One of "
"those APIs is the `/posts/` endpoint, which returns fake blog posts. If you "
"open `https://jsonplaceholder.typicode.com/posts/42` in your browser, you'll "
"get a JSON payload describing a single post - some [Lorum ipsum]{2} content "
"for a blog post with ID 42."
msgstr ""
"这只是个入门级的应用，我们没有*真正*的API可供调用，所以我们将使用[{JSON}占位"
"符API]{1} 作为数据来源。{JSON}占位符API有一系列“虚假”的API端点可以供您作为测"
"试数据调用。其中之一就是`/posts/`端点，它会返回一些虚假的博客推文。如果您在浏"
"览器中访问`https://jsonplaceholder.typicode.com/posts/42`，您将会得到一串看起"
"来像是在发推文的JSON数据——不过内容是ID为42的一些`乱数假文 [Lorum ipsum]{2}。"

#: docs/en/tutorial/tutorial-8.md:13
msgid ""
"The Python standard library contains all the tools you'd need to access an "
"API. However, the built-in APIs are very low level. They are good "
"implementations of the HTTP protocol - but they require the user to manage "
"lots of low-level details, like URL redirection, sessions, authentication, "
"and payload encoding. As a \"normal browser user\" you're probably used to "
"taking these details for granted, as a browser manages them for you."
msgstr ""
"Python 标准库包含了需要访问一个 API 的所有工具，但这些内置 API 非常低级别。它"
"们良好的实现了 HTTP 协议，但它们要求用户管理 URL 重定向、会话、身份验证、数据"
"编码等许多低级别细节。作为一个 “普通浏览器用户”，您可能会把这些细节的管理是为"
"理所当然的，因为浏览器帮您管理它们。"

#: docs/en/tutorial/tutorial-8.md:15
#, fuzzy
msgid ""
"As a result, people have developed third-party libraries that wrap the built-"
"in APIs and provide a simpler API that is a closer match for the everyday "
"browser experience. We're going to use one of those libraries to access the "
"{JSON} Placeholder API - a library called [`httpx`]{1}. Briefcase uses "
"`httpx` internally, so it's already in your local environment - you don't "
"need to install it separately to use it here."
msgstr ""
"因此，人们开发了第三方库来封装内置 API，并提供更简单的 API，使其更符合日常的"
"浏览器体验。我们将使用其中一个库来访问 {JSON}占位符 API - 一个名为 [`httpx`]"
"{1} 的库。公文包在内部使用 `httpx`，因此它已经存在于本地环境中，无需单独安装"
"即可在此使用。"

#: docs/en/tutorial/tutorial-8.md:17
#, fuzzy
msgid ""
"Let's add a `httpx` API call to our app. Modify the `requires` setting in "
"our `pyproject.toml` to include the new requirement:"
msgstr ""
"让我们为应用程序添加一个 `httpx` API 调用。修改我们的 `pyproject.toml` 中的 "
"`requires` 设置，以包含新需求："

#: docs/en/tutorial/tutorial-8.md:26
#, fuzzy
msgid "Add an import to the top of the `app.py` to import `httpx`:"
msgstr "在 `app.py` 顶部添加导入，以导入 `httpx`："

#: docs/en/tutorial/tutorial-8.md:50
#, fuzzy
msgid ""
"This will change the `say_hello()` callback so that when it is invoked, it "
"will:"
msgstr "这将更改`say_hello()` 回调，使其在被调用时，会"

#: docs/en/tutorial/tutorial-8.md:52
#, fuzzy
msgid "make a GET request on the JSON placeholder API to obtain post 42;"
msgstr "在 JSON 占位符 API 上发出 GET 请求，以获取职位 42；"

#: docs/en/tutorial/tutorial-8.md:53
#, fuzzy
msgid "decode the response as JSON;"
msgstr "将响应解码为 JSON 格式；"

#: docs/en/tutorial/tutorial-8.md:54
#, fuzzy
msgid "extract the body of the post; and"
msgstr "提取帖子正文；以及"

#: docs/en/tutorial/tutorial-8.md:55
#, fuzzy
msgid ""
"include the body of that post as the text of the \"message\" dialog, in "
"place of the text generated by Faker."
msgstr "在 \"消息 \"对话框中加入该帖子的正文，取代 Faker 生成的文本。"

#: docs/en/tutorial/tutorial-8.md:57
#, fuzzy
msgid ""
"Lets run our updated app in Briefcase developer mode to check that our "
"change has worked. As we've added a new requirement, we need to tell "
"developer mode to reinstall requirements, by using the `-r` argument:"
msgstr ""
"让我们在 Briefcase 开发人员模式下运行更新后的应用程序，检查我们的更改是否有效"
"。由于我们添加了一个新需求，因此需要使用 `-r` 参数告诉开发者模式重新安装需求"
"："

#: docs/en/tutorial/tutorial-8.md:72
#, fuzzy
msgid "![Hello World Tutorial 8 dialog, on macOS]{1}"
msgstr "![《Hello World》教程 8 对话框，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-8.md:93
#, fuzzy
msgid "![Hello World Tutorial 8 dialog, on Linux]{1}"
msgstr "![Hello World 教程 8 对话框，在 Linux 上]{1}!"

#: docs/en/tutorial/tutorial-8.md:114
#, fuzzy
msgid "![Hello World Tutorial 8 dialog, on Windows]{1}"
msgstr "![Hello World 教程 8 对话框，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-8.md:134
#, fuzzy
msgid ""
"Unless you've got a *really* fast internet connection, you may notice that "
"when you press the button, the GUI for your app locks up for a little bit. "
"The operating system may even manifest this with a \"beachball\" or "
"\"spinner\" cursor to indicate that the app is being unresponsive."
msgstr ""
"除非你的网络连接速度非常快，否则你可能会发现，当你按下按钮时，应用程序的图形"
"用户界面会锁定一小会儿。操作系统甚至会用 \"沙滩球 \"或 \"旋转器 \"光标来表示"
"应用程序反应迟钝。"

#: docs/en/tutorial/tutorial-8.md:136
msgid ""
"This is because the web request we have made is *synchronous*. When our "
"application makes the web request, it waits for the API to return a response "
"before continuing. While it's waiting, it *isn't* allowing the application "
"to redraw - and as a result, the application locks up."
msgstr ""
"除非您的网络连接速度*非常*快，否则您可能会注意到，当您按下按钮时，应用程序的"
"图形用户界面会锁定一会儿。这是因为我们发出的网络请求是\\ *同步*\\ 的。当我们"
"的应用程序发出网络请求时，它会等待应用程序接口返回响应，然后再继续。在等待的"
"过程中，应用程序*不*允许重新绘制，结果导致应用程序锁定。"

#: docs/en/tutorial/tutorial-8.md:138
msgid "GUI Event Loops"
msgstr "图形用户界面事件循环"

#: docs/en/tutorial/tutorial-8.md:140
msgid ""
"To understand why this happens, we need to dig into the details of how a GUI "
"application works. The specifics vary depending on the platform; but the "
"high level concepts are the same, no matter the platform or GUI environment "
"you're using."
msgstr ""
"要理解为什么会出现这种情况，我们需要深入了解图形用户界面应用程序的工作原理。"
"具体细节因平台而异，但无论使用何种平台或图形用户界面环境，高层概念都是相同的"
"。"

#: docs/en/tutorial/tutorial-8.md:142
msgid "A GUI app is, fundamentally, a single loop that looks something like:"
msgstr "从根本上说，图形用户界面应用程序就是一个单一的循环，看起来就像:"

#: docs/en/tutorial/tutorial-8.md:150
#, fuzzy
msgid ""
"This loop is called the *Event Loop*. (These aren't actual method names - "
"it's an illustration of what is going on using \"pseudo-code\")."
msgstr "这个循环被称为 *事件循环*。(这些并不是实际的方法名称，而是 \"伪代码 \"的说明"
"）。"

#: docs/en/tutorial/tutorial-8.md:152
#, fuzzy
msgid ""
"When you click on a button, or drag a scroll bar, or type a key, you are "
"generating an \"event\". That \"event\" is put onto a queue, and the app "
"will process the queue of events when it next has the opportunity to do so. "
"The user code that is triggered in response to the event is called an *event "
"handler*. These event handlers are invoked as part of the `process_events()` "
"call."
msgstr ""
"当你点击一个按钮、拖动一个滚动条或输入一个键时，你就产生了一个 \"事件\"。该 "
"\\\"事件 \"被放入一个队列，应用程序将在下一次有机会时处理队列中的事件。为响应"
"事件而触发的用户代码称为*事件处理程序*。这些事件处理程序作为`process_events()"
"`调用的一部分被调用。"

#: docs/en/tutorial/tutorial-8.md:154
msgid ""
"Once an app has processed all the available events, it will `redraw()` the "
"GUI. This takes into account any changes that the events have caused to the "
"display of the app, as well as anything else that is going on in the "
"operating system - for example, the windows of another app may obscure or "
"reveal part of our app's window, and our app's redraw will need to reflect "
"the portion of the window that is currently visible."
msgstr ""
"应用程序处理完所有可用事件后，就会 重绘 （`redraw()`）图形用户界面。这将考虑"
"到事件对应用程序显示所造成的任何变化，以及操作系统中发生的任何其他情况，例如"
"，其他应用程序的窗口可能会遮挡或显示我们应用程序的部分窗口，而我们应用程序的"
"重绘将需要反映当前可见的窗口部分。"

#: docs/en/tutorial/tutorial-8.md:156
#, fuzzy
msgid ""
"The important detail to notice: while an application is processing an event, "
"*it can't redraw*, and *it can't process other events*."
msgstr "需要注意的重要细节是：当应用程序在处理事件时，*不能重绘*，*也不能处理其他事件"
"*。"

#: docs/en/tutorial/tutorial-8.md:158
#, fuzzy
msgid ""
"This means any user logic contained in an event handler needs to complete "
"quickly. Any delay in completing the event handler will be observed by the "
"user as a slowdown (or stop) in GUI updates. If this delay is long enough, "
"your operating system may report this as a problem - the macOS \"beachball\" "
"and Windows \"spinner\" icons are the operating system telling you that your "
"app is taking too long in an event handler."
msgstr ""
"这意味着事件处理程序中包含的任何用户逻辑都需要快速完成。完成事件处理程序的任"
"何延迟都会被用户观察到，表现为图形用户界面更新的减慢（或停止）。如果延迟时间"
"足够长，操作系统可能会将此报告为问题--macOS 的 \"沙滩球 \"和 Windows 的 \"旋"
"转器 \"图标就是操作系统在告诉你，你的应用程序在事件处理程序中耗时过长。"

#: docs/en/tutorial/tutorial-8.md:160
#, fuzzy
msgid ""
"Simple operations like \"update a label\", or "
"\"recompute the total of the inputs\" are easy to complete quickly. However, "
"there are a lot of operations that can't be completed quickly. If you're "
"performing a complex mathematical calculation, or indexing all the files on "
"a file system, or performing a large network request, you can't "
"\"just do it quickly\" - the operations are inherently slow."
msgstr ""
"像 \"更新标签 \"或 \"重新计算输入总和 \"这样的简单操作很容易快速完成。然而，"
"有很多操作是无法快速完成的。如果要执行复杂的数学计算，或为文件系统中的所有文"
"件编制索引，或执行大型网络请求，就不能 \"快速完成\"--这些操作本身就很慢。"

#: docs/en/tutorial/tutorial-8.md:162
#, fuzzy
msgid "So - how do we perform long-lived operations in a GUI application?"
msgstr "那么，我们如何在图形用户界面应用程序中执行长期操作呢？"

#: docs/en/tutorial/tutorial-8.md:164
#, fuzzy
msgid "Asynchronous programming"
msgstr "异步编程"

#: docs/en/tutorial/tutorial-8.md:166
#, fuzzy
msgid ""
"What we need is a way to tell an app in the middle of a long-lived event "
"handler that it is OK to temporarily release control back to the event loop, "
"as long as we can resume where we left off. It's up to the app to determine "
"when this release can occur; but if the app releases control to the event "
"loop regularly, we can have a long-running event handler *and* maintain a "
"responsive UI."
msgstr ""
"我们需要的是一种方法，让处于长期事件处理程序中间的应用程序知道，只要我们能从"
"上次中断的地方继续运行，就可以暂时将控制权释放回事件循环。应用程序可以自行决"
"定何时释放控制权；但如果应用程序定期向事件循环释放控制权，我们就可以拥有一个"
"长期运行的事件处理程序，并**保持响应式用户界面。"

#: docs/en/tutorial/tutorial-8.md:168
#, fuzzy
msgid ""
"We can do this by using *asynchronous programming*. Asynchronous programming "
"is a way to describe a program that allows the interpreter to run multiple "
"functions at the same time, sharing resources between all the concurrently "
"running functions."
msgstr "我们可以通过使用*异步编程*来实现这一点。异步编程是一种描述程序的方法，它允许"
"解释器同时运行多个函数，在所有并发运行的函数之间共享资源。"

#: docs/en/tutorial/tutorial-8.md:170
#, fuzzy
msgid ""
"Asynchronous functions (known as *coroutines*) need to be explicitly "
"declared as being asynchronous. They also need to internally declare when an "
"opportunity exists to change context to another coroutine."
msgstr "异步函数（称为 * 协同例程*）需要明确声明为异步函数。它们还需要在内部声明何时"
"有机会将上下文切换到另一个共同例程。"

#: docs/en/tutorial/tutorial-8.md:172
#, fuzzy
msgid ""
"In Python, asynchronous programming is implemented using the `async` and "
"`await` keywords, and the [asyncio]{1} module in the standard library. The "
"`async` keyword allows us to declare that a function is an asynchronous "
"coroutine. The `await` keyword provides a way to declare when an opportunity "
"exists to change context to another coroutine. The [asyncio]{2} module "
"provides some other useful tools and primitives for asynchronous coding."
msgstr ""
"在 Python 中，异步编程是通过 `async` 和 `await` 关键字以及标准库中的 "
"[asyncio]{1} 模块来实现的。[async` 关键字允许我们声明一个函数是异步协程。关键"
"字 `await` 提供了一种方法来声明何时有机会将上下文切换到另一个协程。[asyncio]"
"{2} 模块为异步编码提供了一些其他有用的工具和原语。"

#: docs/en/tutorial/tutorial-8.md:174
#, fuzzy
msgid "Making the tutorial asynchronous"
msgstr "使教程异步化"

#: docs/en/tutorial/tutorial-8.md:176
#, fuzzy
msgid ""
"To make our tutorial asynchronous, modify the `say_hello()` event handler so "
"it looks like this:"
msgstr "为了使我们的教程成为异步教程，请修改事件处理程序 \"say_hello()\"，使其看起来"
"像这样：："

#: docs/en/tutorial/tutorial-8.md:194
#, fuzzy
msgid ""
"There are only three changes to this callback from the previous version:"
msgstr "与上一版本相比，该代码只有 4 处改动："

#: docs/en/tutorial/tutorial-8.md:196
#, fuzzy
msgid ""
"The client that is created is an asynchronous `AsyncClient()`, rather than a "
"synchronous `Client()`. This tells `httpx` that it should operate in "
"asynchronous mode, rather than synchronous mode."
msgstr ""
"创建的客户端是异步的 `AsyncClient()` 而不是同步的 `Client()[。这就告诉 "
"`httpx` 应在异步模式而非同步模式下运行。"

#: docs/en/tutorial/tutorial-8.md:197
#, fuzzy
msgid ""
"The context manager used to create the client is marked as `async`. This "
"tells Python that there is an opportunity to release control as the context "
"manager is entered and exited."
msgstr "用于创建客户端的上下文管理器被标记为 `async`。这就告诉 Python，当上下文管理器"
"进入和退出时，有机会释放控制。"

#: docs/en/tutorial/tutorial-8.md:198
#, fuzzy
msgid ""
"The `get` call is made with an `await` keyword. This instructs the app that "
"while we are waiting for the response from the network, the app can release "
"control to the event loop. We've seen this keyword before - we also use "
"`await` when displaying the dialog box. The reason for that usage is the "
"same as it is for the HTTP request - we need to tell the app that while the "
"dialog is displayed, and we're waiting for the user to push a button, it's "
"OK to release control back to the event loop."
msgstr ""
"get \"调用带有 \"等待 \"关键字。这指示应用程序在等待网络响应时，可以将控制权"
"释放给事件循环。我们以前见过这个关键字--在显示对话框时我们也使用了`await`。使"
"用该关键字的原因与 HTTP 请求相同--我们需要告诉应用程序，在显示对话框并等待用"
"户按下按钮时，可以将控制权释放回事件循环。"

#: docs/en/tutorial/tutorial-8.md:200
#, fuzzy
msgid ""
"It's also important to note that the handler itself is defined as `async def`"
", rather than just `def`. This tells Python that the method is an "
"asynchronous coroutine. We made this change back in Tutorial 3 when we added "
"the dialog box. You can only use `await` statements inside a method that is "
"declared as `async def`."
msgstr ""
"还需要注意的是，处理程序本身被定义为 `async def`，而不仅仅是 `def`。这告诉 "
"Python 该方法是一个异步的例程。我们在教程 3 中添加对话框时做了这一更改。您只"
"能在声明为 `async def` 的方法中使用 `await` 语句。"

#: docs/en/tutorial/tutorial-8.md:202
#, fuzzy
msgid ""
"Toga allows you to use regular methods or asynchronous coroutines as "
"handlers; Toga manages everything behind the scenes to make sure the handler "
"is invoked or awaited as required."
msgstr "Toga 允许你使用常规方法或异步协程作为处理程序；Toga 在幕后管理一切，确保处理"
"程序按要求被调用或等待。"

#: docs/en/tutorial/tutorial-8.md:204
#, fuzzy
msgid ""
"If you save these changes and re-run the app in development mode, there "
"won't be any obvious changes to the app. However, when you click on the "
"button to trigger the dialog, you may notice a number of subtle improvements:"
msgstr ""
"如果保存这些更改并重新运行应用程序（在开发模式下使用 `briefcase dev` 或更新并"
"重新运行打包的应用程序），应用程序不会有任何明显的变化。不过，当您点击按钮触"
"发对话框时，您可能会注意到一些细微的改进："

#: docs/en/tutorial/tutorial-8.md:206
#, fuzzy
msgid ""
"The button returns to an \"unclicked\" state, rather than being stuck in a "
"\"clicked\" state."
msgstr "按钮会返回到 \"未点击 \"状态，而不是停留在 \"已点击 \"状态。"

#: docs/en/tutorial/tutorial-8.md:207
#, fuzzy
msgid "The \"beachball\"/\"spinner\" icon won't appear."
msgstr "沙滩球\"/\"旋转器 \"图标不会出现。"

#: docs/en/tutorial/tutorial-8.md:208
msgid ""
"If you move/resize the app window while waiting for the dialog to appear, "
"the window will redraw."
msgstr "如果在等待对话框出现时移动或调整应用程序窗口的大小，窗口将重新绘制。"

#: docs/en/tutorial/tutorial-8.md:209
#, fuzzy
msgid "If you try to open an app menu, the menu will appear immediately."
msgstr "如果尝试打开应用程序菜单，菜单会立即出现。"

#: docs/en/tutorial/tutorial-8.md:211
#, fuzzy
msgid ""
"We can now run the full app. However, as we've added an extra requirement "
"(`httpx`) we also need to update our app's requirements; we can do this by "
"passing `-r` to `briefcase run`. This will update our app's requirements, "
"then re-build the app, then launch the app:"
msgstr ""
"现在我们可以运行完整的应用程序了。不过，由于我们添加了一个额外的需求（`httpx`"
"），因此还需要更新应用程序的需求；我们可以通过向 `briefcase run` 传递 `-r` 来"
"做到这一点。这将更新应用程序的需求，然后重新构建应用程序，最后启动应用程序："

#: docs/en/tutorial/tutorial-8.md:253
#, fuzzy
msgid ""
"You should see you app running, and remaining responsive when you press the "
"button and network content is retrieved."
msgstr "当您按下按钮并检索网络内容时，您应该会看到应用程序正在运行并保持响应。"

#: docs/en/tutorial/tutorial-8.md:257
#, fuzzy
msgid ""
"This has been a taste for what you can do with the tools provided by the "
"BeeWare project. Over the course of this tutorial, you have:"
msgstr "通过本教程，您可以了解到 BeeWare 项目提供的工具可以做些什么。在本教程中，您可"
"以"

#: docs/en/tutorial/tutorial-8.md:259
#, fuzzy
msgid "Created a new GUI app project;"
msgstr "创建一个新的图形用户界面应用程序项目；"

#: docs/en/tutorial/tutorial-8.md:260
#, fuzzy
msgid "Run that app in development mode;"
msgstr "在开发者模式下运行应用程序"

#: docs/en/tutorial/tutorial-8.md:261
#, fuzzy
msgid "Built the app as a standalone binary for a desktop operating system;"
msgstr "将应用程序作为桌面操作系统的独立二进制文件构建；"

#: docs/en/tutorial/tutorial-8.md:262
#, fuzzy
msgid "Packaged that project for distribution to others;"
msgstr "将该项目打包分发给其他人；"

#: docs/en/tutorial/tutorial-8.md:263
#, fuzzy
msgid "Run the app on a mobile simulator and/or device;"
msgstr "在移动模拟器和/或设备上运行应用程序；"

#: docs/en/tutorial/tutorial-8.md:264
#, fuzzy
msgid "Run the app as a web app;"
msgstr "将应用程序作为网络应用程序运行；"

#: docs/en/tutorial/tutorial-8.md:265
#, fuzzy
msgid "Added a third-party dependency to your app; and"
msgstr "在应用程序中添加了第三方依赖；以及"

#: docs/en/tutorial/tutorial-8.md:266
#, fuzzy
msgid "Modified the app so that it remains responsive."
msgstr "修改应用程序，使其保持响应速度。"

#: docs/en/tutorial/tutorial-8.md:268
#, fuzzy
msgid "So - where to from here?"
msgstr "那么--何去何从？"

#: docs/en/tutorial/tutorial-8.md:270
#, fuzzy
msgid ""
"If you'd like to go further, there are some additional [topic tutorials]{1} "
"that go into detail on specific aspects of application development."
msgstr "如果你想进一步了解，还有一些额外的 [主题教程]{1}，详细介绍了应用程序开发的具"
"体方面。"

#: docs/en/tutorial/tutorial-8.md:271
#, fuzzy
msgid ""
"If you'd like to know more about how to build complex user interfaces with "
"Toga, you can dive into [Toga's documentation]{1}. Toga also has its own "
"tutorial [demonstrating how to use various features of the widget toolkit]"
"{2}."
msgstr ""
"如果你想进一步了解如何使用 Toga 构建复杂的用户界面，可以查阅 [Toga 文档]{1}。"
"Toga 也有自己的教程[演示如何使用 widget 工具包的各种功能]{2}。"

#: docs/en/tutorial/tutorial-8.md:273
#, fuzzy
msgid ""
"If you'd like to know more about the capabilities of Briefcase, you can dive "
"into [Briefcase's documentation]{1}."
msgstr "如果你想了解更多有关公文包功能的信息，可以查阅[公文包文档]{1}。"

#, fuzzy
#~ msgid "Tutorial 0 - Let's get set up"
#~ msgstr "教程 0 - 让我们开始吧！"

#~ msgid ""
#~ "It **generated an application template**. There's a lot of files and "
#~ "configurations required to build a native installer, above and beyond the "
#~ "code of your actual application. This extra scaffolding is almost the same "
#~ "for every application on the same platform, except for the name of the "
#~ "actual application being constructed - so Briefcase provides an application "
#~ "template for each platform it supports. This step rolls out the template, "
#~ "substituting the name of your application, bundle ID, and other properties "
#~ "of your configuration file as required to support the platform you're "
#~ "building on."
#~ msgstr ""
#~ "它生成了一个应用程序模板。除了实际应用程序的代码之外，构建本机安装程序还需要许多文件和配置。这些额外的脚手架对于同一平台上的每个应用程序几乎都是一样的，除了正在构建的实际应用程序的名称"
#~ "--因此，Briefcase 为其支持的每个平台提供了一个应用程序模板。这一步将推出模板，替换应用程序名称、捆绑 ID "
#~ "和配置文件中的其他属性，以支持正在构建的平台。"

#~ msgid ""
#~ "If you're not happy with the template provided by Briefcase, you can provide"
#~ " your own. However, you probably don't want to do this until you've got a "
#~ "bit more experience using Briefcase's default template."
#~ msgstr ""
#~ "如果您对 Briefcase 提供的模板不满意，可以提供自己的模板。不过，在使用 Briefcase 的默认模板获得更多经验之前，您可能不想这样做。"

#~ msgid ""
#~ "It **downloaded and installed a support package**. The packaging approach "
#~ "taken by Briefcase is best described as \"the simplest thing that could "
#~ "possibly work\" - it ships a complete, isolated Python interpreter as part "
#~ "of every application it builds (except for Linux native system package "
#~ "builds). This is slightly space inefficient - if you have 5 applications "
#~ "packaged with Briefcase, you'll have 5 copies of the Python interpreter. "
#~ "However, this approach guarantees that every application is completely "
#~ "independent, using a specific version of Python that is known to work with "
#~ "the application."
#~ msgstr ""
#~ "它下载并安装了一个支持包。Briefcase 所采用的打包方法被描述为“最简单可行的方法”--它将一个完整、独立的 Python "
#~ "解释器作为其构建的每个应用程序的一部分（除了了、 Linux 上的原生系统包构建）。这种打包方式在空间利用上略显不足--如果有 5 个应用程序使用 "
#~ "Briefcase 打包，那么就会有 5 份 Python "
#~ "解释器副本。但是，这种方法保证了每个应用程序都是完全独立的，使已知的能与应用程序一起工作的特定 Python版本。"

#~ msgid ""
#~ "Again, Briefcase provides a default support package for each platform; if "
#~ "you want, you can provide your own support package, and have that package "
#~ "included as part of the build process. You may want to do this if you have "
#~ "particular options in the Python interpreter that you need to have enabled, "
#~ "or if you want to strip modules out of the standard library that you don't "
#~ "need at runtime."
#~ msgstr ""
#~ "同样，Briefcase 为每个平台提供了默认的支持包；如果需要，您可以提供自己的支持包，并将其作为构建过程的一部分。如果您需要启用 Python "
#~ "解释器中的特定选项，或者如果您想从标准库中剥离运行时不需要的模块，您可能需要这样做。"

#~ msgid ""
#~ "Briefcase maintains a local cache of support packages, so once you've "
#~ "downloaded a specific support package, that cached copy will be used on "
#~ "future builds."
#~ msgstr "Briefcase 维护支持包的本地缓存，因此一旦您下载了特定的支持包，该缓存副本将用于未来的构建。"

#~ msgid ""
#~ "As noted above, when Briefcase packages an app as a native Linux system "
#~ "package (the default package format for Linux), a support package is not "
#~ "included with the app. Instead, the app will use the Python that is provided"
#~ " by the distribution of Linux being targeted."
#~ msgstr ""
#~ "如上所述，当 Briefcase 将一个应用程序打包成 Linux 上的原生系统包（Linux "
#~ "上的默认包格式），应用程序中将不会包含任何的支持包；应用程序将会使用将要被分发到的 Linux 发行版提供的 Python。"

#, fuzzy
#~ msgid "Tutorial 6 - Put it on the web"
#~ msgstr "教程 6 - 把它放上网！"

#~ msgid "**Fedora**"
#~ msgstr "**Fedora**"

#~ msgid "Install Python"
#~ msgstr "安装 Python"

#~ msgid "Install dependencies"
#~ msgstr "安装依赖项"
