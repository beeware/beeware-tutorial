#
msgid ""
msgstr ""
"Project-Id-Version: BeeWare 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-15 03:01+0000\n"
"PO-Revision-Date: 2025-10-15 17:07+0000\n"
"Last-Translator: John <johnzhou721@gmail.com>\n"
"Language-Team: Chinese (Simplified Han script) <https://hosted.weblate.org/projects/beeware/tutorial/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Translate Toolkit 3.16.3\n"

#: docs/en/SUMMARY.md:5
msgid "[Tutorial 0 - Let's get set up!]{1}"
msgstr "[教程 0 - 准备就绪！]{1}"

#: docs/en/SUMMARY.md:6
msgid "[Tutorial 1 - Your first app]{1}"
msgstr "[教程 1 - 您的第一个应用程序]{1}"

#: docs/en/SUMMARY.md:7
msgid "[Tutorial 2 - Making it interesting]{1}"
msgstr "[教程 2 - 使之更有趣]{1}"

#: docs/en/SUMMARY.md:8
msgid "[Tutorial 3 - Packaging for distribution]{1}"
msgstr "[教程 3 - 打包与分发]{1}"

#: docs/en/SUMMARY.md:9
msgid "[Tutorial 4 - Updating your application]{1}"
msgstr "[教程 4 - 更新应用程序]{1}"

#: docs/en/SUMMARY.md:10
msgid "Tutorial 5 - Taking it mobile"
msgstr "教程 5 - 在移动设备上"

#: docs/en/SUMMARY.md:10
msgid "[Tutorial 5 - Taking it mobile]{1}"
msgstr "[教程 5 - 在移动设备上]{1}"

#: docs/en/SUMMARY.md:10
msgid "[Tutorial 5 - Taking it mobile: Android]{1}"
msgstr "[教程 5 - 在移动设备上：Android]{1}"

#: docs/en/SUMMARY.md:10
msgid "[Tutorial 5 - Taking it mobile: iOS]{1}"
msgstr "[教程 5 - 在移动设备上：iOS]{1}"

#: docs/en/SUMMARY.md:14
msgid "[Tutorial 6 - Put it on the web!]{1}"
msgstr "[教程 6 - 把它放上网！]{1}"

#: docs/en/SUMMARY.md:15
msgid "[Tutorial 7 - Get this (third-)party started]{1}"
msgstr "[教程 7 - 使用第三方库]{1}"

#: docs/en/SUMMARY.md:16
msgid "[Tutorial 8 - Making it Smooooth]{1}"
msgstr "[教程 8 - 使其光滑]{1}"

#: docs/en/SUMMARY.md:17 docs/en/tutorial/topics/index.md:1
msgid "Going further"
msgstr "更进一步"

#: docs/en/SUMMARY.md:17
msgid "[Going further]{1}"
msgstr "[进一步]{1}"

#: docs/en/SUMMARY.md:17 docs/en/tutorial/topics/index.md:5
msgid "[Customizing icons]{1}"
msgstr "[自定义图标]{1}"

#: docs/en/SUMMARY.md:17 docs/en/tutorial/topics/index.md:9
msgid "[Using the camera]{1}"
msgstr "[使用相机]{1}"

#: docs/en/SUMMARY.md:17 docs/en/tutorial/topics/index.md:13
msgid "[Testing times]{1}"
msgstr "[测试时间]{1}"

#: docs/en/SUMMARY.md:22
msgid "How-to guides"
msgstr "如何...？"

#: docs/en/SUMMARY.md:22
msgid "[Contributing to this tutorial]{1}"
msgstr "[为本教程做出贡献]{1}"

#: docs/en/SUMMARY.md:22
msgid "[Style guide]{1}"
msgstr "[风格指南]{1}"

#: docs/en/how-to/contribute.md:1
msgid "Contributing to this tutorial"
msgstr "为本教程做出贡献"

#: docs/en/how-to/contribute.md:3
msgid ""
"This tutorial is written using [MkDocs and Markdown]{1}. This guide will "
"help you contribute fixes or new content to this tutorial."
msgstr "本教程使用 [MkDocs 和 Markdown]{1} 编写。本指南将帮助您为本教程贡献修复或者新内容。"

#: docs/en/how-to/contribute.md:5
msgid ""
"Translations of this tutorial are managed using [Weblate]{1}. If you'd like "
"to contribute to the translation effort, join the `#translations` channel on"
" [Discord]{2} and introduce yourself!"
msgstr ""
"本教程使用 [Weblate]{1} 进行翻译管理。如果您想参与翻译工作，请加入 [Discord]{2} 上的 `#translations` "
"频道并介绍自己！"

#: docs/en/how-to/contribute.md:7
msgid "Set up your development environment"
msgstr "设置开发环境"

#: docs/en/how-to/contribute.md:9
msgid ""
"To build the BeeWare tutorial you **must** have a Python 3.12 interpreter "
"installed and available on your path (i.e., `python3` must start a Python "
"3.12 interpreter)."
msgstr ""
"要编译 BeeWare 教程，path 上**必须**安装有 Python 3.12 解释器（即 `python3` 必须启动 Python 3.12 "
"解释器）。"

#: docs/en/how-to/contribute.md:11 docs/en/how-to/contribute.md:42
#: docs/en/how-to/contribute.md:77 docs/en/how-to/contribute.md:117
#: docs/en/how-to/contribute.md:148 docs/en/how-to/contribute.md:177
#: docs/en/how-to/contribute.md:239 docs/en/how-to/contribute.md:293
#: docs/en/how-to/contribute.md:323 docs/en/how-to/contribute.md:353
#: docs/en/how-to/contribute.md:396 docs/en/how-to/contribute.md:426
#: docs/en/how-to/contribute.md:456 docs/en/how-to/contribute.md:502
#: docs/en/tutorial/topics/camera-access.md:115
#: docs/en/tutorial/topics/custom-icons.md:29
#: docs/en/tutorial/topics/custom-icons.md:196
#: docs/en/tutorial/topics/custom-icons.md:377
#: docs/en/tutorial/topics/testing.md:19
#: docs/en/tutorial/topics/testing.md:124
#: docs/en/tutorial/topics/testing.md:196
#: docs/en/tutorial/topics/testing.md:315
#: docs/en/tutorial/topics/testing.md:381 docs/en/tutorial/tutorial-0.md:9
#: docs/en/tutorial/tutorial-0.md:53 docs/en/tutorial/tutorial-0.md:106
#: docs/en/tutorial/tutorial-1.md:9 docs/en/tutorial/tutorial-1.md:49
#: docs/en/tutorial/tutorial-1.md:118 docs/en/tutorial/tutorial-1.md:165
#: docs/en/tutorial/tutorial-2.md:230 docs/en/tutorial/tutorial-2.md:267
#: docs/en/tutorial/tutorial-3.md:13 docs/en/tutorial/tutorial-3.md:132
#: docs/en/tutorial/tutorial-3.md:202 docs/en/tutorial/tutorial-3.md:289
#: docs/en/tutorial/tutorial-4.md:29 docs/en/tutorial/tutorial-4.md:65
#: docs/en/tutorial/tutorial-4.md:160
#: docs/en/tutorial/tutorial-5/android.md:11
#: docs/en/tutorial/tutorial-5/android.md:104
#: docs/en/tutorial/tutorial-5/android.md:176
#: docs/en/tutorial/tutorial-5/android.md:285
#: docs/en/tutorial/tutorial-6.md:17 docs/en/tutorial/tutorial-7.md:34
#: docs/en/tutorial/tutorial-7.md:114 docs/en/tutorial/tutorial-7.md:183
#: docs/en/tutorial/tutorial-7.md:490 docs/en/tutorial/tutorial-8.md:59
#: docs/en/tutorial/tutorial-8.md:213
msgid "/// tab | macOS"
msgstr "/// tab | macOS"

#: docs/en/how-to/contribute.md:18 docs/en/how-to/contribute.md:27
#: docs/en/how-to/contribute.md:36 docs/en/how-to/contribute.md:49
#: docs/en/how-to/contribute.md:58 docs/en/how-to/contribute.md:67
#: docs/en/how-to/contribute.md:87 docs/en/how-to/contribute.md:99
#: docs/en/how-to/contribute.md:111 docs/en/how-to/contribute.md:124
#: docs/en/how-to/contribute.md:133 docs/en/how-to/contribute.md:142
#: docs/en/how-to/contribute.md:155 docs/en/how-to/contribute.md:164
#: docs/en/how-to/contribute.md:173 docs/en/how-to/contribute.md:195
#: docs/en/how-to/contribute.md:215 docs/en/how-to/contribute.md:235
#: docs/en/how-to/contribute.md:253 docs/en/how-to/contribute.md:269
#: docs/en/how-to/contribute.md:283 docs/en/how-to/contribute.md:299
#: docs/en/how-to/contribute.md:307 docs/en/how-to/contribute.md:315
#: docs/en/how-to/contribute.md:329 docs/en/how-to/contribute.md:337
#: docs/en/how-to/contribute.md:345 docs/en/how-to/contribute.md:359
#: docs/en/how-to/contribute.md:367 docs/en/how-to/contribute.md:375
#: docs/en/how-to/contribute.md:402 docs/en/how-to/contribute.md:410
#: docs/en/how-to/contribute.md:418 docs/en/how-to/contribute.md:432
#: docs/en/how-to/contribute.md:440 docs/en/how-to/contribute.md:448
#: docs/en/how-to/contribute.md:462 docs/en/how-to/contribute.md:470
#: docs/en/how-to/contribute.md:478 docs/en/how-to/contribute.md:508
#: docs/en/how-to/contribute.md:516 docs/en/how-to/contribute.md:524
#: docs/en/index.md:13 docs/en/index.md:25 docs/en/index.md:37
#: docs/en/tutorial/topics/camera-access.md:15
#: docs/en/tutorial/topics/camera-access.md:123
#: docs/en/tutorial/topics/camera-access.md:133
#: docs/en/tutorial/topics/custom-icons.md:13
#: docs/en/tutorial/topics/custom-icons.md:46
#: docs/en/tutorial/topics/custom-icons.md:70
#: docs/en/tutorial/topics/custom-icons.md:89
#: docs/en/tutorial/topics/custom-icons.md:127
#: docs/en/tutorial/topics/custom-icons.md:161
#: docs/en/tutorial/topics/custom-icons.md:190
#: docs/en/tutorial/topics/custom-icons.md:220
#: docs/en/tutorial/topics/custom-icons.md:252
#: docs/en/tutorial/topics/custom-icons.md:279
#: docs/en/tutorial/topics/custom-icons.md:323
#: docs/en/tutorial/topics/custom-icons.md:325
#: docs/en/tutorial/topics/custom-icons.md:361
#: docs/en/tutorial/topics/custom-icons.md:367
#: docs/en/tutorial/topics/custom-icons.md:392
#: docs/en/tutorial/topics/custom-icons.md:409
#: docs/en/tutorial/topics/custom-icons.md:426
#: docs/en/tutorial/topics/custom-icons.md:442
#: docs/en/tutorial/topics/custom-icons.md:458
#: docs/en/tutorial/topics/custom-icons.md:472
#: docs/en/tutorial/topics/testing.md:42 docs/en/tutorial/topics/testing.md:70
#: docs/en/tutorial/topics/testing.md:98
#: docs/en/tutorial/topics/testing.md:141
#: docs/en/tutorial/topics/testing.md:160
#: docs/en/tutorial/topics/testing.md:179
#: docs/en/tutorial/topics/testing.md:228
#: docs/en/tutorial/topics/testing.md:264
#: docs/en/tutorial/topics/testing.md:298
#: docs/en/tutorial/topics/testing.md:333
#: docs/en/tutorial/topics/testing.md:353
#: docs/en/tutorial/topics/testing.md:373
#: docs/en/tutorial/topics/testing.md:423
#: docs/en/tutorial/topics/testing.md:457
#: docs/en/tutorial/topics/testing.md:496 docs/en/tutorial/tutorial-0.md:25
#: docs/en/tutorial/tutorial-0.md:37 docs/en/tutorial/tutorial-0.md:47
#: docs/en/tutorial/tutorial-0.md:59 docs/en/tutorial/tutorial-0.md:90
#: docs/en/tutorial/tutorial-0.md:100 docs/en/tutorial/tutorial-0.md:115
#: docs/en/tutorial/tutorial-0.md:126 docs/en/tutorial/tutorial-0.md:155
#: docs/en/tutorial/tutorial-0.md:157 docs/en/tutorial/tutorial-0.md:165
#: docs/en/tutorial/tutorial-1.md:15 docs/en/tutorial/tutorial-1.md:27
#: docs/en/tutorial/tutorial-1.md:29 docs/en/tutorial/tutorial-1.md:41
#: docs/en/tutorial/tutorial-1.md:43 docs/en/tutorial/tutorial-1.md:55
#: docs/en/tutorial/tutorial-1.md:63 docs/en/tutorial/tutorial-1.md:71
#: docs/en/tutorial/tutorial-1.md:131 docs/en/tutorial/tutorial-1.md:146
#: docs/en/tutorial/tutorial-1.md:161 docs/en/tutorial/tutorial-1.md:171
#: docs/en/tutorial/tutorial-1.md:173 docs/en/tutorial/tutorial-1.md:181
#: docs/en/tutorial/tutorial-1.md:183 docs/en/tutorial/tutorial-1.md:191
#: docs/en/tutorial/tutorial-1.md:207 docs/en/tutorial/tutorial-1.md:209
#: docs/en/tutorial/tutorial-2.md:83 docs/en/tutorial/tutorial-2.md:111
#: docs/en/tutorial/tutorial-2.md:166 docs/en/tutorial/tutorial-2.md:239
#: docs/en/tutorial/tutorial-2.md:250 docs/en/tutorial/tutorial-2.md:261
#: docs/en/tutorial/tutorial-2.md:273 docs/en/tutorial/tutorial-2.md:275
#: docs/en/tutorial/tutorial-2.md:283 docs/en/tutorial/tutorial-2.md:285
#: docs/en/tutorial/tutorial-2.md:293 docs/en/tutorial/tutorial-2.md:295
#: docs/en/tutorial/tutorial-3.md:40 docs/en/tutorial/tutorial-3.md:84
#: docs/en/tutorial/tutorial-3.md:86 docs/en/tutorial/tutorial-3.md:112
#: docs/en/tutorial/tutorial-3.md:147 docs/en/tutorial/tutorial-3.md:177
#: docs/en/tutorial/tutorial-3.md:194 docs/en/tutorial/tutorial-3.md:196
#: docs/en/tutorial/tutorial-3.md:225 docs/en/tutorial/tutorial-3.md:253
#: docs/en/tutorial/tutorial-3.md:277 docs/en/tutorial/tutorial-3.md:326
#: docs/en/tutorial/tutorial-3.md:423 docs/en/tutorial/tutorial-3.md:461
#: docs/en/tutorial/tutorial-4.md:35 docs/en/tutorial/tutorial-4.md:37
#: docs/en/tutorial/tutorial-4.md:45 docs/en/tutorial/tutorial-4.md:47
#: docs/en/tutorial/tutorial-4.md:55 docs/en/tutorial/tutorial-4.md:57
#: docs/en/tutorial/tutorial-4.md:79 docs/en/tutorial/tutorial-4.md:102
#: docs/en/tutorial/tutorial-4.md:118 docs/en/tutorial/tutorial-4.md:128
#: docs/en/tutorial/tutorial-4.md:181 docs/en/tutorial/tutorial-4.md:210
#: docs/en/tutorial/tutorial-4.md:228
#: docs/en/tutorial/tutorial-5/android.md:38
#: docs/en/tutorial/tutorial-5/android.md:67
#: docs/en/tutorial/tutorial-5/android.md:96
#: docs/en/tutorial/tutorial-5/android.md:122
#: docs/en/tutorial/tutorial-5/android.md:142
#: docs/en/tutorial/tutorial-5/android.md:162
#: docs/en/tutorial/tutorial-5/android.md:168
#: docs/en/tutorial/tutorial-5/android.md:188
#: docs/en/tutorial/tutorial-5/android.md:202
#: docs/en/tutorial/tutorial-5/android.md:216
#: docs/en/tutorial/tutorial-5/android.md:228
#: docs/en/tutorial/tutorial-5/android.md:238
#: docs/en/tutorial/tutorial-5/android.md:248
#: docs/en/tutorial/tutorial-5/android.md:254
#: docs/en/tutorial/tutorial-5/android.md:264
#: docs/en/tutorial/tutorial-5/android.md:299
#: docs/en/tutorial/tutorial-5/android.md:315
#: docs/en/tutorial/tutorial-5/android.md:331
#: docs/en/tutorial/tutorial-5/android.md:341
#: docs/en/tutorial/tutorial-5/iOS.md:101 docs/en/tutorial/tutorial-6.md:11
#: docs/en/tutorial/tutorial-6.md:55 docs/en/tutorial/tutorial-6.md:95
#: docs/en/tutorial/tutorial-6.md:135 docs/en/tutorial/tutorial-7.md:54
#: docs/en/tutorial/tutorial-7.md:76 docs/en/tutorial/tutorial-7.md:98
#: docs/en/tutorial/tutorial-7.md:104 docs/en/tutorial/tutorial-7.md:110
#: docs/en/tutorial/tutorial-7.md:127 docs/en/tutorial/tutorial-7.md:129
#: docs/en/tutorial/tutorial-7.md:144 docs/en/tutorial/tutorial-7.md:146
#: docs/en/tutorial/tutorial-7.md:161 docs/en/tutorial/tutorial-7.md:163
#: docs/en/tutorial/tutorial-7.md:169 docs/en/tutorial/tutorial-7.md:175
#: docs/en/tutorial/tutorial-7.md:220 docs/en/tutorial/tutorial-7.md:222
#: docs/en/tutorial/tutorial-7.md:277 docs/en/tutorial/tutorial-7.md:316
#: docs/en/tutorial/tutorial-7.md:318 docs/en/tutorial/tutorial-7.md:393
#: docs/en/tutorial/tutorial-7.md:441 docs/en/tutorial/tutorial-7.md:511
#: docs/en/tutorial/tutorial-7.md:540 docs/en/tutorial/tutorial-7.md:563
#: docs/en/tutorial/tutorial-7.md:582 docs/en/tutorial/tutorial-7.md:606
#: docs/en/tutorial/tutorial-7.md:614 docs/en/tutorial/tutorial-8.md:76
#: docs/en/tutorial/tutorial-8.md:78 docs/en/tutorial/tutorial-8.md:97
#: docs/en/tutorial/tutorial-8.md:99 docs/en/tutorial/tutorial-8.md:118
#: docs/en/tutorial/tutorial-8.md:120 docs/en/tutorial/tutorial-8.md:126
#: docs/en/tutorial/tutorial-8.md:132 docs/en/tutorial/tutorial-8.md:219
#: docs/en/tutorial/tutorial-8.md:227 docs/en/tutorial/tutorial-8.md:235
#: docs/en/tutorial/tutorial-8.md:243 docs/en/tutorial/tutorial-8.md:251
msgid "///"
msgstr "///"

#: docs/en/how-to/contribute.md:20 docs/en/how-to/contribute.md:51
#: docs/en/how-to/contribute.md:89 docs/en/how-to/contribute.md:126
#: docs/en/how-to/contribute.md:157 docs/en/how-to/contribute.md:197
#: docs/en/how-to/contribute.md:255 docs/en/how-to/contribute.md:301
#: docs/en/how-to/contribute.md:331 docs/en/how-to/contribute.md:361
#: docs/en/how-to/contribute.md:404 docs/en/how-to/contribute.md:434
#: docs/en/how-to/contribute.md:464 docs/en/how-to/contribute.md:510
#: docs/en/tutorial/topics/custom-icons.md:48
#: docs/en/tutorial/topics/custom-icons.md:222
#: docs/en/tutorial/topics/custom-icons.md:394
#: docs/en/tutorial/topics/testing.md:44
#: docs/en/tutorial/topics/testing.md:143
#: docs/en/tutorial/topics/testing.md:230
#: docs/en/tutorial/topics/testing.md:335
#: docs/en/tutorial/topics/testing.md:425 docs/en/tutorial/tutorial-0.md:27
#: docs/en/tutorial/tutorial-0.md:61 docs/en/tutorial/tutorial-0.md:117
#: docs/en/tutorial/tutorial-1.md:17 docs/en/tutorial/tutorial-1.md:57
#: docs/en/tutorial/tutorial-1.md:133 docs/en/tutorial/tutorial-1.md:175
#: docs/en/tutorial/tutorial-2.md:241 docs/en/tutorial/tutorial-2.md:277
#: docs/en/tutorial/tutorial-3.md:42 docs/en/tutorial/tutorial-3.md:149
#: docs/en/tutorial/tutorial-3.md:227 docs/en/tutorial/tutorial-3.md:328
#: docs/en/tutorial/tutorial-4.md:39 docs/en/tutorial/tutorial-4.md:81
#: docs/en/tutorial/tutorial-4.md:183
#: docs/en/tutorial/tutorial-5/android.md:40
#: docs/en/tutorial/tutorial-5/android.md:124
#: docs/en/tutorial/tutorial-5/android.md:190
#: docs/en/tutorial/tutorial-5/android.md:301
#: docs/en/tutorial/tutorial-6.md:57 docs/en/tutorial/tutorial-7.md:56
#: docs/en/tutorial/tutorial-7.md:131 docs/en/tutorial/tutorial-7.md:224
#: docs/en/tutorial/tutorial-7.md:513 docs/en/tutorial/tutorial-8.md:80
#: docs/en/tutorial/tutorial-8.md:221
msgid "/// tab | Linux"
msgstr "/// tab | Linux"

#: docs/en/how-to/contribute.md:29 docs/en/how-to/contribute.md:60
#: docs/en/how-to/contribute.md:101 docs/en/how-to/contribute.md:135
#: docs/en/how-to/contribute.md:166 docs/en/how-to/contribute.md:217
#: docs/en/how-to/contribute.md:271 docs/en/how-to/contribute.md:309
#: docs/en/how-to/contribute.md:339 docs/en/how-to/contribute.md:369
#: docs/en/how-to/contribute.md:412 docs/en/how-to/contribute.md:442
#: docs/en/how-to/contribute.md:472 docs/en/how-to/contribute.md:518
#: docs/en/tutorial/topics/custom-icons.md:72
#: docs/en/tutorial/topics/custom-icons.md:254
#: docs/en/tutorial/topics/custom-icons.md:411
#: docs/en/tutorial/topics/testing.md:72
#: docs/en/tutorial/topics/testing.md:162
#: docs/en/tutorial/topics/testing.md:266
#: docs/en/tutorial/topics/testing.md:355
#: docs/en/tutorial/topics/testing.md:459 docs/en/tutorial/tutorial-0.md:39
#: docs/en/tutorial/tutorial-0.md:92 docs/en/tutorial/tutorial-0.md:128
#: docs/en/tutorial/tutorial-1.md:31 docs/en/tutorial/tutorial-1.md:65
#: docs/en/tutorial/tutorial-1.md:148 docs/en/tutorial/tutorial-1.md:185
#: docs/en/tutorial/tutorial-2.md:252 docs/en/tutorial/tutorial-2.md:287
#: docs/en/tutorial/tutorial-3.md:88 docs/en/tutorial/tutorial-3.md:179
#: docs/en/tutorial/tutorial-3.md:255 docs/en/tutorial/tutorial-3.md:425
#: docs/en/tutorial/tutorial-4.md:49 docs/en/tutorial/tutorial-4.md:104
#: docs/en/tutorial/tutorial-4.md:212
#: docs/en/tutorial/tutorial-5/android.md:69
#: docs/en/tutorial/tutorial-5/android.md:144
#: docs/en/tutorial/tutorial-5/android.md:204
#: docs/en/tutorial/tutorial-5/android.md:317
#: docs/en/tutorial/tutorial-6.md:97 docs/en/tutorial/tutorial-7.md:78
#: docs/en/tutorial/tutorial-7.md:148 docs/en/tutorial/tutorial-7.md:279
#: docs/en/tutorial/tutorial-7.md:542 docs/en/tutorial/tutorial-8.md:101
#: docs/en/tutorial/tutorial-8.md:229
msgid "/// tab | Windows"
msgstr "/// tab | Windows"

#: docs/en/how-to/contribute.md:38
msgid "Create a virtual environment"
msgstr "建立虚拟环境"

#: docs/en/how-to/contribute.md:40
msgid ""
"The recommended way of setting up your development environment for BeeWare "
"is to install a virtual environment, install the required dependencies and "
"start coding. To set up a virtual environment, run:"
msgstr "设置 BeeWare 开发环境的推荐方法是安装虚拟环境、安装所需的依赖项并开始写代码。要设置虚拟环境，请运行："

#: docs/en/how-to/contribute.md:69
msgid "Your prompt should now have a `(.venv)` prefix in front of it."
msgstr "现在，你的提示符前面应该会有 `(.venv)` 前缀。"

#: docs/en/how-to/contribute.md:71
msgid "Clone the BeeWare Tutorial repository"
msgstr "克隆 BeeWare 教程仓库"

#: docs/en/how-to/contribute.md:73
msgid "For updates to BeeWare documentation:"
msgstr "有关 BeeWare 文档的更新："

#: docs/en/how-to/contribute.md:75
#, fuzzy
msgid ""
"Next, go to [the BeeWare Tutorial page on GitHub]{1}, fork the repository "
"into your own account, and then clone a copy of that repository onto your "
"computer by clicking on \"Code\". If you have the GitHub desktop application"
" installed on your computer, you can select \"Open in Desktop\"; otherwise, "
"copy the URL provided, and use it to clone using the command line:"
msgstr ""
"接下来，请访问[GitHub上的BeeWare教程页面]{1}，将该版本库fork到自己的账户中，然后点击 "
"\"代码\"（Code），将该版本库的副本克隆到自己的电脑上。如果电脑上安装了 GitHub 桌面程序，可以选择 "
"\"在桌面打开\"；否则，请复制所提供的 URL，并使用命令行克隆："

#: docs/en/how-to/contribute.md:79 docs/en/how-to/contribute.md:91
#: docs/en/how-to/contribute.md:103
msgid "Fork the BeeWare Tutorial repository, and then:"
msgstr "Fork BeeWare Tutorial 仓库，然后："

#: docs/en/how-to/contribute.md:85 docs/en/how-to/contribute.md:97
#: docs/en/how-to/contribute.md:109
msgid "(substituting your GitHub username)"
msgstr "(用您的 GitHub 用户名代替）"

#: docs/en/how-to/contribute.md:113
msgid "Install BeeWare tutorial docs dependencies"
msgstr "安装 BeeWare 教程文档依赖项"

#: docs/en/how-to/contribute.md:115
msgid ""
"Now that you have the source code, you can install BeeWare docs requirements"
" into your development environment. Since we're installing from source, we "
"can't rely on pip to resolve the dependencies to source packages, so we have"
" to manually install each package:"
msgstr ""
"有了源代码，就可以在开发环境中安装 BeeWare 文档依赖项了。由于我们是从源代码安装，因此不能依靠 pip "
"来解析源代码包的依赖关系，所以我们必须手动安装每个软件包："

#: docs/en/how-to/contribute.md:144
msgid "Install pre-commit"
msgstr "安装 pre-commit"

#: docs/en/how-to/contribute.md:146
msgid ""
"BeeWare uses a tool called [Pre-Commit]{1} to identify simple issues and "
"standardize code formatting. It does this by installing a git hook that "
"automatically runs a series of code linters prior to finalizing any git "
"commit. To enable pre-commit, run:"
msgstr ""
"BeeWare 使用一个名为 [Pre-Commit]{1} 的工具来识别简单问题并规范代码格式。它通过安装一个 git 钩子，在完成任何 git "
"commit 之前自动运行一系列 linters。要启用 pre-commit，请运行："

#: docs/en/how-to/contribute.md:175
msgid ""
"When you commit any change, pre-commit will run automatically. If there are "
"any issues found with the commit, this will cause your commit to fail. Where"
" possible, pre-commit will make the changes needed to correct the problems "
"it has found:"
msgstr ""
"提交任何更改时，pre-commit 会自动运行。如果在提交过程中发现任何问题，都会导致提交失败。在可能的情况下，pre-commit "
"会对发现的问题进行必要的修改："

#: docs/en/how-to/contribute.md:237
msgid ""
"You can then re-add any files that were modified as a result of the pre-"
"commit checks, and re-commit the change."
msgstr "然后，你可以重新添加任何被 pre-commit 修改的文件，并重新 commit 更改。"

#: docs/en/how-to/contribute.md:285
msgid "Now you are ready to start hacking on BeeWare docs!"
msgstr "现在，您已经准备好为 BeeWare 做贡献了！"

#: docs/en/how-to/contribute.md:287
msgid "Building the BeeWare Tutorial"
msgstr "编译 BeeWare 教程"

#: docs/en/how-to/contribute.md:289
msgid "Build the Tutorial locally"
msgstr "在本地构建教程"

#: docs/en/how-to/contribute.md:291
msgid "Once your development environment is set up, run:"
msgstr "设置好开发环境后，运行："

#: docs/en/how-to/contribute.md:317
msgid ""
"The output of the file should be in the `_build/html` folder. If there are "
"any markup problems, they'll raise an error."
msgstr "该文件的输出应位于 `_build/html` 文件夹中。如果出现任何标记语法问题，它将会引发错误。"

#: docs/en/how-to/contribute.md:319
msgid "Live Tutorial preview"
msgstr "实时教程预览"

#: docs/en/how-to/contribute.md:321
msgid ""
"To support rapid editing of documentation, BeeWare also has a \"live "
"preview\" mode:"
msgstr "为了支持文档的快速编辑，BeeWare 还提供了“实时预览”模式："

#: docs/en/how-to/contribute.md:347
msgid ""
"This will build the documentation, start a web server to serve the build "
"documentation, and watch the file system for any changes to the "
"documentation source. If a change is detected, the documentation will be "
"rebuilt, and any browser viewing the modified page will be automatically "
"refreshed."
msgstr ""
"这将构建文档，启动网络服务器以提供构建文档，并监视是否对文档源进行了任何更改。如果检测到了更改，它将重建文档，并自动刷新查看修改过的页面的任何浏览器。"

#: docs/en/how-to/contribute.md:349
msgid "Tutorial linting"
msgstr "教程 lint"

#: docs/en/how-to/contribute.md:351
msgid ""
"The build process will identify most Markdown problems, but BeeWare performs"
" some additional \"lint\" checks. To run the lint checks:"
msgstr "构建过程会识别出大多数 Markdown 问题，但 BeeWare 还会执行一些额外的 \"lint\" 检查。要运行 \"lint\" 检查："

#: docs/en/how-to/contribute.md:377
msgid "This will validate the documentation does not contain:"
msgstr "这将验证文档不包含："

#: docs/en/how-to/contribute.md:379
msgid "dead hyperlinks"
msgstr "死超链接"

#: docs/en/how-to/contribute.md:380
msgid "misspelled words"
msgstr "错别字"

#: docs/en/how-to/contribute.md:382
#, fuzzy
msgid ""
"If a valid spelling of a word is identified as misspelled, then add the word"
" to the list in `docs/spelling_wordlist`. This will add the word to the "
"spellchecker's dictionary. When adding to this list, remember:"
msgstr ""
"如果一个单词的有效拼写被识别为拼写错误，则将该单词添加到 `docs/spelling_wordlist` "
"中的列表中。这将把该词添加到拼写检查程序的词典中。添加到该列表时，请记住"

#: docs/en/how-to/contribute.md:384
msgid ""
"We prefer US spelling, with some liberties for programming-specific "
"colloquialisms (e.g., \"apps\") and verbing of nouns (e.g., \"scrollable\")"
msgstr "我们倾向于使用美式拼写法，但对程序特定的口语（如 “apps”）和名词的动词化（如 “scrollable”）有一定的自由度"

#: docs/en/how-to/contribute.md:385
msgid ""
"Any reference to a product name should use the product's preferred "
"capitalization. (e.g., \"macOS\", \"GTK\", \"pytest\", \"Pygame\", "
"\"PyScript\")."
msgstr ""
"任何对产品名称的引用都应使用该产品的首选大小写。(例如，“macOS”、“GTK”、“pytest”、“Pygame”、“PyScript”）。"

#: docs/en/how-to/contribute.md:386
msgid ""
"If a term is being used \"as code\", then it should be quoted as inline code"
" rather than being added to the dictionary."
msgstr "如果一个术语是作为代码使用的，那么它应该作为内嵌代码被引用，而不是被添加到词典中。"

#: docs/en/how-to/contribute.md:388
msgid "Translations"
msgstr "翻译"

#: docs/en/how-to/contribute.md:390
#, fuzzy
msgid ""
"The BeeWare tutorial is available in multiple languages, which you can build"
" individually or all at the same time."
msgstr "BeeWare 教程有多种语言版本，您可以单独或同时构建所有语言版本。"

#: docs/en/how-to/contribute.md:392
msgid "Updating translations"
msgstr "更新翻译文件"

#: docs/en/how-to/contribute.md:394
#, fuzzy
msgid ""
"If you have made changes to the English content, the first step to building "
"the translations is to update the translation files. To update the "
"translations:"
msgstr "如果您对英文内容进行了更改，那么构建翻译的第一步就是更新翻译文件。更新翻译文件"

#: docs/en/how-to/contribute.md:420
#, fuzzy
msgid "This will update the"
msgstr "这将更新"

#: docs/en/how-to/contribute.md:422
#, fuzzy
msgid "Building translations"
msgstr "建筑翻译"

#: docs/en/how-to/contribute.md:424
#, fuzzy
msgid ""
"To build a single translation, you run the `docs` command with the language "
"code for the translation you wish to build. For example, to build French:"
msgstr "要编译单个译文，请运行 `docs` 命令，并输入要编译的译文的语言代码。例如，要编译法语："

#: docs/en/how-to/contribute.md:450
#, fuzzy
msgid ""
"The French translation should be built in the `_build/html` folder. If there"
" are any markup problems, they'll raise an error."
msgstr "法文翻译应建在 `_build/html` 文件夹中。如果出现任何标记问题，都会引发错误。"

#: docs/en/how-to/contribute.md:452
#, fuzzy
msgid ""
"An error is also raised if you enter a language code for an unavailable "
"language. If this happens, verify that you are using the proper language "
"code."
msgstr "如果输入了不可用语言的语言代码，也会出现错误。如果出现这种情况，请确认您使用的是正确的语言代码。"

#: docs/en/how-to/contribute.md:454
#, fuzzy
msgid "To build all the translations at the same time:"
msgstr "同时构建所有翻译："

#: docs/en/how-to/contribute.md:480
#, fuzzy
msgid ""
"This will build all available translations in the `_build/html` directory, "
"inside a language-specific subdirectory. For example, the French translation"
" would be available in `_build/html/fr`."
msgstr "这将在 `_build/html`目录下的特定语言子目录内构建所有可用的翻译。例如，法语翻译将放在 `_build/html/fr`。"

#: docs/en/how-to/contribute.md:482
#, fuzzy
msgid "What to work on?"
msgstr "要做什么？"

#: docs/en/how-to/contribute.md:484
#, fuzzy
msgid ""
"If you're looking for specific areas to improve, there are [tickets tagged "
"\"documentation\"]{1} in BeeWare's issue tracker."
msgstr "如果您正在寻找需要改进的具体方面，BeeWare 的问题跟踪器中有[标记为 \"文档 \"的票据]{1}。"

#: docs/en/how-to/contribute.md:486
#, fuzzy
msgid ""
"However, you don't need to be constrained by these tickets. If you can "
"identify an error in the tutorial, or an improvement that can be made, start"
" writing! Anything that improves the experience of the end user is a welcome"
" change."
msgstr "不过，您不必拘泥于这些罚单。如果您能发现教程中的错误或可以改进的地方，请开始撰写！任何能改善最终用户体验的改变都是值得欢迎的。"

#: docs/en/how-to/contribute.md:488
#, fuzzy
msgid "Submitting a pull request"
msgstr "提交拉取请求"

#: docs/en/how-to/contribute.md:490
#, fuzzy
msgid ""
"Before you submit a pull request, there's a few bits of housekeeping to do."
msgstr "在提交拉取请求之前，您需要做一些内务整理。"

#: docs/en/how-to/contribute.md:492
#, fuzzy
msgid "Submit from a feature branch, not your `main` branch"
msgstr "从特性分支提交，而不是从 \"主 \"分支提交"

#: docs/en/how-to/contribute.md:494
#, fuzzy
msgid ""
"Before you start working on your change, make sure you've created a branch. "
"By default, when you clone your repository fork, you'll be checked out on "
"your `main` branch. This is a direct copy of BeeWare's `main` branch. To "
"contribute to BeeWare itself, not the docs, please review the repo README."
msgstr ""
"在你开始修改之前，请确保你已经创建了一个分支。默认情况下，当您克隆您的分叉仓库时，您将在 \"主 \"分支上签出。这是BeeWare \"主 "
"\"分支的直接拷贝。如需对BeeWare本身（而非文档）做出贡献，请查看版本库的README。"

#: docs/en/how-to/contribute.md:496
#, fuzzy
msgid ""
"While you *can* submit a pull request from your `main` branch, it's "
"preferable if you *don't* do this. If you submit a pull request that is "
"*almost* right, the core team member who reviews your pull request may be "
"able to make the necessary changes, rather than giving feedback asking for a"
" minor change. However, if you submit your pull request from your `main` "
"branch, reviewers are prevented from making modifications."
msgstr ""
"虽然您*可以*从您的 \"主 "
"\"分支提交拉取请求，但最好不要*这样做。如果您提交的拉取请求*几乎*正确，那么审查您的拉取请求的核心团队成员可能会做出必要的修改，而不是给出反馈，要求您做细微的改动。但是，如果你从你的"
" \"主 \"分支提交拉取请求，审查人员就无法进行修改。"

#: docs/en/how-to/contribute.md:498
#, fuzzy
msgid ""
"Instead, you should make your changes on a *feature branch*. A feature "
"branch has a simple name to identify the change that you've made."
msgstr "相反，你应该在*特性分支*上进行修改。特性分支有一个简单的名称，用来标识你所做的改动。"

#: docs/en/how-to/contribute.md:500
#, fuzzy
msgid "To create a feature branch, run:"
msgstr "要创建功能分支，请运行"

#: docs/en/how-to/contribute.md:526
#, fuzzy
msgid ""
"Commit your changes to this branch, then push to GitHub and create a pull "
"request."
msgstr "将更改提交到此分支，然后推送到 GitHub 并创建拉取请求。"

#: docs/en/how-to/style-guide.md:1
#, fuzzy
msgid "-8<- \"style_guide.md\""
msgstr "-8<- \"style_guide.md\""

#: docs/en/index.md:1
#, fuzzy
msgid "Welcome to the BeeWare Tutorial"
msgstr "欢迎来到 BeeWare 教程!"

#: docs/en/index.md:3
msgid "**Write Python. Run Anywhere.**"
msgstr "**用 Python 编写。随处运行。**"

#: docs/en/index.md:5
msgid ""
"Welcome to BeeWare! In this tutorial, we're going to build a graphical user "
"interface using Python, and deploy it as a desktop application, as a mobile "
"application, and as a single page web app. We'll also look at how you can "
"use BeeWare tools to perform some of the common tasks that you'll need to do"
" as an app developer, such as testing your app."
msgstr ""
"欢迎来到 BeeWare！在本教程中，我们将使用 Python "
"构建一个图形用户界面，并将其部署为桌面应用程序、移动应用程序和单页网页应用程序。我们还将探讨如何使用 BeeWare "
"工具执行应用程序开发者需要做的一些常见任务，例如测试你的应用。"

#: docs/en/index.md:7
msgid "{% if config.extra.translation_type == \"original\" %}"
msgstr "{% if config.extra.translation_type == \"original\" %}"

#: docs/en/index.md:9
#, fuzzy
msgid "/// admonition | Translations are available"
msgstr "/// admonition |提供翻译"

#: docs/en/index.md:11
msgid ""
"If you're not comfortable with English, translations of this tutorial are "
"available in [Deutsch]{1}, [Español]{2}, [Français]{3}, [Italiano]{4}, "
"[Português]{5}, [中文(简体)]{6}, and [中文(繁體)]{7}."
msgstr ""
"如果您不熟悉中文，本教程提供了以下语言的翻译：[Deutsch]{1} （德语）、[Español]{2} （西班牙语）、[Français]{3} "
"（法语）、[Italiano]{4} （意大利语）、[Português]{5} （葡萄牙语）、[中文(简体)]{6} （中文（简体））和 "
"[中文(繁體)]{7} （中文（繁体））。"

#: docs/en/index.md:15 docs/en/index.md:27 docs/en/index.md:39
msgid "{% endif %}"
msgstr "{% endif %}"

#: docs/en/index.md:17
msgid "{% if config.extra.translation_type == \"machine\" %}"
msgstr "{% if config.extra.translation_type == \"machine\" %}"

#: docs/en/index.md:19
#, fuzzy
msgid "/// admonition | This is a machine translation!"
msgstr "/// admonition |这是机器翻译！"

#: docs/en/index.md:21
msgid ""
"This version of the tutorial has been generated by machine translation. We "
"know this isn't ideal, but we felt that a bad translation was better than no"
" translation at all."
msgstr "本教程版本由机器翻译生成。我们知道这并不理想，但我们认为糟糕的翻译总比没有翻译好。"

#: docs/en/index.md:23 docs/en/index.md:35
msgid ""
"If you'd like the help improve the translation, get in touch! We have a "
"`#translations` channel in [Discord]{1}. Introduce yourself there and we "
"will add you to the translation team."
msgstr ""
"如果您想帮助改进翻译，请联系我们！我们在 [Discord]{1} 中有一个 `#translations` "
"频道；在那儿介绍自己，我们会邀请您加入翻译团队。"

#: docs/en/index.md:29
msgid "{% if config.extra.translation_type == \"human\" %}"
msgstr "{% if config.extra.translation_type == \"human\" %}"

#: docs/en/index.md:31
#, fuzzy
msgid "/// admonition | This is a translation!"
msgstr "/// admonition |这是译文！"

#: docs/en/index.md:33
msgid ""
"This document is a translation of the English version. The translation has "
"been reviewed by humans, but newer sections may be generated by machine "
"translation, or not translated at all."
msgstr "本文档是英文文档的翻译。翻译已由人工审核，但较新的部分可能是由机器翻译生成的，或者根本未翻译。"

#: docs/en/index.md:41
msgid "What is BeeWare?"
msgstr "什么是 BeeWare？"

#: docs/en/index.md:43
msgid ""
"BeeWare is not a single product, or tool, or library - it's a collection of "
"tools and libraries, each of which works together to help you write cross "
"platform Python applications with a native GUI. It includes:"
msgstr ""
"BeeWare 并不是一个单独的产品、工具或库 "
"(library)，它是一系列工具和库的集合：每个工具和库都能协同工作，帮助您编写跨平台、具有本地图形用户界面的 Python 应用程序。它包括:"

#: docs/en/index.md:45
#, fuzzy
msgid "[Toga]{1}, a cross-platform widget toolkit;"
msgstr "[Toga]{1}，一个跨平台部件工具包；"

#: docs/en/index.md:46
msgid ""
"[Briefcase]{1}, a tool for packaging Python projects as distributable "
"artefacts that can be shipped to end users;"
msgstr "[Briefcase]{1}，一个用于将 Python 项目打包为可分发给最终用户的的成品的工具;"

#: docs/en/index.md:47
msgid ""
"Libraries (such as [Rubicon ObjC]{1}) for accessing platform-native "
"libraries;"
msgstr "用于访问平台原生库的库（如 [Rubicon ObjC]{1}）;"

#: docs/en/index.md:48
msgid ""
"Pre-compiled builds of Python that can be used on platforms where official "
"Python installers aren't available."
msgstr "预编译的 Python 版本，可在官方 Python 安装程序不可用的平台上使用。"

#: docs/en/index.md:50
msgid ""
"In this tutorial, we'll be using all these tools, but as a user, you'll only"
" need to interact with the first two (Toga and Briefcase). However, each of "
"the tools can also be used individually - for example, you can use Briefcase"
" to deploy an app without using Toga as a GUI toolkit."
msgstr ""
"在这个教程中，我们将使用所有这些工具，但作为用户，你只需要与前两个（Toga 和 Briefcase）互动。然而，每个工具也可以单独使用 - "
"例如，你可以使用Briefcase部署应用程序，而不使用 Toga 作为 GUI 工具包。"

#: docs/en/index.md:52
msgid ""
"The BeeWare suite is available on macOS, Windows, Linux (using GTK); on "
"mobile platforms such as Android and iOS; and for the Web."
msgstr ""
"BeeWare 套件可用于 macOS、Windows、Linux（使用GTK）上；在移动平台如 Android 和 iOS 上；以及在 Web 上。"

#: docs/en/index.md:54
#, fuzzy
msgid "Let's go"
msgstr "让我们开始吧！"

#: docs/en/index.md:56
#, fuzzy
msgid ""
"Ready to try BeeWare for yourself? [Let's build a cross-platform application"
" in Python!]{1}"
msgstr "准备好亲身体验BeeWare了吗？[让我们用Python构建一个跨平台应用程序！]{1}."

#: docs/en/tutorial/topics/camera-access.md:1
#, fuzzy
msgid "Using the camera"
msgstr "使用相机"

#: docs/en/tutorial/topics/camera-access.md:3
msgid ""
"Almost every modern computing device has a camera of some sort. In this "
"tutorial, we'll write new application that is able to request access to this"
" camera, take a photograph, and then display that photograph in the new "
"application that uses your device's camera."
msgstr ""
"几乎每一台现代计算机都配备某种类型的摄像头。在本教程中，我们将编写一个新程序，使该程序能够请求访问摄像头、拍摄照片，然后在这个新的应用程序当中显示所拍摄的照片。"

#: docs/en/tutorial/topics/camera-access.md:5
#, fuzzy
msgid "/// admonition | This tutorial won't work on all platforms!"
msgstr "/// admonition |本教程并不适用于所有平台！"

#: docs/en/tutorial/topics/camera-access.md:7
msgid ""
"Unfortunately, at present, this tutorial will only work on macOS and "
"Android."
msgstr "遗憾的是，目前本教程仅适用于 macOS 系统和 Android。"

#: docs/en/tutorial/topics/camera-access.md:9
msgid ""
"Although iPhones all have cameras, the iOS *Simulator* doesn't have a "
"working camera. Windows and Linux devices also have cameras, but Toga "
"doesn't currently have the ability to access the camera on these platforms."
msgstr ""
"虽然所有 iPhone 都有摄像头，iOS *虚拟机*\\ 没有正常工作的摄像头。Windows 与 Linux 设备也有摄像头，但 Toga "
"目前不提供在这些平台上访问摄像头的能力。"

#: docs/en/tutorial/topics/camera-access.md:11
msgid ""
"The code presented here will *run* on Windows or Linux; but it will raise an"
" error when you try to take a photograph."
msgstr "这里展示的代码可以在 Windows 或 Linux 上运行，但是当您尝试照相时，它会报错。"

#: docs/en/tutorial/topics/camera-access.md:13
msgid ""
"The code will work if it is run on an actual iOS device, but will fail to "
"take a photograph if deployed to the iOS simulator."
msgstr "这段代码在 iOS 设备上会正常工作，但部署到 iOS 虚拟器时，它将无法正常拍照。"

#: docs/en/tutorial/topics/camera-access.md:17
#, fuzzy
msgid "Start a new project"
msgstr "启动新项目"

#: docs/en/tutorial/topics/camera-access.md:19
#, fuzzy
msgid ""
"For this tutorial, we're not going to build onto the application from the "
"core tutorial - we're going to start a fresh project. You can use the same "
"virtual environment you used in the first project; but we need to re-run the"
" `briefcase new` wizard."
msgstr ""
"在本教程中，我们不会在核心教程中的应用程序上进行构建，而是要启动一个全新的项目。您可以使用与第一个项目相同的虚拟环境；但我们需要重新运行 \"新建公文包"
" \"向导。"

#: docs/en/tutorial/topics/camera-access.md:21
#, fuzzy
msgid ""
"Change back to the directory that contains the `helloworld` project folder, "
"and start a new project named \"Hello Camera\":"
msgstr "返回包含 `helloworld` 项目文件夹的目录，并启动名为 \"Hello Camera \"的新项目："

#: docs/en/tutorial/topics/camera-access.md:37
#, fuzzy
msgid "Add code to take a photo"
msgstr "添加拍摄照片的代码"

#: docs/en/tutorial/topics/camera-access.md:39
#, fuzzy
msgid ""
"The wizard has generated a new empty Toga project. We can now add the code "
"to take and display a photograph. Edit the `app.py` for the new application "
"so that it has the following content:"
msgstr "向导已经生成了一个新的空 Toga 项目。现在我们可以添加代码来拍摄并显示照片。编辑新应用程序的 `app.py`，使其包含以下内容："

#: docs/en/tutorial/topics/camera-access.md:92
#, fuzzy
msgid ""
"This code has two changes over the default app that is generated by "
"Briefcase. These additions are highlighted above:"
msgstr "与 Briefcase 生成的默认应用程序相比，这段代码有两处改动。上面突出显示了这些新增内容："

#: docs/en/tutorial/topics/camera-access.md:94
#, fuzzy
msgid ""
"The first highlighted code block (in the `startup()` method) adds the two "
"widgets needed to control the camera: an `ImageView` to display a photo; and"
" a `Button` to trigger the camera."
msgstr ""
"第一个突出显示的代码块（在 `startup()` 方法中）添加了控制摄像头所需的两个部件：显示照片的 `ImageView` 和触发摄像头的 "
"`Button` 。"

#: docs/en/tutorial/topics/camera-access.md:95
#, fuzzy
msgid ""
"The second highlighted code block (the `take_photo()` method) defines the "
"event handler when the button is pressed. This handler first confirms if the"
" application has permission to take a photo; if permission doesn't exist, it"
" is requested. Then, a photo is taken. The request for permission and the "
"request to take a photo are both asynchronous requests, so they require the "
"use of `await`; while the app is waiting for the user to confirm permissions"
" or take the photo, the app's event loop can continue in the background."
msgstr ""
"第二个突出显示的代码块（\"take_photo() "
"\"方法）定义了按下按钮时的事件处理程序。该处理程序首先会确认应用程序是否有拍照权限；如果没有权限，则会请求权限。然后拍摄照片。请求权限和请求拍照都是异步请求，因此需要使用"
" `await`；当应用程序等待用户确认权限或拍照时，应用程序的事件循环可以在后台继续。"

#: docs/en/tutorial/topics/camera-access.md:97
#, fuzzy
msgid ""
"If the camera successfully takes a photo, it will return an `Image` object "
"that can be assigned as the content of the `ImageView`. If the photo request"
" was canceled by the user, the `self.camera.take_photo()` call will return "
"`None`, and the result can be ignored. If the user doesn't grant permission "
"to use the camera, or the camera isn't implemented on the current platform, "
"an error will be raised, and a dialog will be shown to the user."
msgstr ""
"如果相机成功拍摄了照片，它将返回一个 `Image` 对象，该对象可被分配为 `ImageView` "
"的内容。如果用户取消了拍照请求，`self.camera.take_photo()` "
"调用将返回`None`，结果可以忽略。如果用户未授予使用相机的权限，或当前平台未实现相机，则会引发错误，并向用户显示对话框。"

#: docs/en/tutorial/topics/camera-access.md:99
msgid "Adding device permissions"
msgstr "添加设备权限"

#: docs/en/tutorial/topics/camera-access.md:101
#, fuzzy
msgid ""
"Part of this code we've just added asks for permission to use the camera. "
"This is a common feature of modern app platforms - you can't access hardware"
" features without explicitly asking the user's permission first."
msgstr ""
"我们刚刚添加的代码中有一部分要求获得使用摄像头的权限。这是现代应用程序平台的一个共同特点--如果不事先明确征求用户许可，就无法访问硬件功能。"

#: docs/en/tutorial/topics/camera-access.md:103
#, fuzzy
msgid ""
"However, this request comes in two parts. The first is in the code we've "
"just seen; but before the app can ask for permissions, it needs to declare "
"the permissions it is going to ask for."
msgstr "不过，这种请求分为两部分。第一部分在我们刚刚看到的代码中；但在应用程序请求权限之前，它需要声明要请求的权限。"

#: docs/en/tutorial/topics/camera-access.md:105
#, fuzzy
msgid ""
"The permissions required by each platform are slightly different, but "
"Briefcase has a cross-platform representation for many common hardware "
"permissions. In the `[tool.briefcase.app.hellocamera]` configuration section"
" of your app's `pyproject.toml` file, add the following (just above the "
"`sources` declaration):"
msgstr ""
"每个平台所需的权限略有不同，但 Briefcase 为许多常见硬件权限提供了跨平台表示。在应用程序的 `pyproject.toml` 文件的 "
"`[tool.briefcase.app.hellocamera]`配置部分，添加以下内容（就在 `sources` 声明的上方）："

#: docs/en/tutorial/topics/camera-access.md:111
#, fuzzy
msgid ""
"This declares that your app needs to access the camera, and provides a short"
" description why the camera is required. This description is needed on some "
"platforms (most notably macOS and iOS) and will be displayed to the user as "
"a additional information when the permission dialog is presented."
msgstr ""
"这将声明您的应用程序需要访问摄像头，并提供一个简短的说明，说明为什么需要使用摄像头。某些平台（尤其是 macOS 和 "
"iOS）需要此说明，并将在权限对话框显示时作为附加信息显示给用户。"

#: docs/en/tutorial/topics/camera-access.md:113
msgid "We can now generate and run the app:"
msgstr "我们现在可以生成并运行应用程序："

#: docs/en/tutorial/topics/camera-access.md:125
#: docs/en/tutorial/topics/custom-icons.md:91
#: docs/en/tutorial/topics/custom-icons.md:281
#: docs/en/tutorial/topics/custom-icons.md:428
#: docs/en/tutorial/tutorial-7.md:100 docs/en/tutorial/tutorial-7.md:165
#: docs/en/tutorial/tutorial-7.md:320 docs/en/tutorial/tutorial-7.md:565
#: docs/en/tutorial/tutorial-8.md:122 docs/en/tutorial/tutorial-8.md:237
msgid "/// tab | Android"
msgstr "/// tab | Android"

#: docs/en/tutorial/topics/camera-access.md:135
#, fuzzy
msgid ""
"When the app runs, you'll be presented with a button. Press the button, and "
"the platform's default camera dialog will be displayed. Take a photo; the "
"camera dialog will disappear, and the photo will be displayed on in the app,"
" just above the button. You could then take another photo; this will replace"
" the first photo."
msgstr ""
"程序运行时，会出现一个按钮。按下按钮后，平台的默认相机对话框就会显示。拍照后，相机对话框将消失，照片将显示在应用程序中，就在按钮上方。然后，您可以再拍一张照片；这张照片将取代第一张照片。"

#: docs/en/tutorial/topics/camera-access.md:137
#, fuzzy
msgid "Adding more permissions"
msgstr "添加设备权限"

#: docs/en/tutorial/topics/camera-access.md:139
#, fuzzy
msgid ""
"Permissions are declared in the files that are generated during the original"
" call to `briefcase create`. Unfortunately, Briefcase can't update these "
"files once they've been initially generated; so if you want to add a new "
"permission to your app, or modify existing permissions, you'll need to re-"
"create the app. You can do this by re-running `briefcase create`; this will "
"warn you that the existing app will be overwritten, and then regenerate the "
"application with the new permissions."
msgstr ""
"权限声明在最初调用 `briefcase create` 时生成的文件中。不幸的是，Briefcase "
"无法在最初生成这些文件后对其进行更新；因此，如果您想在应用程序中添加新权限或修改现有权限，则需要重新创建应用程序。您可以通过重新运行 "
"`briefcase create` 来做到这一点；这将警告您现有的应用程序将被覆盖，然后用新的权限重新生成应用程序。"

#: docs/en/tutorial/topics/custom-icons.md:1
#, fuzzy
msgid "Customizing icons"
msgstr "自定义图标"

#: docs/en/tutorial/topics/custom-icons.md:3
msgid ""
"The app we developed in the main tutorial uses a default \"gray bee\" icon "
"when it is packaged. Let's personalize this application by configuring it to"
" use our own icon."
msgstr "我们在主教程中开发的应用在打包时使用了默认的 “灰色蜜蜂” 图标。让我们通过配置使用我们自己的图标来个性化此应用程序。"

#: docs/en/tutorial/topics/custom-icons.md:5
#: docs/en/tutorial/topics/custom-icons.md:319
#: docs/en/tutorial/topics/custom-icons.md:363
#: docs/en/tutorial/tutorial-2.md:107 docs/en/tutorial/tutorial-2.md:157
#: docs/en/tutorial/tutorial-4.md:124 docs/en/tutorial/tutorial-7.md:610
#, fuzzy
msgid "/// note | Note"
msgstr "/// note |备注"

#: docs/en/tutorial/topics/custom-icons.md:7
#, fuzzy
msgid "In BeeWare, the term *icon* can refer to two different things:"
msgstr "在 BeeWare 中，*icon* 一词可以指两种不同的东西："

#: docs/en/tutorial/topics/custom-icons.md:9
#, fuzzy
msgid ""
"**Application icon** — The image that represents your app on the desktop, "
"dock, or home screen."
msgstr "** 应用程序图标** - 在桌面、Dock 或主屏幕上代表应用程序的图像。"

#: docs/en/tutorial/topics/custom-icons.md:11
#, fuzzy
msgid ""
"**Runtime icons** — Images used inside your app’s interface (for example, in"
" buttons or tables)."
msgstr "**运行时图标** - 应用程序界面中使用的图片（例如，按钮或表格中的图片）。"

#: docs/en/tutorial/topics/custom-icons.md:15
msgid "Adding an icon"
msgstr "添加图标"

#: docs/en/tutorial/topics/custom-icons.md:17
msgid ""
"Every platform uses a different format for application icons - and some "
"platforms need *multiple* icons in different sizes and shapes. To account "
"for this, Briefcase provides a shorthand way to configure an icon once, and "
"then have that definition expand in to all the different icons needed for "
"each individual platform."
msgstr ""
"每个平台都使用不同的应用程序图标格式 -- 有些还需要\\ *多个*\\ 不同大小和形状的。为此考虑，Briefcase "
"提供了一种简短的方法，可以配置一次图标，并让这种定义扩充到每个单个平台的所有所需要的图标。"

#: docs/en/tutorial/topics/custom-icons.md:19
msgid ""
"Edit your `pyproject.toml`, adding a new `icon` configuration item in the "
"`[tool.briefcase.app.helloworld]` configuration section, just above the "
"`sources` definition:"
msgstr ""
"编辑您的 `project.toml`，在 `[tool.briefcase.app.helloworld]` 配置部分中，在 `sources` "
"的正上方添加一个 `icon` 配置项:"

#: docs/en/tutorial/topics/custom-icons.md:25
msgid ""
"This icon definition doesn't specify any file extension. The value will be "
"used as a prefix; each platform will add additional items to this prefix to "
"build the files needed for each platform. Some platforms require *multiple* "
"icon files; this prefix will be combined with file size and variant "
"modifiers to generate the list of icon files that are used."
msgstr ""
"图标配置时，无需指定任何扩展文件名。这里的值将会被作为前缀使用；每个平台将会在此前缀基础上添加更多项目，以构建在那个平台上所需的文件。有些平台需要\\ "
"*多个*\\ 图标文件；在这种情况下，前缀将与文件大小和变种结合在一起，生成使用的图标列表。"

#: docs/en/tutorial/topics/custom-icons.md:27
msgid ""
"We can now run `briefcase update` again - but this time, we pass in the "
"`--update-resources` flag, telling Briefcase that we want to install new "
"application resources (i.e., the icons):"
msgstr ""
"我们现在可以重新运行 `briefcase update` — 但这次，我们传入 `--update-resources` 标志，以告诉 "
"Briefcase 我们想要安装新的应用资源（图标）："

#: docs/en/tutorial/topics/custom-icons.md:129
#: docs/en/tutorial/topics/custom-icons.md:327
#: docs/en/tutorial/topics/custom-icons.md:444
#: docs/en/tutorial/tutorial-7.md:106 docs/en/tutorial/tutorial-7.md:171
#: docs/en/tutorial/tutorial-7.md:395 docs/en/tutorial/tutorial-7.md:584
#: docs/en/tutorial/tutorial-8.md:128 docs/en/tutorial/tutorial-8.md:245
msgid "/// tab | iOS"
msgstr "/// tab | iOS"

#: docs/en/tutorial/topics/custom-icons.md:163
#, fuzzy
msgid ""
"This reports the specific icon file (or files) that Briefcase is expecting. "
"However, as we haven't provided the actual icon files, the install fails, "
"and Briefcase falls back to a default value (the same \"gray bee\" icon)."
msgstr ""
"这将报告 Briefcase 期望的特定图标文件（或多个文件）。但是，由于我们没有提供实际的图标文件，安装失败，Briefcase 恢复到默认值（相同的"
" \"灰色蜜蜂 \"图标）。"

#: docs/en/tutorial/topics/custom-icons.md:165
#, fuzzy
msgid ""
"Let's provide some actual icons. Download [this icons.zip bundle]{1}, and "
"unzip it into the root of your project directory. After unzipping, your "
"project directory should look something like:"
msgstr ""
"让我们提供一些实际的图标。下载 [this icons.zip bundle]{1}，并解压到项目目录根目录。解压缩后，你的项目目录应该如下所示："

#: docs/en/tutorial/topics/custom-icons.md:184
#, fuzzy
msgid ""
"There's a *lot* of icons in this folder, but most of them should look the "
"same: a green snake on a light blue background:"
msgstr "这个文件夹中有很多图标，但大多数看起来都一样：浅蓝色背景上有一条绿色的蛇："

#: docs/en/tutorial/topics/custom-icons.md:186
#, fuzzy
msgid "![Icon of green snake with a light blue background]{1}"
msgstr "浅蓝色背景下的绿蛇图标]{1}。"

#: docs/en/tutorial/topics/custom-icons.md:188
#: docs/en/tutorial/topics/custom-icons.md:470
#: docs/en/tutorial/tutorial-1.md:169 docs/en/tutorial/tutorial-1.md:179
#: docs/en/tutorial/tutorial-1.md:189 docs/en/tutorial/tutorial-2.md:271
#: docs/en/tutorial/tutorial-2.md:281 docs/en/tutorial/tutorial-2.md:291
#: docs/en/tutorial/tutorial-4.md:33 docs/en/tutorial/tutorial-4.md:43
#: docs/en/tutorial/tutorial-4.md:53
#: docs/en/tutorial/tutorial-5/android.md:224
#: docs/en/tutorial/tutorial-5/android.md:234
#: docs/en/tutorial/tutorial-5/android.md:244
#: docs/en/tutorial/tutorial-5/android.md:260
#: docs/en/tutorial/tutorial-5/iOS.md:99 docs/en/tutorial/tutorial-7.md:125
#: docs/en/tutorial/tutorial-7.md:142 docs/en/tutorial/tutorial-7.md:159
#: docs/en/tutorial/tutorial-7.md:218 docs/en/tutorial/tutorial-7.md:314
#: docs/en/tutorial/tutorial-8.md:74 docs/en/tutorial/tutorial-8.md:95
#: docs/en/tutorial/tutorial-8.md:116
msgid "/// caption"
msgstr "/// caption"

#: docs/en/tutorial/topics/custom-icons.md:192
#, fuzzy
msgid ""
"The only exception will be the icons with `-adaptive-` in their name; these "
"will have a transparent background. This represents all the different icon "
"sizes and shapes you need to support an app on every platform that Briefcase"
" supports."
msgstr ""
"唯一的例外是名称中带有\"-adaptive-\"的图标；这些图标将有透明背景。这代表了在 Briefcase "
"支持的每个平台上支持应用程序所需的所有不同图标尺寸和形状。"

#: docs/en/tutorial/topics/custom-icons.md:194
#, fuzzy
msgid ""
"Now that we have icons, we can update the application again. However, "
"`briefcase update` will only copy the updated resources into the build "
"directory; we also want to rebuild the app to make sure the new icon is "
"included, then start the app. We can shortcut this process by passing "
"`--update-resources` to our call to `run` - this will update the app, update"
" the app's resources, and then start the app:"
msgstr ""
"现在我们有了图标，可以再次更新应用程序了。不过，\"briefcase update "
"\"只会将更新后的资源复制到构建目录中；我们还需要重建应用程序以确保包含新图标，然后启动应用程序。我们可以通过在调用 `run` 时传递 "
"`--update-resources`来缩短这一过程，这将更新应用程序，更新应用程序的资源，然后启动应用程序："

#: docs/en/tutorial/topics/custom-icons.md:321
#, fuzzy
msgid ""
"If you're using a recent version of Android, you may notice that the app "
"icon has been changed to a green snake, but the background of the icon is "
"*white*, rather than light blue. We'll fix this in the next step."
msgstr ""
"如果您使用的是最新版本的安卓系统，您可能会注意到应用程序图标已更改为绿色的蛇形，但图标的背景却是*白色*，而不是浅蓝色。我们将在下一步中解决这个问题。"

#: docs/en/tutorial/topics/custom-icons.md:365
#, fuzzy
msgid ""
"If you get a stack trace referencing `faker` or `httpx` when you run the "
"app, it's possible you missed running your app during step 7 or 8 of the "
"tutorial. Re-run the app, adding the `-r` argument to update the app "
"requirements."
msgstr ""
"如果在运行应用程序时出现引用 `faker` 或 `httpx` 的堆栈跟踪，则有可能是在教程的第 7 或第 8 "
"步中没有运行应用程序。重新运行应用程序，添加 `-r` 参数以更新应用程序需求。"

#: docs/en/tutorial/topics/custom-icons.md:369
#, fuzzy
msgid ""
"When you run the app on iOS or Android, in addition to the icon change, you "
"should also notice that the splash screen incorporates the new icon. "
"However, the light blue background of the icon looks a little out of place "
"against the white background of the splash screen. We can fix this by "
"customizing the background color of the splash screen. Add the following "
"definition to your `pyproject.toml`, just after the `icon` definition:"
msgstr ""
"在 iOS 或 Android "
"上运行应用程序时，除了图标的变化外，您还会发现闪屏也加入了新图标。不过，图标的淡蓝色背景与闪屏的白色背景显得有些格格不入。我们可以通过自定义闪屏的背景颜色来解决这个问题。将以下定义添加到"
" `pyproject.toml` 中，就在 icon` 定义之后："

#: docs/en/tutorial/topics/custom-icons.md:375
#, fuzzy
msgid ""
"Unfortunately, Briefcase isn't able to apply this change to an already "
"generated project, as it requires making modifications to one of the files "
"that was generated during the original call to `briefcase create`. To apply "
"this change, we have to re-create the app by re-running `briefcase create`. "
"When we do this, we'll be prompted to confirm that we want to overwrite the "
"existing project:"
msgstr ""
"不幸的是，Briefcase 无法将此更改应用于已生成的项目，因为这需要修改在最初调用 `briefcase create` "
"时生成的文件之一。要应用这一更改，我们必须通过重新运行 `briefcase create` "
"来重新创建应用程序。当我们这样做时，系统会提示我们确认是否要覆盖现有项目："

#: docs/en/tutorial/topics/custom-icons.md:460
#, fuzzy
msgid ""
"You can then re-build and re-run the app using `briefcase run`. You won't "
"notice any changes to the desktop app; but the Android or iOS apps should "
"now have a light blue splash screen background."
msgstr ""
"然后，您可以使用 \"briefcase run \"重新构建和运行应用程序。您不会注意到桌面应用程序有任何变化；但安卓或 iOS "
"应用程序现在应该有一个淡蓝色的闪屏背景。"

#: docs/en/tutorial/topics/custom-icons.md:462
#, fuzzy
msgid ""
"You'll need to re-create the app like this whenever you make a change to "
"your `pyproject.toml` that doesn't relate to source code or dependencies. "
"Any change to descriptions, version numbers, colors, or permissions will "
"require a re-create step. Because of this, while you are developing your "
"project, you shouldn't make any manual changes to the contents of the "
"`build` folder, and you shouldn't add the `build` folder to your version "
"control system. The `build` folder should be considered entirely ephemeral -"
" an output of the build system that can be recreated as needed to reflect "
"the current configuration of your project."
msgstr ""
"每当您对 "
"`pyproject.toml`进行与源代码或依赖关系无关的更改时，都需要像这样重新创建应用程序。对描述、版本号、颜色或权限的任何更改都需要重新创建步骤。因此，在开发项目时，不应手动更改"
" `build` 文件夹的内容，也不应将 `build` 文件夹添加到版本控制系统中。build "
"\"文件夹应被视为完全短暂的，它是构建系统的输出，可根据需要重新创建，以反映项目的当前配置。"

#: docs/en/tutorial/topics/custom-icons.md:464
#, fuzzy
msgid "Adding a runtime icon"
msgstr "添加运行时图标"

#: docs/en/tutorial/topics/custom-icons.md:466
#, fuzzy
msgid ""
"When it comes to adding an icon to the app interface, this type of icon must"
" be stored in a separate directory from the application icons. Right click "
"Tiberius the yak, save that image as a `.png` file and name it `helloworld`."
" The file should then be saved to the `icons/` folder in your application "
"source package."
msgstr ""
"在应用程序界面上添加图标时，这类图标必须与应用程序图标分开存放。右键单击牦牛提比略，将图片保存为`.png`文件并命名为`helloworld`。然后将该文件保存到应用程序源码包中的"
" `icons/` 文件夹中。"

#: docs/en/tutorial/topics/custom-icons.md:468
#, fuzzy
msgid "![Icon of Tiberius the yak]{1}"
msgstr "牦牛提比略的圣像]{1}。"

#: docs/en/tutorial/topics/custom-icons.md:474
#, fuzzy
msgid "Your directory will resemble the following:"
msgstr "您的目录将如下所示："

#: docs/en/tutorial/topics/custom-icons.md:496
#, fuzzy
msgid ""
"Now that the runtime icon is in place, let's add an icon to our button. The "
"Toga button widget will only accommodate either an icon or text (not both), "
"so let's update the code for the button to include the runtime icon."
msgstr ""
"现在运行时图标已经就位，让我们为按钮添加一个图标。Toga 按钮 widget "
"只能容纳图标或文本（不能同时容纳），因此让我们更新按钮的代码，加入运行时图标。"

#: docs/en/tutorial/topics/custom-icons.md:508
#, fuzzy
msgid ""
"Since runtime icons are app resources bundled inside your Python package, no"
" rebuild or resource update is needed. At this point you can run `briefcase "
"dev` (or `briefcase run`) to see the icon added to the button."
msgstr ""
"由于运行时图标是捆绑在 Python 包内的应用程序资源，因此不需要重建或更新资源。此时，您可以运行 `briefcase dev` (或 "
"`briefcase run`) 来查看添加到按钮上的图标。"

#: docs/en/tutorial/topics/index.md:3
msgid ""
"Want to go deeper on specific topics? Here are some additional tutorials "
"that explore common aspects of application development. Each tutorial is "
"standalone, and can be completed in any order; but they all assume you've "
"completed the core tutorial."
msgstr "想在一些主题更加深入吗？这里有一些探索应用程序开发的常见方面的教程。教程互相独立，可以任意顺序完成，但它们都假设您已学习了主教程。"

#: docs/en/tutorial/topics/index.md:7
msgid ""
"Customize your application's appearance by replacing the default \"gray "
"bee\" icon."
msgstr "替换“灰蜜蜂”图标以自定义您的应用程序的外观。"

#: docs/en/tutorial/topics/index.md:11
msgid ""
"Use the camera on your mobile or desktop device to take and view a picture "
"from within your application."
msgstr "使用在移动或桌面设备上的相机在您的应用程序中拍与查看图片。"

#: docs/en/tutorial/topics/index.md:15
msgid ""
"How do you ensure that your application works, and stays working? By adding "
"a test suite to your project!"
msgstr "怎样确保您的应用程序始终正常工作？向您的项目加入一个测试组！"

#: docs/en/tutorial/topics/testing.md:1
msgid "Testing times"
msgstr "测试时间"

#: docs/en/tutorial/topics/testing.md:3
msgid ""
"Most software development doesn't involve writing new code - it's modifying "
"existing code. Ensuring that existing code continues to work in the way we "
"expect is a key part of the software development process. One way to do "
"ensure the behavior of our app is with a *test suite*."
msgstr ""
"大多数软件开发并不涉及编写新代码，而是修改现有代码。确保现有代码以我们期望的方式继续正常工作是软件开发过程的关键部分。确保应用程序行为的方法之一是使用一个\\"
" *测试套件*。"

#: docs/en/tutorial/topics/testing.md:5
msgid "Running the test suite"
msgstr "运行测试套件"

#: docs/en/tutorial/topics/testing.md:7
msgid ""
"It turns out the project from the core tutorial already has a test suite! "
"When we originally generated our project, two top-level directories were "
"generated: `src` and `tests`. The `src` folder contains the code for our "
"app; the `tests` folder contains our test suite. Inside the `tests` folder "
"is a file named `test_app.py` with the following content:"
msgstr ""
"原来我们的项目已经有了一个测试套件！我们最初生成项目时，会生成两个顶级目录：[`src`\\ 和\\ `tests`。`src`\\ "
"文件夹包含应用程序的代码；`tests`\\ 文件夹包含测试套件。在\\ `tests`\\ 文件夹中，有一个名为\\ `test_app.py`\\ "
"的文件，内容如下:"

#: docs/en/tutorial/topics/testing.md:15
#, fuzzy
msgid ""
"This is a [Pytest]{1} *test case* - a block of code that can be executed to "
"verify some behavior of your app. In this case, the test is a placeholder, "
"and doesn't test anything about our app - but it is a test that we can "
"perform."
msgstr ""
"这是一个 "
"[Pytest]{1}*测试用例*--可用于验证应用程序某些行为的代码块。在本例中，该测试是一个占位符，并不测试我们应用程序的任何内容，但我们可以执行该测试。"

#: docs/en/tutorial/topics/testing.md:17
msgid ""
"We can run this test suite using the `--test` option to `briefcase dev`. As "
"this is the first time we are running tests, we also need to pass in the "
"`-r` option to ensure that the test requirements are also installed:"
msgstr ""
"我们可以使用 `briefcase dev` 的 `--test` 选项来运行这个测试套件。由于这是第一次运行测试，我们还需要传递 `-r` "
"选项，以确保测试以来想也已安装："

#: docs/en/tutorial/topics/testing.md:100
msgid ""
"Success! We've just executed a single test that verifies Python math works "
"in the way we'd expect (What a relief!)."
msgstr "成功了！我们刚刚执行了一个测试，验证了 Python 数学以我们预期的方式运行（真是松了一口气！）。"

#: docs/en/tutorial/topics/testing.md:102
msgid ""
"Let's replace this placeholder test with a test to verify that our "
"`greeting()` method behaves the way we'd expect. Replace the contents of "
"`test_app.py` with the following:"
msgstr ""
"让我们用一个测试来替换这个占位符测试，以验证我们的 `greeting()` 方法是否按照我们预期的方式运行。用以下内容替换 `test_app.py`"
" 中的内容:"

#: docs/en/tutorial/topics/testing.md:120
msgid ""
"This defines two new tests, verifying the two behaviors we expect to see: "
"the output when a name is provided, and the output when the name is empty."
msgstr "这将定义两个新测试，验证我们期望看到的两种行为：提供名称时的输出和名称为空时的输出。"

#: docs/en/tutorial/topics/testing.md:122
msgid ""
"We can now re-run the test suite. This time, we don't need to provided the "
"`-r` option, as the test requirements have already been installed; we only "
"need to use the `--test` option:"
msgstr "现在我们可以重新运行测试套件。这一次，我们不需要提供 `-r` 选项，因为测试需求已经安装完毕；我们只需要使用 `--test` 选项："

#: docs/en/tutorial/topics/testing.md:181
msgid "Excellent! Our `greeting()` utility method is working as expected."
msgstr "非常好！我们的 `greeting()` 实用程序方法如期工作了。"

#: docs/en/tutorial/topics/testing.md:183
msgid "Test driven development"
msgstr "测试驱动开发"

#: docs/en/tutorial/topics/testing.md:185
msgid ""
"Now that we have a test suite, we can use it to drive the development of new"
" features. Let's modify our app to have a special greeting for one "
"particular user. We can start by adding a test case for the new behavior "
"that we'd like to see to the bottom of `test_app.py`:"
msgstr ""
"现在我们有了测试套件，可以用它来推动新功能的开发。让我们修改应用程序，为某位用户添加特殊的问候语。首先，我们可以在 `test_app.py` "
"的底部为我们希望看到的新行为添加一个测试用例:"

#: docs/en/tutorial/topics/testing.md:194
msgid "Then, run the test suite with this new test:"
msgstr "然后，用这个新测试运行测试套件："

#: docs/en/tutorial/topics/testing.md:300
msgid ""
"This time, we see a test failure - and the output explains the source of the"
" failure: the test is expecting the output \"BeeWare the IDEs of Python!\", "
"but our implementation of `greeting()` is returning \"Hello, Brutus\". Let's"
" modify the implementation of `greeting()` in `src/helloworld/app.py` to "
"have the new behavior:"
msgstr ""
"这一次，我们看到了测试失败--输出结果解释了失败的原因：测试期望输出 \"BeeWare the IDEs of Python!\"，但我们的 "
"`greeting()` 实现却返回 \"Hello, Brutus\"。让我们修改 `src/helloworld/app.py` 中 "
"`greeting()` 的实现，使其具有新的行为:"

#: docs/en/tutorial/topics/testing.md:313
msgid "If we run the tests again, we'll now see our tests pass:"
msgstr "如果我们再次运行测试，就会发现测试通过了："

#: docs/en/tutorial/topics/testing.md:375
msgid "Runtime tests"
msgstr "运行时测试"

#: docs/en/tutorial/topics/testing.md:377
msgid ""
"So far, we've been running the tests in development mode. This is especially"
" useful when you're developing new features, as you can rapidly iterate on "
"adding tests, and adding code to make those tests pass. However, at some "
"point, you'll want to verify that your code also runs correctly when inside "
"the bundle app environment."
msgstr ""
"到目前为止，我们一直在开发模式下运行测试。这在开发新功能时尤其有用，因为您可以快速迭代添加测试，并添加代码使测试通过。不过，在某些情况下，您会希望验证您的代码在捆绑应用程序环境下是否也能正确运行。"

#: docs/en/tutorial/topics/testing.md:379
msgid ""
"The `--test` and `-r` options can also be passed to the `run` command. If "
"you use `briefcase run --test -r`, the same test suite will run, but it will"
" run inside the packaged application bundle rather than your development "
"environment:"
msgstr ""
"`-test` 和 `-r` 选项也可以传递给 `run` 命令。如果使用 `briefcase run --test "
"-r`，将运行相同的测试套件，但它将在打包的应用程序捆绑包内运行，而不是在开发环境中运行："

#: docs/en/tutorial/topics/testing.md:498
msgid ""
"As with `briefcase dev --test`, the `-r` option is only needed the first "
"time you run the test suite to ensure that the test dependencies are "
"present. On subsequent runs, you can omit this option."
msgstr ""
"与 `briefcase dev --test` 一样，只有在第一次运行测试套件时才需要使用 `-r` "
"选项，以确保测试依赖项的存在。以后运行时，可以省略该选项。"

#: docs/en/tutorial/topics/testing.md:500
msgid ""
"You can also use the `--test` option on mobile backends: - so `briefcase run"
" iOS --test` and `briefcase run android --test` will both work, running the "
"test suite on the mobile device you select."
msgstr ""
"你也可以在移动后端使用 `--test` 选项：`briefcase run iOS --test` 和 `briefcase run android "
"--test`` 都可以在你选择的移动设备上运行测试套件。"

#: docs/en/tutorial/tutorial-0.md:1
#, fuzzy
msgid "Tutorial 0 - Let's get set up!"
msgstr "教程 0 - 准备就绪！"

#: docs/en/tutorial/tutorial-0.md:3
msgid ""
"Before we build our first BeeWare app, we have to make sure we've got all "
"the prerequisites for running BeeWare."
msgstr "在构建第一个使用 BeeWare 的应用程序之前，我们必须确保已具备运行 BeeWare 的所有先决条件。"

#: docs/en/tutorial/tutorial-0.md:5
#, fuzzy
msgid "Install Python { id=\"install-python\" }"
msgstr "安装 Python { id=\"install-python\" }"

#: docs/en/tutorial/tutorial-0.md:7
msgid "The first thing we'll need is a working Python interpreter."
msgstr "首先，我们需要一个正常工作的 Python 解释器。"

#: docs/en/tutorial/tutorial-0.md:11
msgid ""
"If you're on macOS, you can get an official Python installer from [the "
"Python website]{1}. You can use any version of Python from 3.10 or newer "
"(although you should avoid alphas, betas and release candidates). We "
"strongly recommend using Python 3.13 or newer."
msgstr ""
"如果您使用 macOS，您可以从 [Python 网站]{1}_\\ 获取官方安装程序。您可以使用 Python 3.10 以上时任何版本，但避免使用 "
"Alpha、Beta 和候选版本。我们强烈建议使用 Python 3.13 或更新版本。"

#: docs/en/tutorial/tutorial-0.md:13
#, fuzzy
msgid ""
"You can also install Python through [Homebrew]{1}, use [pyenv]{2} to manage "
"multiple Python installs, or use [Anaconda]{3} or [Miniconda]{4}. It doesn't"
" matter *how* you've installed Python - it only matters that you can run "
"`python3` from your terminal and get a working, supported Python "
"interpreter."
msgstr ""
"安装 Python 也有很多其他不同的方法。您可以通过 [homebrew]{1} 安装 Python，或使用 "
"[pyenv]{2}来管理同一台机器上的多个 Python 安装，或使用 [Anaconda]{3} 或 [Miniconda]{4}。*怎么*\\ "
"安装 Python 并不重要，只要可以从终端运行 `python3` 并获取到支持的、正常工作的 Python 解释器即可。"

#: docs/en/tutorial/tutorial-0.md:15
#, fuzzy
msgid ""
"Xcode and the Command-line Developer Tools provide a version of Python; "
"however that Python is version 3.9. Python 3.9 has reached end-of-life, and "
"is no longer supported by Python or BeeWare. You will *not* be able to use "
"the Xcode-provided version of Python to run this tutorial."
msgstr ""
"Xcode 和命令行开发工具提供了一个 Python 版本，但该 Python 版本为 3.9。Python 3.9 已达到生命周期的终点，Python"
" 或 BeeWare 不再支持该版本。您将**无法使用 Xcode 提供的 Python 版本运行本教程。"

#: docs/en/tutorial/tutorial-0.md:17
#, fuzzy
msgid ""
"To check the version of Python that you have installed, run the following "
"command:"
msgstr "要检查已安装的 Python 版本，请运行以下命令："

#: docs/en/tutorial/tutorial-0.md:23
#, fuzzy
msgid "If Python is installed, you'll see its version number."
msgstr "如果已安装 Python，则会看到其版本号。"

#: docs/en/tutorial/tutorial-0.md:29
msgid ""
"If you're on Linux, you'll install Python using the system package manager "
"(`apt` on Debian/Ubuntu/Mint, `dnf` on Fedora, or `pacman` on Arch)."
msgstr ""
"如果您使用的是 Linux，您将使用系统软件包管理器（Debian/Ubuntu/Mint 上的 `apt`，Fedora 上的 `dnf`，或 "
"Arch 上的 `pacman`）安装 Python。"

#: docs/en/tutorial/tutorial-0.md:31
#, fuzzy
msgid ""
"You should ensure that the system Python is Python 3.10 or newer; if it "
"isn't (e.g., Ubuntu 20.04 ships with Python 3.8), you'll need to upgrade "
"your Linux distribution to something more recent."
msgstr ""
"您应该确保系统 Python 是 Python 3.9 或更高；如果不是（例如，Ubuntu 20.04 附带 Python 3.8），您需要将您的 "
"Linux 发行版升级到更新版本。"

#: docs/en/tutorial/tutorial-0.md:33
msgid "Support for Raspberry Pi is limited at this time."
msgstr "目前对 Raspberry Pi 的支持有限。"

#: docs/en/tutorial/tutorial-0.md:35
#, fuzzy
msgid ""
"**Important:** You *must* use the system Python provided by your operating "
"system. Alternative Python installations (pyenv, Anaconda, manually compiled"
" Python, etc.) will prevent you from successfully packaging your application"
" for distribution in later steps of this tutorial."
msgstr ""
"**重要：** 您**必须**使用操作系统提供的系统 Python。其他 Python 安装（pyenv、Anaconda、手动编译的 Python "
"等）将导致您无法在本教程后面的步骤中成功打包发布应用程序。"

#: docs/en/tutorial/tutorial-0.md:41
#, fuzzy
msgid ""
"If you're on Windows, you can get the official installer from [the Python "
"website]{1}. You can use any version of Python from 3.10 to 3.13 (although "
"you should avoid alphas, betas and release candidates). We strongly "
"recommend using Python 3.13."
msgstr ""
"如果您使用的是 Windows，您可以从 [Python 网站]{1}\\ 获取官方安装程序。您可以使用 Python 3.9 到 3.13 "
"的任何稳定版本。我们还建议避免使用 Alpha、Beta 和候选版本，除非你\\ *真的*\\ 知道自己在做什么。"

#: docs/en/tutorial/tutorial-0.md:43
#, fuzzy
msgid "Support for Windows on ARM64 is limited at this time."
msgstr "目前对 Raspberry Pi 的支持有限。"

#: docs/en/tutorial/tutorial-0.md:45
#, fuzzy
msgid ""
"You can also install Python from the Windows App Store, or use [Anaconda]{1}"
" or [Miniconda]{2}. It doesn't matter *how* you've installed Python - it "
"only matters that you can run `python3` from your command prompt and get a "
"working, supported Python interpreter."
msgstr ""
"安装 Python 也有很多其他不同的方法。您可以通过 [homebrew]{1} 安装 Python，或使用 "
"[pyenv]{2}来管理同一台机器上的多个 Python 安装，或使用 [Anaconda]{3} 或 [Miniconda]{4}。*怎么*\\ "
"安装 Python 并不重要，只要可以从终端运行 `python3` 并获取到支持的、正常工作的 Python 解释器即可。"

#: docs/en/tutorial/tutorial-0.md:49
#, fuzzy
msgid "Install dependencies { id=\"install-dependencies\" }"
msgstr "安装依赖项 { id=\"install-dependencies\" }"

#: docs/en/tutorial/tutorial-0.md:51
msgid ""
"Next, install the additional dependencies needed for your operating system:"
msgstr "接下来，安装您的操作系统所需的其他依赖项："

#: docs/en/tutorial/tutorial-0.md:55
msgid "Building BeeWare apps on macOS requires:"
msgstr "在 macOS 上构建 BeeWare 应用程序需要："

#: docs/en/tutorial/tutorial-0.md:57
msgid ""
"**Git**, a version control system. This is included with Xcode or the "
"command line developer tools, which you installed above. You may need to "
"open Xcode for the first time in order for Git to work in your terminal "
"session. If it still doesn't register that Git is installed, you may need to"
" restart your terminal session."
msgstr ""
"**Git**，一个版本控制系统。上面已安装的 Xcode 或其命令行开发工具已经包含了Git。您可能需要第一次打开 Xcode "
"以后才能再命令行会话中使Git正常工作。如果仍然无法识别 Git，可能需要重启您的命令行会话。"

#: docs/en/tutorial/tutorial-0.md:63
msgid ""
"To support local development, you'll need to install some system packages. "
"The list of packages required varies depending on your distribution:"
msgstr "为支持本地开发，您将需要安装一些系统软件包。所需的软件包列表因发行版而异："

#: docs/en/tutorial/tutorial-0.md:65
#, fuzzy
msgid "Ubuntu / Debian"
msgstr "**Ubuntu 或 Debian**"

#: docs/en/tutorial/tutorial-0.md:72
#, fuzzy
msgid "Fedora"
msgstr "Fedora"

#: docs/en/tutorial/tutorial-0.md:78
#, fuzzy
msgid "Arch / Manjaro"
msgstr "**Arch 或 Manjaro**"

#: docs/en/tutorial/tutorial-0.md:84
#, fuzzy
msgid "OpenSUSE Tumbleweed"
msgstr "**OpenSUSE Tumbleweed**"

#: docs/en/tutorial/tutorial-0.md:94
msgid "Building BeeWare apps on Windows requires:"
msgstr "在 Windows 上构建 BeeWare 应用程序需要："

#: docs/en/tutorial/tutorial-0.md:96
#, fuzzy
msgid ""
"**Git**, a version control system. You can download Git from from {1}[git-"
"scm.com]{2}."
msgstr "**Git**，一个版本控制系统。您可以从 [git-scm.com]{1} 下载 Git。"

#: docs/en/tutorial/tutorial-0.md:98
msgid ""
"After installing these tools, you should ensure you restart any terminal "
"sessions. Windows will only expose newly installed tools terminals started "
"*after* the install has completed."
msgstr "安装这些工具后，应确保重新启动任何终端会话。Windows 只在安装完成后开始的命令行*才*会暴露新安装的工具。"

#: docs/en/tutorial/tutorial-0.md:102
msgid "Set up a virtual environment"
msgstr "建立虚拟环境"

#: docs/en/tutorial/tutorial-0.md:104
msgid ""
"We're now going to create a virtual environment - a \"sandbox\" that we can "
"use to isolate our work on this tutorial from our main Python installation. "
"If we install packages into the virtual environment, our main Python "
"installation (and any other Python projects on our computer) won't be "
"affected. If we make a complete mess of our virtual environment, we'll be "
"able to simply delete it and start again, without affecting any other Python"
" project on our computer, and without the need to re-install Python."
msgstr ""
"我们现在要创建一个虚拟环境--一个 \"沙箱\"，用来将本教程的工作与我们的主 Python 安装隔离开来。如果我们将软件包安装到虚拟环境中，我们的主 "
"Python 安装（以及计算机上的任何其他 Python "
"项目）将不会受到影响。如果我们把虚拟环境弄得一团糟，我们可以简单地删除它，然后重新开始，不会影响计算机上的任何其他 Python 项目，也不需要重新安装"
" Python。"

#: docs/en/tutorial/tutorial-0.md:137
msgid ""
"If you're not using Python 3.12, replace the `-3.12` in these instructions "
"with the version number that you are using."
msgstr "如果您不在使用 Python 3.12，将指示中的 `-3.12` 替换为您在使用的版本号。"

#: docs/en/tutorial/tutorial-0.md:139
#, fuzzy
msgid "/// admonition | Errors running PowerShell Scripts"
msgstr "/// admonition |运行 PowerShell 脚本时出现的错误"

#: docs/en/tutorial/tutorial-0.md:141
msgid "If you're using PowerShell, and you receive the error:"
msgstr "如果使用 PowerShell 时收到以下错误信息:"

#: docs/en/tutorial/tutorial-0.md:147
#, fuzzy
msgid ""
"Your Windows account doesn't have permission to run scripts. To fix this:"
msgstr "您的 Windows 账户没有运行脚本的权限。要解决这个问题"

#: docs/en/tutorial/tutorial-0.md:149
msgid "Run [Windows PowerShell as Administrator]{1}."
msgstr "[以管理员身份运行 PowerShell]{1}."

#: docs/en/tutorial/tutorial-0.md:150
msgid "Run `set-executionpolicy RemoteSigned`"
msgstr "运行 `set-executionpolicy RemoteSigned`"

#: docs/en/tutorial/tutorial-0.md:151
msgid "Select `Y` to change the execution policy."
msgstr "选择 `Y` 更改执行策略。"

#: docs/en/tutorial/tutorial-0.md:153
msgid ""
"Once you've done this you can rerun `beeware-venv\\Scripts\\activate.ps1` in"
" your original PowerShell session (or a new session in the same directory)."
msgstr ""
"完成后，您就可以在原来的 PowerShell 会话（或同一目录下的新会话）中重新运行 `beeware-"
"venv\\scripts\\activate.ps1`。"

#: docs/en/tutorial/tutorial-0.md:159
msgid ""
"If this worked, your prompt should now be changed - it should have a "
"`(beeware-venv)` prefix. This lets you know that you're currently in your "
"BeeWare virtual environment. Whenever you're working on this tutorial, you "
"should make sure your virtual environment is activated. If it isn't, re-run "
"the last command (the `activate` command) to re-activate your environment."
msgstr ""
"如果这样做成功了，您的提示符现在应该有所改变--它会带有 `(beeware-venv)` 前缀。这样，您就可以知道您当前正处于 BeeWare "
"虚拟环境中。无论何时运行本教程，都应确保虚拟环境已激活。如果没有激活，请重新执行前一条命令（`activate`）以重新激活虚拟环境。"

#: docs/en/tutorial/tutorial-0.md:161
#, fuzzy
msgid "/// admonition | Alternative virtual environments"
msgstr "/// admonition |替代虚拟环境"

#: docs/en/tutorial/tutorial-0.md:163
#, fuzzy
msgid ""
"If you're using Anaconda or miniconda, you may be more familiar with using "
"conda environments. You might also have heard of `virtualenv`, a predecessor"
" to Python's built in `venv` module. As with Python installs -if you're on "
"macOS or Windows, it doesn't matter *how* you create your virtual "
"environment, as long as you have one. If you're on Linux, you should stick "
"to `venv` and the system Python."
msgstr ""
"如果您使用的是 Anaconda 或 miniconda，您可能更熟悉使用 conda 环境。您可能还听说过 `virtualenv`，它是 "
"Python 内置的 `venv` 模块的前身。就像 Python 的安装一样，如果你使用的是 macOS 或 "
"Windows，那么如何创建虚拟环境并不重要，只要有一个就够了。如果您在 Linux 上，则应坚持使用 `venv` 和系统 Python。"

#: docs/en/tutorial/tutorial-0.md:167 docs/en/tutorial/tutorial-1.md:213
#: docs/en/tutorial/tutorial-2.md:301 docs/en/tutorial/tutorial-3.md:463
#: docs/en/tutorial/tutorial-4.md:232
#: docs/en/tutorial/tutorial-5/android.md:343
#: docs/en/tutorial/tutorial-5/iOS.md:123 docs/en/tutorial/tutorial-6.md:149
#: docs/en/tutorial/tutorial-7.md:630 docs/en/tutorial/tutorial-8.md:255
msgid "Next steps"
msgstr "下一步"

#: docs/en/tutorial/tutorial-0.md:169
#, fuzzy
msgid ""
"We've now set up our environment. We're ready to [create our first BeeWare "
"application]{1}."
msgstr "现在我们已经设置好了环境。我们已经准备创建\\ [您的第一个应用程序]{1}\\ 了。"

#: docs/en/tutorial/tutorial-1.md:1
#, fuzzy
msgid "Tutorial 1 - Your first app"
msgstr "教程 1 - 您的第一个应用程序"

#: docs/en/tutorial/tutorial-1.md:3
msgid "We're ready to create our first application."
msgstr "我们准备好创建我们的第一个应用程序了。"

#: docs/en/tutorial/tutorial-1.md:5
msgid "Install the BeeWare tools"
msgstr "安装 BeeWare 工具"

#: docs/en/tutorial/tutorial-1.md:7
#, fuzzy
msgid ""
"First, we need to install **Briefcase**. Briefcase is a BeeWare tool that "
"can be used to package your application for distribution to end users - but "
"it can also be used to bootstrap a new project. Make sure you're in the "
"`beeware-tutorial` directory you created in [Tutorial 0]{1}, with the "
"`beeware-venv` virtual environment activated, and run:"
msgstr ""
"首先，我们需要安装 **Briefcase**。Briefcase 是一款 BeeWare "
"工具，可用于打包应用程序，以便分发给最终用户；但它也可用于引导新项目。确保您在 [教程0]{1} 中创建的 `beeware-tutorial` "
"目录中，并已激活 `beeware-venv` 虚拟环境，然后运行："

#: docs/en/tutorial/tutorial-1.md:23 docs/en/tutorial/tutorial-1.md:37
#, fuzzy
msgid "/// admonition | Possible errors during installation"
msgstr "/// admonition |安装过程中可能出现的错误"

#: docs/en/tutorial/tutorial-1.md:25
#, fuzzy
msgid ""
"If you see errors during installation, it's almost certainly because some of"
" the system requirements haven't been installed. Make sure you have "
"[installed all the platform pre-requisites][install-dependencies]."
msgstr ""
"如果在安装过程中出现错误，几乎可以肯定是因为某些系统要求尚未安装。请确保已[安装所有平台先决条件][install-dependencies]。"

#: docs/en/tutorial/tutorial-1.md:39
msgid ""
"It is important that you use `python -m pip`, rather than a bare `pip`. "
"Briefcase needs to ensure that it has an up-to-date version of `pip` and "
"`setuptools`, and a bare invocation of `pip` can't self-update. If you want "
"to know more, [Brett Cannon has a detailed blog post about the issue]{1}."
msgstr ""
"请务必使用 `python -m pip`，而不是简单的 `pip`。Briefcase 需要确保它拥有最新版本的 `pip` 和 "
"`setuptools` ，而裸调用的 `pip` 无法自我更新。如果您想了解更多，[Brett Cannon 有一篇关于这个问题的详细博文]{1}。"

#: docs/en/tutorial/tutorial-1.md:45
msgid "Bootstrap a new project"
msgstr "引导新项目"

#: docs/en/tutorial/tutorial-1.md:47
#, fuzzy
msgid ""
"Let's start our first BeeWare project! We're going to use the Briefcase "
"`new` command to create an application called **Hello World**. Run the "
"following from your command prompt:"
msgstr ""
"让我们开始第一个 BeeWare 项目！我们将使用 Briefcase `new` 命令创建一个名为 **Hello World** "
"的应用程序。在命令提示符下运行以下命令"

#: docs/en/tutorial/tutorial-1.md:73
msgid ""
"Briefcase will ask us for some details of our new application. For the "
"purposes of this tutorial, use the following:"
msgstr "Briefcase会要求我们提供新应用程序的一些详细信息。在本教程中，请使用以下内容："

#: docs/en/tutorial/tutorial-1.md:75
msgid "**Formal Name** - Accept the default value: `Hello World`."
msgstr "**Formal Name** - 接受默认值：`Hello World`。"

#: docs/en/tutorial/tutorial-1.md:76
msgid "**App Name** - Accept the default value: `helloworld`."
msgstr "**App Name** - 接受默认值：`helloworld`。"

#: docs/en/tutorial/tutorial-1.md:77
msgid ""
"**Bundle Identifier** - If you own your own domain, enter that domain in "
"reversed order. (For example, if you own the domain \"cupcakes.com\", enter "
"`com.cupcakes` as the bundle). If you don't own your own domain, accept the "
"default bundle (`com.example`)."
msgstr ""
"**Bundle Identifier（捆绑标识符）** - 如果您拥有自己的域名，请按相反顺序输入该域名。(例如，如果您拥有域名 "
"\"cupcakes.com\"，则输入 `com.cupcakes` "
"作为捆绑标识符）。如果您没有自己的域名，请接受默认值（`com.example`）。"

#: docs/en/tutorial/tutorial-1.md:78
msgid "**Project Name** - Accept the default value: `Hello World`."
msgstr "**Project Name** - 接受默认值：`Hello World`。"

#: docs/en/tutorial/tutorial-1.md:79
msgid ""
"**Description** - Accept the default value (or, if you want to be really "
"creative, come up with your own description!)"
msgstr "**描述** - 接受默认值（或者，如果您想发挥自己的创造力，也可以提出自己的描述！）"

#: docs/en/tutorial/tutorial-1.md:80
msgid "**Author** - Enter your own name here."
msgstr "**Author** - 在此处输入您自己的名字。"

#: docs/en/tutorial/tutorial-1.md:81
msgid ""
"**Author's Email** - Enter your own email address. This will be used in the "
"configuration file, in help text, and anywhere that an email is required "
"when submitting the app to an app store."
msgstr ""
"**Author's Email** - 输入您自己的电子邮件地址。这将用于配置文件、帮助文本以及向应用程序商店提交应用程序时需要电子邮件的任何地方。"

#: docs/en/tutorial/tutorial-1.md:82
msgid ""
"**Application URL** - The URL of the landing page for your application. "
"Again, if you own your own domain, enter a URL at that domain (including the"
" `https://`). Otherwise, just accept the default URL "
"(`https://example.com/helloworld`). This URL doesn't need to actually exist "
"(for now); it will only be used if you publish your application to an app "
"store."
msgstr ""
"**URL** - 应用程序登陆页面的 URL。同样，如果您拥有自己的域名，请输入该域名的 URL（包括 `https://`）。否则，接受默认 URL"
" (`https://example.com/helloworld`) 即可。此 "
"URL（暂时）不需要实际存在；只有在您将应用程序发布到应用程序商店时才会使用。"

#: docs/en/tutorial/tutorial-1.md:83
msgid ""
"**Project License** - Accept the default license (BSD). This won't affect "
"anything about the operation of the tutorial, though - so if you have "
"particularly strong feelings about license choice, feel free to choose "
"another license."
msgstr ""
"**Project License** (项目许可证) - "
"接受默认许可证（BSD）。这不会影响本教程的任何操作，因此，如果您对许可证选择有特别强烈的意见，请随意选择其他许可证。"

#: docs/en/tutorial/tutorial-1.md:84
msgid ""
"**GUI framework** - Accept the default option, Toga (BeeWare's own GUI "
"toolkit)."
msgstr "**GUI Framework** - 接受默认选项 Toga（BeeWare 自己的图形用户界面工具包）。"

#: docs/en/tutorial/tutorial-1.md:86
msgid ""
"Briefcase will then generate a project skeleton for you to use. If you've "
"followed this tutorial so far, and accepted the defaults as described, your "
"file system should look something like:"
msgstr ""
"接下来，Briefcase 会生成一个项目骨架供你使用。如果你到目前为止都已经跟着这个教程走的话，并接受了所述的默认设置，那么你的文件系统应该是这样的:"

#: docs/en/tutorial/tutorial-1.md:110
msgid ""
"This skeleton is actually a fully functioning application without adding "
"anything else. The `src` folder contains all the code for the application, "
"the `tests` folder contains an initial test suite, and the `pyproject.toml` "
"file describes how to package the application for distribution. If you open "
"`pyproject.toml` in an editor, you'll see the configuration details you just"
" provided to Briefcase."
msgstr ""
"该骨架实际上是一个功能完备的应用程序，无需添加任何其他内容。`src` 文件夹包含应用程序的所有代码，`tests` "
"文件夹包含初始测试套件，`pyproject.toml` 文件描述了如何打包发布应用程序。如果您用编辑器打开 "
"`pyproject.toml`，就会看到刚才提供给 Briefcase 的配置详细信息。"

#: docs/en/tutorial/tutorial-1.md:112
msgid ""
"Now that we have a stub application, we can use Briefcase to run the "
"application."
msgstr "现在我们有了一个包含占位代码的应用程序，可以使用 Briefcase 来运行它。"

#: docs/en/tutorial/tutorial-1.md:114
msgid "Run the app in developer mode"
msgstr "在开发者模式下运行应用程序"

#: docs/en/tutorial/tutorial-1.md:116
msgid ""
"Move into the `helloworld` project directory and tell briefcase to start the"
" project in Developer (or `dev`) mode:"
msgstr "移动到 `helloworld` 项目目录，告诉 Briefcase 以开发者（或 `dev`）模式启动项目："

#: docs/en/tutorial/tutorial-1.md:163 docs/en/tutorial/tutorial-2.md:265
msgid "This should open a GUI window:"
msgstr "这将打开一个图形用户界面 (GUI) 窗口："

#: docs/en/tutorial/tutorial-1.md:167
#, fuzzy
msgid "![Hello World Tutorial 1 window, on macOS]{1}"
msgstr "Hello World 教程 1 窗口，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-1.md:177
#, fuzzy
msgid "![Hello World Tutorial 1 window, on Linux]{1}"
msgstr "![Hello World 教程 1 窗口，在 Linux 上]{1}!"

#: docs/en/tutorial/tutorial-1.md:187
#, fuzzy
msgid "![Hello World Tutorial 1 window, on Windows]{1}"
msgstr "![Hello World 教程 1 窗口，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-1.md:193
#, fuzzy
msgid "/// admonition | Invalid requirements or pip unable to connect"
msgstr "/// admonition |无效要求或 pip 无法连接"

#: docs/en/tutorial/tutorial-1.md:195
msgid "If you encounter the error:"
msgstr "如果您遇到错误："

#: docs/en/tutorial/tutorial-1.md:203
#, fuzzy
msgid ""
"Confirm that you are running a [version of python that this tutorial "
"supports][install-python]."
msgstr "确认运行的是[本教程支持的 python 版本][install-python]。"

#: docs/en/tutorial/tutorial-1.md:205
msgid ""
"If your version of python is *not* a supported version, you will have to "
"restart the tutorial."
msgstr "如果您的 Python 版本*不*被支持，则需重新开始本教程。"

#: docs/en/tutorial/tutorial-1.md:211
msgid ""
"Close the application - either by pressing the close button on the "
"application window, by selecting Quit/Exit from the application's menu, or "
"by typing **Ctrl+C** in the terminal where you ran `briefcase dev` - and "
"you're done! Congratulations - you've just written a standalone, native "
"application in Python!"
msgstr ""
"关闭应用程序 -- 可以使用应用程序窗口上的关闭按钮、从应用程序的菜单栏选择关闭/退出、或在您运行 `briefcase dev` 的命令行窗口中按 "
"**Ctrl+C** -- 就完成了！恭喜您，您刚刚使用 Python 编写了一个独立、原生的应用程序！"

#: docs/en/tutorial/tutorial-1.md:215
#, fuzzy
msgid ""
"We now have a working application, running in developer mode. Now we can add"
" some logic of our own to make our application do something a little more "
"interesting. In [Tutorial 2]{1}, we'll put a more useful user interface onto"
" our application."
msgstr ""
"现在，我们有了一个在开发者模式下运行的应用程序。现在我们可以添加一些自己的逻辑，让应用程序做更有趣一些的事情。在\\ :doc:`教程 "
"2<tutorial-2>` 中，我们将为应用程序添加一个更有用的用户界面。"

#: docs/en/tutorial/tutorial-2.md:1
#, fuzzy
msgid "Tutorial 2 - Making it interesting"
msgstr "教程 2 - 使之更有趣"

#: docs/en/tutorial/tutorial-2.md:3
#, fuzzy
msgid ""
"In [Tutorial 1]{1}, we generated a stub project that was able to run, but we"
" didn't write any code ourselves. Let's take a look at what was generated "
"for us."
msgstr ""
"在 [教程 1<tutorial-1>` 中，我们生成了一个可以运行的基础项目，但我们自己并没有编写任何代码。让我们看看 Briefcase "
"为我们生成了什么。"

#: docs/en/tutorial/tutorial-2.md:5
msgid "What was generated"
msgstr "生成的内容"

#: docs/en/tutorial/tutorial-2.md:7
msgid ""
"In the `src/helloworld` directory, you should see 3 files: `__init__.py`, "
"`__main__.py` and `app.py`."
msgstr ""
"在 `src/helloworld` 目录中，你应该看到 3 个文件：`__init__.py`、`__main__.py` 和 `app.py`。"

#: docs/en/tutorial/tutorial-2.md:9
msgid ""
"`__init__.py` marks the `helloworld` directory as an importable Python "
"module. It is an empty file; the very fact it exists tells the Python "
"interpreter that the `helloworld` directory defines a module."
msgstr ""
"`__init__.py` 将 `helloworld` 目录标记为可导入的 Python 模块。这是一个空文件；它的存在告诉 Python 解释器 "
"helloworld 目录定义了一个模块。"

#: docs/en/tutorial/tutorial-2.md:11
#, fuzzy
msgid ""
"`__main__.py` marks the `helloworld` module as a special kind of module -an "
"executable module. If you try to run the `helloworld` module using `python "
"-m helloworld`, the `__main__.py` file is where Python will start executing."
" The contents of `__main__.py` is relatively simple:"
msgstr ""
"`__main__.py` 将 `helloworld` 模块标记为一种特殊的模块 - 可执行模块。如果使用 `python -m "
"helloworld` 试图运行 `helloworld` 模块，`__main__.py` 文件就是 Python "
"开始执行的地方。`__main__.py` 的内容相对简单："

#: docs/en/tutorial/tutorial-2.md:20
msgid "This file does two things:"
msgstr "此文件做以下两件事："

#: docs/en/tutorial/tutorial-2.md:22
#, fuzzy
msgid "It imports the `main` method from the `helloworld` app."
msgstr "它从 `helloworld` 应用程序导入了 `main` 方法。"

#: docs/en/tutorial/tutorial-2.md:23
msgid ""
"Then, it starts the application’s main loop. The main loop is the way a GUI "
"application listens for user input (like mouse clicks and keyboard presses)."
msgstr "然后，它会开始应用程序的主循环，以便侦听用户输入（例如鼠标点击或键盘按键）。"

#: docs/en/tutorial/tutorial-2.md:25
msgid ""
"The more interesting file is `app.py` - this contains the logic that creates"
" our application window:"
msgstr "更有趣的文件是 `app.py` - 它包含创建我们应用程序窗口的逻辑:"

#: docs/en/tutorial/tutorial-2.md:43
msgid "Let's go through this line by line:"
msgstr "让我们逐行查看:"

#: docs/en/tutorial/tutorial-2.md:50
msgid ""
"First, we import the `toga` widget toolkit, as well as some style-related "
"utility constants. Our code doesn't use these yet - but we'll make use of "
"them shortly."
msgstr "首先，我们导入 `toga` 控件工具包，以及一些与样式相关的实用常量。目前我们的代码还没有使用这些——但我们很快就会用到它们。"

#: docs/en/tutorial/tutorial-2.md:52
msgid "Then, we define a class:"
msgstr "然后，我们定义了一个类 :"

#: docs/en/tutorial/tutorial-2.md:58
msgid ""
"Each Toga application has a single `toga.App` instance, representing the "
"running entity that is the application. The app may end up managing multiple"
" windows; but for simple applications, there will be a single main window."
msgstr ""
"每个 Toga 应用程序都有一个 `toga.App` "
"实例，代表应用程序的运行实体。应用程序最终可能会管理多个窗口；但是对于简单的应用程序来说，可能只有一个主窗口。"

#: docs/en/tutorial/tutorial-2.md:60
msgid "Next, we define a `startup()` method:"
msgstr "接下来，我们定义一个 `startup()` 方法 (startup意为启动):"

#: docs/en/tutorial/tutorial-2.md:67
msgid ""
"The first thing the startup method does is to define a main box. Toga's "
"layout scheme behaves similar to HTML. You build an application by "
"constructing a collection of boxes, each of which contains other boxes, or "
"actual widgets. You then apply styles to these boxes to define how they will"
" consume the available window space."
msgstr ""
"startup 方法的第一件事是定义一个主盒子 (main box)。Toga 的布局方案类似于 HTML。你通过构造一系列盒子 (box) "
"来构建应用程序，每个盒子包含其他盒子或实际的控件 (widgets)。然后，你对这些盒子应用样式 (styles)，以定义它们将如何消耗可用的窗口空间 "
"(window space)。"

#: docs/en/tutorial/tutorial-2.md:69
msgid ""
"In this application, we define a single box, but we don't put anything into "
"it."
msgstr "在这个应用程序中，我们定义了一个单独的空盒子 (我们没有放任何东西进去)。"

#: docs/en/tutorial/tutorial-2.md:71
msgid "Next, we define a window into which we can put this empty box:"
msgstr "接下来，我们定义一个可以将这个空盒子放入其中的窗口:"

#: docs/en/tutorial/tutorial-2.md:77
msgid ""
"This creates an instance of a `toga.MainWindow`, which will have a title "
"matching the application's name. A Main Window is a special kind of window "
"in Toga - it's a window that is closely bound to the life cycle of the app. "
"When the Main Window is closed, the application exits. The Main Window is "
"also the window that has the application's menu (if you're on a platform "
"like Windows where menu bars are part of the window)."
msgstr ""
"这将创建一个 `toga.MainWindow` 的实例，它的标题 (title) 将与应用程序的名称 (self.formal_name) "
"匹配。主窗口是 Toga 中的一种特殊窗口——它与应用程序的生命周期 (life cycle) "
"密切绑定。主窗口关闭，应用程序就退出了。主窗口也具有应用程序菜单（例如类似 Windows 这样的平台上，菜单栏是窗口的一部分）。"

#: docs/en/tutorial/tutorial-2.md:79
#, fuzzy
msgid "/// admonition | Where is my window?"
msgstr "/// admonition |我的窗户在哪里？"

#: docs/en/tutorial/tutorial-2.md:81
msgid ""
"If you have made an error in your code, the main window of the app may not "
"display. If this happens, you can type **Ctrl+C** in the terminal where you "
"started the app. This will stop the app. You can then fix the error and "
"restart the app."
msgstr ""
"如果你写的代码中有错误，app的主窗口可能不会显示。要是真这样了，你可以找到先前启动app的终端窗口，并在其中按下\\ **Ctrl + "
"C**，以终止app运行。之后，你就可以修改代码里的错误，再重启app。"

#: docs/en/tutorial/tutorial-2.md:85
msgid ""
"We then add our empty box as the content of the main window, and instruct "
"the application to show our window:"
msgstr "然后，我们将空盒子作为主窗口的内容，并指示应用程序显示我们的窗口:"

#: docs/en/tutorial/tutorial-2.md:92
msgid ""
"Last of all, we define a `main()` function. This is what creates the "
"instance of our application:"
msgstr "最后，我们定义一个 `main()` 方法。它将创建应用程序的实例:"

#: docs/en/tutorial/tutorial-2.md:99
msgid ""
"This `main()` method is the one that is imported and invoked by "
"`__main__.py`. It creates and returns an instance of our `HelloWorld` "
"application."
msgstr "这个 `main()` 方法由 `__main__.py` 导入并调用。它创建并返回我们的 `HelloWorld` 应用程序的实例。"

#: docs/en/tutorial/tutorial-2.md:101
msgid ""
"That's the simplest possible Toga application. Let's put some of our own "
"content into the application, and make the app do something interesting."
msgstr "这是最简单可能的 Toga 应用程序。接下来，让我们在应用程序中加入一些我们自己的内容，使应用程序做一些有趣的事情。"

#: docs/en/tutorial/tutorial-2.md:103
msgid "Adding some content of our own"
msgstr "添加一些我们自己的内容"

#: docs/en/tutorial/tutorial-2.md:105
msgid "Let's do something more interesting with our `HelloWorld` app."
msgstr "对我们的 `HelloWorld` 应用程序，做些更有意思的事吧。"

#: docs/en/tutorial/tutorial-2.md:109
msgid ""
"When you make these changes, make sure you keep the imports at the top of "
"the file, and the `main()` at the bottom of the file. You only need to "
"update the `HelloWorld` class."
msgstr ""
"在做这些更改时，确保不要删除文件顶部的导入 (imports)，也不要删除底部的 `main()`。您只需更新 `HelloWorld` 类。"

#: docs/en/tutorial/tutorial-2.md:113
msgid ""
"Modify your `HelloWorld` class inside `src/helloworld/app.py` so that it "
"looks like this:"
msgstr "修改 `src/helloworld/app.py` 中的 `HelloWorld` 类，使其看起来像这样:"

#: docs/en/tutorial/tutorial-2.md:147
msgid "Let's look in detail at what has changed."
msgstr "让我们详细看看有哪些变化。"

#: docs/en/tutorial/tutorial-2.md:149
msgid "We're still creating a main box; however, we are now applying a style:"
msgstr "我们仍然在创建一个主盒子；然而，现在我们正在应用一个样式:"

#: docs/en/tutorial/tutorial-2.md:155
msgid ""
"Toga's built-in layout system is called \"Pack\". It behaves a lot like CSS."
" You define objects in a hierarchy - in HTML, the objects are `<div>`, "
"`<span>`, and other DOM elements; in Toga, they're widgets and boxes. You "
"can then assign styles to the individual elements. In this case, we're "
"indicating that this is a `COLUMN` box - that is, it is a box that will "
"consume all the available width, and will expand its height as content is "
"added, but it will try to be as short as possible."
msgstr ""
"Toga 的内置布局系统称为 \"Pack\" (包)。它的行为很像 CSS (Cascading Style Sheets "
"层叠样式表)。你可以在一个层次结构中定义对象--在 HTML 中，对象是 `<div>` (division 块级容器)、`<span>` "
"(inline span 内联容器) 和其他 DOM (Document Object Model 文档对象模型) 元素；在 Toga 中，对象是控件 "
"(widgets ) 和盒子 (boxes)。然后，您可以为各个元素指定样式。在本例中，我们表示这是一个 `COLUMN` (垂直) "
"框，也就是说，它是一个将占用所有可用宽度 (width) 的框，并会随着内容的添加而扩大高度 (height)，但会尽量使高度更短。"

#: docs/en/tutorial/tutorial-2.md:159
msgid ""
"For more advanced uses, Toga also supports a separate style object, which is"
" used like this:"
msgstr "对于更高级的使用，Toga 也支持可以被这样使用的单独的样式对象:"

#: docs/en/tutorial/tutorial-2.md:168
msgid "Next, we define a couple of widgets:"
msgstr "接下来，我们定义了一些控件:"

#: docs/en/tutorial/tutorial-2.md:178
msgid ""
"Here, we define a Label and a TextInput. Both widgets have styles associated"
" with them; the label will have 5px of margin on its left and right, and no "
"margin on the top and bottom. The TextInput is marked as being flexible - "
"that is, it will absorb all available space in its layout axis."
msgstr ""
"在这里，我们定义了一个标签 (Label) 和一个文本输入框 (TextInput)。这两个控件都有与其相关的样式；标签左右会各有 5px "
"的填充，上下没有填充。文本输入框是被标记为灵活的——也就是说，它将吸收其布局方向上所有可用的空间。"

#: docs/en/tutorial/tutorial-2.md:180
msgid ""
"The TextInput is assigned as an instance variable of the class. This gives "
"us easy access to the widget instance - something that we'll use in a "
"moment."
msgstr ""
"文本输入框 (TextInput) 被分配为类的实例变量。这使我们能够轻松访问控件 (widget) 实例 - 这是我们马上就会使用的东西。"

#: docs/en/tutorial/tutorial-2.md:182
msgid "Next, we define a box to hold these two widgets:"
msgstr "接下来，我们定义了一个盒子来容纳这两个控件:"

#: docs/en/tutorial/tutorial-2.md:190
msgid ""
"The `name_box` is a box just like the main box; however, this time, it's a "
"`ROW` box. That means content will be added horizontally, and it will try to"
" make its width as narrow as possible. The box also has some margin - 5px on"
" all sides."
msgstr ""
"`name_box` 就像主盒子一样；然而，这次它是一个 `ROW` (水平) "
"盒子。这意味着内容将会被水平添加，并且它会尽量使其宽度尽可能窄。盒子也有一些空白填充——四周各为 5px。"

#: docs/en/tutorial/tutorial-2.md:192
msgid "Now we define a button:"
msgstr "现在，我们定义一个按钮:"

#: docs/en/tutorial/tutorial-2.md:202
#, fuzzy
msgid ""
"The button also has 5px of margin on all sides. We also define a *handler* -"
" a method to invoke when the button is pressed."
msgstr "按钮四边的边距也是 5px。我们还定义了一个 *handler* - 按钮按下时调用的方法。"

#: docs/en/tutorial/tutorial-2.md:204
msgid "Then, we add the name box and the button to the main box:"
msgstr "然后，我们将 name box 和按钮添加到主盒子中:"

#: docs/en/tutorial/tutorial-2.md:211
msgid ""
"This completes our layout; the rest of the startup method is as it was "
"previously - defining a `MainWindow`, and assigning the main box as the "
"window's content:"
msgstr "这完成了我们的布局；其余的 startup 方法与以前一样 - 定义一个 `MainWindow` ，并将主盒子指定为窗口的内容:"

#: docs/en/tutorial/tutorial-2.md:219
msgid ""
"The last thing we need to do is define the handler for the button. A handler"
" can be any method, generator, or asynchronous coroutine; it accepts the "
"widget that generated the event as an argument, and will be invoked whenever"
" the button is pressed:"
msgstr ""
"我们需要做的最后一件事，就是定义按钮的处理器(handler)——它可以是任何方法、生成器或异步协程，且接受生成事件的控件 (widget) "
"作为参数。只要按下按钮，就会调用这些处理器:"

#: docs/en/tutorial/tutorial-2.md:226
msgid ""
"The body of the method is a simple print statement - however, it will "
"interrogate the current value of the name input, and use that content as the"
" text that is printed."
msgstr "方法的主体是一个简单的打印语句——然而，它会使用名称输入的当前值，并使用该内容作为打印的文本。"

#: docs/en/tutorial/tutorial-2.md:228
msgid ""
"Now that we've made these changes we can see what they look like by starting"
" the application again. As before, we'll use developer mode:"
msgstr "现在我们已经做了这些更改，我们可以通过再次启动应用程序来看看它们的样子。和以前一样，我们将使用开发者模式："

#: docs/en/tutorial/tutorial-2.md:263
msgid ""
"You'll notice that this time, it *doesn't* install dependencies. Briefcase "
"can detect that the application has been run before, and to save time, will "
"only run the application. If you add new dependencies to your app, you need "
"to make sure that they're installed by passing in a `-r` option when you run"
" `briefcase dev`."
msgstr ""
"你会注意到，这次\\ *没有*\\ 安装依赖项。Briefcase 可以检测到已经被运行过的应用程序 -- "
"为了节省时间，它只会运行应用程序，而不会安装依赖项。如果你在应用程序中添加了新的依赖项，你可以在运行 `briefcase dev` 时通过 `-r` "
"选项来确保它们被安装。"

#: docs/en/tutorial/tutorial-2.md:269
#, fuzzy
msgid "![Hello World Tutorial 2 window, on macOS]{1}"
msgstr "Hello World 教程 2 窗口，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-2.md:279
#, fuzzy
msgid "![Hello World Tutorial 2 window, on Linux]{1}"
msgstr "![Hello World 教程 2 窗口，在 Linux 上]{1}!"

#: docs/en/tutorial/tutorial-2.md:289
#, fuzzy
msgid "![Hello World Tutorial 2 window, on Windows]{1}"
msgstr "![Hello World 教程 2 窗口，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-2.md:297
msgid ""
"If you enter a name in the text box, and press the GUI button, you should "
"see output appear in the console where you started the application."
msgstr "如果在文本框中输入名称，并按下图形用户界面中的按钮，就会在启动程序的控制台中看到输出结果。"

#: docs/en/tutorial/tutorial-2.md:299
msgid ""
"Before continuing, close the app. As with Tutorial 1, you can do this by "
"pressing the close button on the application window, by selecting Quit/Exit "
"from the application's menu, or by typing **Ctrl+C** in the terminal where "
"you ran `briefcase dev`."
msgstr ""
"在继续之前，关闭应用程序。和教程 1 一样，您可以使用应用程序窗口上的关闭按钮、从应用程序的菜单栏选择关闭/退出、或在您运行 `briefcase "
"dev` 的命令行窗口中按 **Ctrl+C** 以关闭应用程序。"

#: docs/en/tutorial/tutorial-2.md:303
#, fuzzy
msgid ""
"We've now got an application that does something a little more interesting. "
"But it only runs on our own computer. Let's package this application for "
"distribution. In [Tutorial 3]{1}, we'll wrap our application up as a "
"standalone installer that we could send to a friend, a customer, or upload "
"to an App Store."
msgstr ""
"我们现在有了一个应用程序，它能做一些更有趣的事情。但它只能在我们自己的电脑上运行。让我们将应用程序打包，以便发布。在 [教程 "
"3]{1}中，我们将把应用程序打包成一个独立的安装程序，发送给朋友、客户或上传到应用程序商店。"

#: docs/en/tutorial/tutorial-3.md:1
#, fuzzy
msgid "Tutorial 3 - Packaging for distribution"
msgstr "教程 3 - 打包与分发"

#: docs/en/tutorial/tutorial-3.md:3
msgid ""
"So far, we've been running our application in \"Developer mode\". This makes"
" it easy for us to run our application locally - but what we really want is "
"to be able to give our application to others."
msgstr ""
"到目前为止，我们一直在“开发者模式”下运行应用程序。这可以让我们轻松地在本地运行应用程序，但我们真正想要的是能将我们的应用程序提供给其他人。"

#: docs/en/tutorial/tutorial-3.md:5
msgid ""
"However, we don't want to have to teach our users how to install Python, "
"create a virtual environment, clone a git repository, and run Briefcase in "
"developer mode. We'd rather just give them an installer, and have the "
"application Just Work."
msgstr ""
"但是，我们不想教用户怎样安装 Python、创建虚拟环境、克隆 git 仓库和在开发者模式下运行 "
"Briefcase。我们宁可只给他们一个安装程序，让应用程序能够正常运行。"

#: docs/en/tutorial/tutorial-3.md:7
msgid ""
"Briefcase can be used to package your application for distribution in this "
"way."
msgstr "Briefcase 可用于打包应用程序，以便以这种方式发布。"

#: docs/en/tutorial/tutorial-3.md:9
msgid "Creating your application scaffold"
msgstr "创建应用程序脚手架"

#: docs/en/tutorial/tutorial-3.md:11
msgid ""
"Since this is the first time we're packaging our application, we need to "
"create some configuration files and other scaffolding to support the "
"packaging process. From the `helloworld` directory, run:"
msgstr "由于这是我们第一次打包应用程序，我们需要创建一些配置文件和其他脚手架来支持打包过程。在 `helloworld` 目录中，运行:"

#: docs/en/tutorial/tutorial-3.md:75
#, fuzzy
msgid "/// admonition | Errors about Python versions"
msgstr "/// admonition |有关 Python 版本的错误"

#: docs/en/tutorial/tutorial-3.md:77
msgid "If you receive an error that reads something like:"
msgstr "如果您收到类似如下的错误信息："

#: docs/en/tutorial/tutorial-3.md:79
msgid ""
"The version of Python being used to run Briefcase (3.12) is not the system "
"python3 (3.10)."
msgstr "用于运行 Briefcase 的 Python 版本 (3.12) 不是系统 python3 (3.10)。"

#: docs/en/tutorial/tutorial-3.md:82
msgid ""
"You will need to recreate your virtual environment using the system "
"`python3`. Using the system Python is a requirement for packaging your "
"application."
msgstr "您将需要使用系统的 `python3` 重新创建您的虚拟环境。打包您的应用程序要求使用系统 Python。"

#: docs/en/tutorial/tutorial-3.md:114
msgid ""
"You've probably just seen pages of content go past in your terminal... so "
"what just happened? Briefcase has done the following:"
msgstr "您可能刚刚在终端上看到了几页内容滑过......刚刚发生了什么？Briefcase 做了以下工作："

#: docs/en/tutorial/tutorial-3.md:116
#, fuzzy
msgid ""
"It **generated an application template**. There's a lot of files and "
"configurations required to build a native installer, above and beyond the "
"code of your actual application. This extra scaffolding is almost the same "
"for every application on the same platform, except for the name of the "
"actual application being constructed - so Briefcase provides an application "
"template for each platform it supports. This step rolls out the template, "
"substituting the name of your application, bundle ID, and other properties "
"of your configuration file as required to support the platform you're "
"building on. If you're not happy with the template provided by Briefcase, "
"you can provide your own. However, you probably don't want to do this until "
"you've got a bit more experience using Briefcase's default template."
msgstr ""
"它**生成一个应用程序模板**。除了实际应用程序的代码之外，构建本机安装程序还需要许多文件和配置。这些额外的脚手架对于同一平台上的每个应用程序几乎都是一样的，除了正在构建的实际应用程序的名称"
"--因此，Briefcase 为其支持的每个平台提供了一个应用程序模板。这一步将推出模板，根据需要替换应用程序名称、捆绑 ID "
"和配置文件的其他属性，以支持正在构建的平台。如果对 Briefcase 提供的模板不满意，可以提供自己的模板。不过，在使用 Briefcase "
"的默认模板积累更多经验之前，您可能不想这样做。"

#: docs/en/tutorial/tutorial-3.md:118
#, fuzzy
msgid ""
"It **downloaded and installed a support package**. The packaging approach "
"taken by Briefcase is best described as \"the simplest thing that could "
"possibly work\" - it ships a complete, isolated Python interpreter as part "
"of every application it builds (except for Linux native system package "
"builds). This is slightly space inefficient - if you have 5 applications "
"packaged with Briefcase, you'll have 5 copies of the Python interpreter. "
"However, this approach guarantees that every application is completely "
"independent, using a specific version of Python that is known to work with "
"the application. Again, Briefcase provides a default support package for "
"each platform; if you want, you can provide your own support package, and "
"have that package included as part of the build process. You may want to do "
"this if you have particular options in the Python interpreter that you need "
"to have enabled, or if you want to strip modules out of the standard library"
" that you don't need at runtime. Briefcase maintains a local cache of "
"support packages, so once you've downloaded a specific support package, that"
" cached copy will be used on future builds. As noted above, when Briefcase "
"packages an app as a native Linux system package (the default package format"
" for Linux), a support package is not included with the app. Instead, the "
"app will use the Python that is provided by the distribution of Linux being "
"targeted."
msgstr ""
"它**下载并安装了一个支持包**。Briefcase 所采用的打包方法被描述为 \"最简单可行的方法\"--它将一个完整、独立的 Python "
"解释器作为其构建的每个应用程序的一部分（Linux 本机系统包构建除外）。这在空间利用上略显不足--如果有 5 个应用程序打包到 Briefcase "
"中，就会有 5 份 Python 解释器副本。但是，这种方法保证了每个应用程序都是完全独立的，使用的 Python "
"版本是已知的可与应用程序一起工作的特定版本。同样，Briefcase "
"为每个平台提供了默认的支持包；如果需要，您可以提供自己的支持包，并将该包作为构建过程的一部分。如果您需要启用 Python "
"解释器中的特定选项，或者如果您想从标准库中剥离运行时不需要的模块，您可能需要这样做。公文包会维护支持包的本地缓存，因此一旦下载了特定的支持包，该缓存副本将在未来的构建中使用。如上所述，当"
" Briefcase 将应用程序打包为本地 Linux 系统包（Linux 的默认包格式）时，支持包不会随应用程序一起提供。相反，应用程序将使用目标 "
"Linux 发行版提供的 Python。"

#: docs/en/tutorial/tutorial-3.md:120
msgid ""
"It **installed application requirements**. Your application can specify any "
"third-party modules that are required at runtime. These will be installed "
"using `pip` into your application's installer."
msgstr ""
"它\\ **安装应用程序的依赖项**。您的应用程序可以指定运行时所需的任何第三方模块。这些模块将会被用 `pip` 安装到应用程序的安装程序中。"

#: docs/en/tutorial/tutorial-3.md:122
msgid ""
"It **Installed your application code**. Your application will have its own "
"code and resources (e.g., images that are needed at runtime); these files "
"are copied into the installer."
msgstr "它\\ **安装您的应用程序代码**。您的应用程序将有自己的代码和资源（如运行时需要的图像）；这些文件会被复制到安装程序中。"

#: docs/en/tutorial/tutorial-3.md:124
msgid ""
"It **installed your resources needed by your application.** Lastly, it adds "
"any additional resources that are needed by the installer itself. This "
"includes things like icons that need to be attached to the final application"
" and splash screen images."
msgstr "最后，它还会\\ **添加安装程序本身所需的其他资源**。这包括需要附加到最终应用程序的图标和启动画面等。"

#: docs/en/tutorial/tutorial-3.md:126
msgid ""
"Once this completes, if you look in the project directory, you should now "
"see a directory corresponding to your platform (`macOS`, `linux`, or "
"`windows`) that contains additional files. This is the platform-specific "
"packaging configuration for your application."
msgstr ""
"完成上述操作后，如果查看项目目录，就会发现一个与平台（`macOS`, `linux`，或\\ "
"`windows`）相对应的目录，其中包含附加文件。这就是应用程序的平台具体的打包配置。"

#: docs/en/tutorial/tutorial-3.md:128
msgid "Building your application"
msgstr "构建您的应用程序"

#: docs/en/tutorial/tutorial-3.md:130
msgid ""
"You can now compile your application. This step performs any binary "
"compilation that is necessary for your application to be executable on your "
"target platform."
msgstr "现在可以编译应用程序了。此步骤将执行任何使应用程序在目标平台上可执行所必须的二进制编译。"

#: docs/en/tutorial/tutorial-3.md:145
msgid ""
"On macOS, the `build` command doesn't need to *compile* anything, but it "
"does need to sign the contents of binary so that it can be executed. This "
"signature is an *ad hoc* signature - it will only work on *your* machine; if"
" you want to distribute the application to others, you'll need to provide a "
"full signature."
msgstr ""
"在 macOS 上，` build`\\ 命令不需要\\ *编译*\\ 任何内容，但需要对二进制文件的内容进行（数字）签名，以便执行。这种签名是一种\\"
" *临时 (ad hoc)*\\ 签名--它只能在\\ *你的*\\ 机器上工作；如果你想将应用程序发布给其他人，就需要提供完整的签名。"

#: docs/en/tutorial/tutorial-3.md:175
msgid ""
"Once this step completes, the `build` folder will contain a "
"`helloworld-0.0.1` folder that contains a mirror of a Linux `/usr` file "
"system. This file system mirror will contain a `bin` folder with a "
"`helloworld` binary, plus `lib` and `share` folders needed to support the "
"binary."
msgstr ""
"此步骤完成后，[build`\\ 文件夹将包含一个\\ `helloworld-0.0.1`\\ 文件夹，其中包含一个 Linux `/usr` "
"文件系统的镜像。这个文件系统镜像将包含一个\\ `bin`\\ 文件夹，里面有一个\\ `helloworld`\\ "
"二进制文件，以及支持二进制文件所需的\\ `lib`\\ 和\\ `share`\\ 文件夹。"

#: docs/en/tutorial/tutorial-3.md:188
msgid ""
"On Windows, the `build` command doesn't need to *compile* anything, but it "
"does need to write some metadata so that the application knows its name, "
"version, and so on."
msgstr "在 Windows 上，`build` 命令不需要\\ *编译*\\ 任何东西，但它确实需要写入一些元数据，以便应用程序知道它的名称、版本等。"

#: docs/en/tutorial/tutorial-3.md:190
#, fuzzy
msgid "/// admonition | Triggering antivirus"
msgstr "/// admonition |触发杀毒软件"

#: docs/en/tutorial/tutorial-3.md:192
msgid ""
"Since this metadata is being written directly in to the pre-compiled binary "
"rolled out from the template during the `create` command, this may trigger "
"antivirus software running on your machine and prevent the metadata from "
"being written. In that case, instruct the antivirus to allow the tool (named"
" `rcedit-x64.exe`) to run and re-run the command above."
msgstr ""
"由于这些元数据是在 `create` "
"命令中直接写入从模板推出的预编译二进制文件的，因此可能会触发机器上运行的杀毒软件，从而阻止元数据的写入。在这种情况下，请指示杀毒软件允许工具（名为 "
"`rcedit-x64.exe`）运行，并重新运行上述命令。"

#: docs/en/tutorial/tutorial-3.md:198
msgid "Running your app"
msgstr "运行应用程序"

#: docs/en/tutorial/tutorial-3.md:200
msgid "You can now use Briefcase to run your application:"
msgstr "现在您可以使用 Briefcase 运行应用程序了："

#: docs/en/tutorial/tutorial-3.md:279
msgid ""
"This will start to run your native application, using the app bundle created"
" by the `build` command."
msgstr "这将使用 `build` 命令的输出开始运行原生应用程序。"

#: docs/en/tutorial/tutorial-3.md:281
msgid ""
"You might notice some small differences in the way your application looks "
"when it's running. For example, icons and the name displayed by the "
"operating system may be slightly different to those you saw when running "
"under developer mode. This is also because you're using the packaged "
"application, not just running Python code. From the operating system's "
"perspective, you're now running \"an app\", not \"a Python program\", and "
"this is reflected in how the application appears."
msgstr ""
"你可能会注意到应用程序运行时的外观有一些细微差别。例如，操作系统显示的图标和名称可能与在开发者模式下运行时略有不同。这也是因为您使用的是打包的应用程序，而不仅仅是运行"
" Python 代码。从操作系统的角度来看，您现在运行的是“一个应用程序”，而不是“一个 Python 程序\"”，这也反映在应用程序的显示方式上。"

#: docs/en/tutorial/tutorial-3.md:283
msgid ""
"Before continuing, close the app. As with previous tutorial steps, you can "
"do this by pressing the close button on the application window, by selecting"
" Quit/Exit from the application's menu, or by typing **Ctrl+C** in the "
"terminal where you ran `briefcase run`."
msgstr ""
"在继续之前，关闭应用程序。和之前的教程步骤一样，您可以使用应用程序窗口上的关闭按钮、从应用程序的菜单栏选择关闭/退出、或在您运行 `briefcase "
"dev` 的命令行窗口中按 **Ctrl+C** 以关闭应用程序。"

#: docs/en/tutorial/tutorial-3.md:285
msgid "Building your installer"
msgstr "创建安装程序"

#: docs/en/tutorial/tutorial-3.md:287
msgid ""
"You can now package your application for distribution, using the `package` "
"command. The package command does any compilation that is required to "
"convert the scaffolded project into a final, distributable product. "
"Depending on the platform, this may involve compiling an installer, "
"performing code signing, or doing other pre-distribution tasks."
msgstr ""
"现在，您可以使用 `package` "
"命令打包应用程序，以便发布。打包命令会执行将脚手架项目转换为最终可发布产品所需的编译工作。根据平台的不同，这可能涉及编译安装程序、执行代码签名或执行其他发布前任务。"

#: docs/en/tutorial/tutorial-3.md:320
#, fuzzy
msgid ""
"The `dist` folder will contain a file named `Hello World-0.0.1.dmg`. If you "
"locate this file in the Finder, and double-click on its icon, you'll mount "
"the DMG, giving you a copy of the Hello World app, and a link to your "
"Applications folder for easy installation. Drag the app file into "
"Applications, and you've installed your application. Send the DMG file to a "
"friend, and they should be able to do the same."
msgstr ""
"`dist` 文件夹将包含一个名为 `Hello World-0.0.1.dmg` 的文件。如果在 Finder 中找到该文件，并双击其图标，就会加载 "
"DMG，从而获得 Hello World 应用程序的副本，并链接到 `Applications` 文件夹以方便安装。将应用程序文件拖入 "
"Applications，就安装好了应用程序。将 DMG 文件发送给朋友，他们应该也能完成同样的操作。"

#: docs/en/tutorial/tutorial-3.md:322
msgid ""
"In this example, we've used the `--adhoc-sign` option - that is, we're "
"signing our application with *ad hoc* credentials - temporary credentials "
"that will only work on your machine. We've done this to keep the tutorial "
"simple. Setting up code signing identities is a little fiddly, and they're "
"only *required* if you're intending to distribute your application to "
"others. If we were publishing a real application for others to use, we would"
" need to specify real credentials."
msgstr ""
"在本例中，我们使用了 `--adhoc-sign` 选项--也就是说，我们使用 *ad hoc* "
"凭据（仅在你的机器上有效的临时凭据）来签署我们的应用程序。我们这样做是为了让教程简单明了。设置代码签名身份有点麻烦，而且只有当你打算将应用程序发布给他人时\\"
" *才*\\ 需要。如果我们要发布一个真正的应用程序供他人使用，我们就需要指定真实的凭据。"

#: docs/en/tutorial/tutorial-3.md:324
#, fuzzy
msgid ""
"When you're ready to publish a real application, check out the Briefcase "
"How-To guide on [Setting up a macOS code signing identity]{1}."
msgstr "当你准备发布一个真正的应用程序时，请查看公文包操作指南中的 [设置 macOS 代码签名身份]{1}。"

#: docs/en/tutorial/tutorial-3.md:330
msgid ""
"The output of the package step will be slightly different depending on your "
"Linux distribution. If you're on a Debian-derived distribution, you'll see:"
msgstr "软件包步骤的输出会因 Linux 发行版的不同而略有不同。如果你使用的是 Debian 衍生发行版，你会看到:"

#: docs/en/tutorial/tutorial-3.md:350
msgid "The `dist` folder will contain the `.deb` file that was generated."
msgstr "`dist` 文件夹将包含生成的 `.deb` 文件。"

#: docs/en/tutorial/tutorial-3.md:352
msgid "If you're on a RHEL-based distribution, you'll see:"
msgstr "如果你使用的是基于 RHEL 的发行版，你就会看到："

#: docs/en/tutorial/tutorial-3.md:379
msgid "The `dist` folder will contain the `.rpm` file that was generated."
msgstr "`dist` 文件夹将包含生成的 `.rpm` 文件。"

#: docs/en/tutorial/tutorial-3.md:381
msgid "If you're on an Arch-based distribution, you'll see:"
msgstr "如果你使用的是基于 Arch 的发行版，你就会看到："

#: docs/en/tutorial/tutorial-3.md:399
msgid ""
"The `dist` folder will contain the `.pkg.tar.zst` file that was generated."
msgstr "`dist` 文件夹将包含生成的 `.pkg.tar.zst` 文件。"

#: docs/en/tutorial/tutorial-3.md:401
msgid "Other Linux distributions aren't currently supported for packaging."
msgstr "目前不支持其他 Linux 发行版的打包。"

#: docs/en/tutorial/tutorial-3.md:403
msgid ""
"If you want to build a package for a Linux distribution other than the one "
"you're using, Briefcase can also help - but you'll need to install Docker."
msgstr "如果你想为你正在使用的 Linux 发行版之外的其他发行版构建软件包，Briefcase 也能提供帮助，但你需要安装 Docker。"

#: docs/en/tutorial/tutorial-3.md:405
msgid ""
"Official installers for [Docker Engine]{1} are available for a range of Unix"
" distributions. Follow the instructions for your platform; however, ensure "
"you don't install Docker in \"rootless\" mode."
msgstr ""
"[Docker Engine]{1} 的官方安装程序适用于一系列 Unix 发行版。请按照您所在平台的说明进行操作；不过，请确保不要在 rootless"
" 模式下安装 Docker。"

#: docs/en/tutorial/tutorial-3.md:407
msgid ""
"Once you've installed Docker, you should be able to start an Linux container"
" - for example:"
msgstr "安装好 Docker 后，你就可以启动 Linux 容器了，例如:"

#: docs/en/tutorial/tutorial-3.md:413
msgid ""
"will show you a Unix prompt (something like `root@84444e31cff9:/#`) inside "
"an Ubuntu 22.04 Docker container. Type Ctrl-D to exit Docker and return to "
"your local shell."
msgstr ""
"将显示 Ubuntu 22.04 Docker 容器中的 Unix 提示符（类似于 `root@84444e31cff9:/#`）。键入 Ctrl-D "
"退出 Docker 并返回本地 shell。"

#: docs/en/tutorial/tutorial-3.md:415
msgid ""
"Once you've got Docker installed, you can use Briefcase to build a package "
"for any Linux distribution that Briefcase supports by passing in a Docker "
"image as an argument. For example, to build a DEB package for Ubuntu 22.04 "
"(Jammy), regardless of the operating system you're on, you can run:"
msgstr ""
"一旦安装了 Docker，只要将 Docker 镜像作为参数传递，就可以使用 Briefcase 为 Briefcase 支持的任何 Linux "
"发行版构建软件包。例如，要为 Ubuntu 22.04 (Jammy) 构建一个 DEB 包，无论你使用的是哪种操作系统，你都可以运行:"

#: docs/en/tutorial/tutorial-3.md:421
msgid ""
"This will download the Docker image for your selected operating system, "
"create a container that is able to run Briefcase builds, and build the app "
"package inside the image. Once it's completed, the `dist` folder will "
"contain the package for the target Linux distribution."
msgstr ""
"这将下载所选操作系统的 Docker 镜像，创建一个能够运行 Briefcase 构建的容器，并在镜像中构建应用程序软件包。完成后，`dist` "
"文件夹将包含目标 Linux 发行版的软件包。"

#: docs/en/tutorial/tutorial-3.md:455
msgid ""
"In this example, we're not signing our app. As a result, when you use the "
"installer, you'll get a system warning that the application comes from an "
"unknown developer. We've done this to keep the tutorial simple. Setting up "
"code signing identities is a little fiddly, and they're only *required* if "
"you're intending to distribute your application to others. If we were "
"publishing a real application for others to use, we would need to specify a "
"real signing identity; when that signed app is installed, the system will "
"notify the user that the application is from the known identity associated "
"with the certificate."
msgstr ""
"在本例中，我们没有签署我们的应用程序。因此，当您使用安装程序时，您将收到系统警告，该应用程序来自未知开发人员。我们这样做是为了保持教程的简单性。设置代码签名身份比较复杂，只有当您打算将您的应用程序分发给其他人时，它们才*需要*。如果我们发布一个真实的应用程序供其他人使用，我们需要指定一个真实的签名身份；当该签名的应用程序安装时，系统将通知用户该应用程序来自与证书关联的已知身份。"

#: docs/en/tutorial/tutorial-3.md:457
#, fuzzy
msgid ""
"When you're ready to publish a real application, check out the Briefcase "
"How-To guide on [Setting up a Windows code signing identity]{1}."
msgstr "当您准备发布实际应用程序时，请查看公文包操作指南中的 [设置 Windows 代码签名身份]{1}。"

#: docs/en/tutorial/tutorial-3.md:459
msgid ""
"Once this step completes, the `dist` folder will contain a file named "
"`Hello_World-0.0.1.msi`. If you double click on this installer to run it, "
"you should go through a familiar Windows installation process. Once this "
"installation completes, there will be a \"Hello World\" entry in your start "
"menu."
msgstr ""
"此步骤完成后，`dist` 文件夹中将包含一个名为 `Hello_World-0.0.1.msi`` 的文件。如果双击运行该安装程序，就会进入熟悉的 "
"Windows 安装过程。安装完成后，开始菜单中将出现 \"Hello World \"条目。"

#: docs/en/tutorial/tutorial-3.md:465
#, fuzzy
msgid ""
"We now have our application packaged for distribution on desktop platforms. "
"But what happens when we need to update the code in our application? How do "
"we get those updates into our packaged application? Turn to [Tutorial 4]{1} "
"to find out..."
msgstr ""
"现在，我们已将应用程序打包发布到桌面平台上。但是，当我们需要更新应用程序中的代码时该怎么办？我们如何将这些更新添加到打包的应用程序中？请参阅 [教程 "
"4]{1} 了解详情..."

#: docs/en/tutorial/tutorial-4.md:1
#, fuzzy
msgid "Tutorial 4 - Updating your application"
msgstr "教程 4 - 更新应用程序"

#: docs/en/tutorial/tutorial-4.md:3
msgid ""
"In the last tutorial, we packaged our application as a native application. "
"If you're dealing with a real-world app, that isn't going to be the end of "
"the story - you'll likely do some testing, discover problems, and need to "
"make some changes. Even if your application is perfect, you'll eventually "
"want to publish version 2 of your application with improvements."
msgstr ""
"在上一教程中，我们将应用程序打包为本地应用程序。如果您面对的是一个真实世界的应用程序，这并不是故事的结束--"
"您可能会进行一些测试，发现一些问题，并需要进行一些修改。即使您的应用程序是完美的，您最终还是希望发布改进后的第二版应用程序。"

#: docs/en/tutorial/tutorial-4.md:5
msgid "So - how do you update your installed app when you make code changes?"
msgstr "那么，在更改代码时如何更新已安装的应用程序？"

#: docs/en/tutorial/tutorial-4.md:7
msgid "Updating application code"
msgstr "更新应用程序代码"

#: docs/en/tutorial/tutorial-4.md:9
msgid ""
"Our application currently prints to the console when you press the button. "
"However, GUI applications shouldn't really use the console for output. They "
"need to use dialogs to communicate with users."
msgstr "目前，我们的应用程序会在您按下按钮时打印到控制台。但是，图形用户界面应用程序实际上不应该使用控制台进行输出。它们需要使用对话框与用户交流。"

#: docs/en/tutorial/tutorial-4.md:11
msgid ""
"Let's add a dialog box to say hello, instead of writing to the console. "
"Modify the `say_hello` callback so it looks like this:"
msgstr "让我们添加一个对话框来说 \"你好\"，而不是写入控制台。修改 `say_hello` 回调，使它看起来像这样：："

#: docs/en/tutorial/tutorial-4.md:23
#, fuzzy
msgid ""
"We need to make the method `async` so that when we display the dialog, the "
"rest of the application continues to run. Don't worry about this detail too "
"much right now - we'll give a more detailed explanation in [Tutorial 8]{1}."
msgstr ""
"我们需要使用 \"async \"方法，以便在显示对话框时，应用程序的其他部分能够继续运行。现在不用太在意这个细节，我们会在【教程 "
"8】{1}中给出更详细的解释。"

#: docs/en/tutorial/tutorial-4.md:25
msgid ""
"This directs Toga to open a modal dialog box when the button is pressed."
msgstr "这将指示 Toga 在按下按钮时打开一个模态对话框。"

#: docs/en/tutorial/tutorial-4.md:27
msgid ""
"If you run `briefcase dev`, enter a name, and press the button, you'll see "
"the new dialog box:"
msgstr "如果运行 `briefcase dev`，输入名称并按下按钮，就会看到新的对话框："

#: docs/en/tutorial/tutorial-4.md:31
#, fuzzy
msgid "![Hello World Tutorial 4 dialog, on macOS]{1}"
msgstr "你好世界教程 4 对话框，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-4.md:41
#, fuzzy
msgid "![Hello World Tutorial 4 dialog, on Linux]{1}"
msgstr "![Hello World 教程 4 对话框，在 Linux 上]{1}。"

#: docs/en/tutorial/tutorial-4.md:51
#, fuzzy
msgid "![Hello World Tutorial 4 dialog, on Windows]{1}"
msgstr "![Hello World 教程 4 对话，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-4.md:59
msgid "However, if you run `briefcase run`, the dialog box won't appear."
msgstr "但是，如果运行\\ `briefcase run`，对话框就不会出现。"

#: docs/en/tutorial/tutorial-4.md:61
#, fuzzy
msgid ""
"Why is this? Well, `briefcase dev` operates by running your code in place - "
"it tries to produce as realistic runtime environment for your code as "
"possible, but it doesn't provide or use any of the platform infrastructure "
"for wrapping your code as an application. Part of the process of packaging "
"your app involves copying your code *into* the application bundle - and at "
"the moment, your application still has the old code in it."
msgstr ""
"为什么会这样？简易开发包 \"的运行方式是在原地运行您的代码--"
"它试图为您的代码提供尽可能逼真的运行环境，但并不提供或使用任何平台基础架构来将您的代码包装成应用程序。打包应用程序的部分过程包括将您的代码复制到应用程序捆绑包中，目前，您的应用程序中仍有旧代码。"

#: docs/en/tutorial/tutorial-4.md:63
msgid ""
"So - we need to tell briefcase to update your app, copying in the new "
"version of the code. We *could* do this by deleting the old platform "
"directory and starting from scratch. However, Briefcase provides an easier "
"way - you can update the code for your existing bundled application:"
msgstr ""
"因此，我们需要告诉 Briefcase 让它更新应用程序，复制新版本的代码。我们\\ *可以*\\ "
"删除旧的平台目录，然后从头开始。不过，Briefcase 提供了一种更简单的方法--您可以更新现有捆绑的应用程序的代码："

#: docs/en/tutorial/tutorial-4.md:120
msgid ""
"If Briefcase can't find the scaffolded template, it will automatically "
"invoke `create` to generate a fresh scaffold."
msgstr "如果 Briefcase 找不到脚手架模板，它会自动调用 `create` 生成一个新的脚手架。"

#: docs/en/tutorial/tutorial-4.md:122
msgid ""
"Now that we've updated the installer code, we can then run `briefcase build`"
" to re-compile the app, `briefcase run` to run the updated app, and "
"`briefcase package` to repackage the application for distribution."
msgstr ""
"更新了安装程序代码后，我们就可以运行 `briefcase build` 来重新编译应用程序，运行 `briefcase run` "
"来运行更新后的应用程序，并运行 `briefcase package` 来重新打包应用程序以便分发。"

#: docs/en/tutorial/tutorial-4.md:126
#, fuzzy
msgid ""
"macOS users, remember that as noted in [Tutorial 3]{1}, for the tutorial we "
"recommend running `briefcase package` with the `--adhoc-sign` flag to avoid "
"the complexity of setting up a code signing identity and keep the tutorial "
"as simple as possible."
msgstr ""
"(macOS 用户请记住，正如 [Tutorial 3<tutorial-3>` 中所述，我们建议在运行 `briefcase package` 时使用"
" `--adhoc-sign` 标志，以避免设置代码签名身份的复杂性，并使教程尽可能简单）"

#: docs/en/tutorial/tutorial-4.md:130
msgid "Update and run in one step"
msgstr "更新和运行一步到位"

#: docs/en/tutorial/tutorial-4.md:132
msgid ""
"If you're rapidly iterating code changes, you'll likely want to make a code "
"change, update the application, and immediately re-run your application. For"
" most purposes, developer mode (`briefcase dev`) will be the easiest way to "
"do this sort of rapid iteration; however, if you're testing something about "
"how your application runs as a native binary, or hunting a bug that only "
"manifests when your application is in packaged form, you may need to use "
"repeated calls to `briefcase run`. To simplify the process of updating and "
"running the bundled app, Briefcase has a shortcut to support this usage "
"pattern - the `-u` (or `--update`) option on the `run` command."
msgstr ""
"如果要快速迭代代码更改，很可能需要更改代码、更新应用程序并立即重新运行应用程序。对于大多数情况来说，开发人员模式 (`briefcase dev`) "
"是进行这种快速迭代的最简单方法；但是，如果您要测试应用程序作为原生二进制文件的运行，或查找一个只有在应用程序打包时才会出现的错误，您可能需要反复调用 "
"`briefcase run`。为了简化更新和运行打包应用程序的过程，Briefcase 提供了支持这种使用模式的快捷方式 - `run` 命令上的 "
"`-u`（或 `--update`）选项。"

#: docs/en/tutorial/tutorial-4.md:134
msgid ""
"Let's try making another change. You may have noticed that if you don't type"
" a name in the text input box, the dialog will say \"Hello, \". Let's modify"
" the `say_hello` function again to handle this edge case."
msgstr ""
"让我们尝试做另一个改动。您可能已经注意到，如果您不在文本输入框中输入姓名，对话框就会显示 \"Hello, \"。 让我们再次修改 "
"`say_hello` 函数，以处理这种边缘情况。"

#: docs/en/tutorial/tutorial-4.md:136
msgid ""
"At the top of the file, between the imports and the `class HelloWorld` "
"definition, add a utility method to generate an appropriate greeting "
"depending on the value of the name that has been provided:"
msgstr "在文件顶部，在导入和 `class HelloWorld` 定义之间，添加一个实用程序方法，以根据所提供的名称值生成适当的问候语:"

#: docs/en/tutorial/tutorial-4.md:146
msgid "Then, modify the `say_hello` callback to use this new utility method:"
msgstr "然后，修改 `say_hello` 回调，以使用这个新的实用程序方法:"

#: docs/en/tutorial/tutorial-4.md:158
msgid ""
"Run your app in development mode (with `briefcase dev`) to confirm that the "
"new logic works; then update, build and run the app with one command:"
msgstr "在开发模式下运行应用程序（使用 `briefcase dev`），以确认新逻辑是否有效；然后使用一条命令更新、构建和运行应用程序："

#: docs/en/tutorial/tutorial-4.md:230
msgid ""
"The package command also accepts the `-u` argument, so if you make a change "
"to your application code and want to repackage immediately, you can run "
"`briefcase package -u`."
msgstr ""
"package 命令也接受 `-u` 参数，因此如果你修改了应用程序代码并希望立即重新打包，可以运行 `briefcase package -u`。"

#: docs/en/tutorial/tutorial-4.md:234
msgid ""
"We now have our application packaged for distribution on desktop platforms, "
"and we've been able to update the code in our application."
msgstr "现在，我们的应用程序已经打包，可以在桌面平台上发布，我们也可以更新应用程序中的代码。"

#: docs/en/tutorial/tutorial-4.md:236
#, fuzzy
msgid ""
"But what about mobile? In [Tutorial 5]{1}, we'll convert our application "
"into a mobile application, and deploy it onto a device simulator, and onto a"
" phone."
msgstr "那么移动应用呢？在 [教程 5]{1} 中，我们将把应用程序转换为移动应用程序，并将其部署到设备模拟器和手机上。"

#: docs/en/tutorial/tutorial-5/android.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it mobile: Android"
msgstr "教程 5 - 在移动设备上：安卓"

#: docs/en/tutorial/tutorial-5/android.md:3
msgid ""
"Now, we're going to take our application, and deploy it as an Android "
"application."
msgstr "现在，我们要将应用程序部署为 Android 应用程序。"

#: docs/en/tutorial/tutorial-5/android.md:5
msgid ""
"The process of deploying an application to Android is very similar to the "
"process for deploying as a desktop application. Briefcase handles installing"
" dependencies for Android, including the Android SDK, the Android emulator, "
"and a Java compiler."
msgstr ""
"将应用程序部署到 Android 的过程与部署为桌面应用程序的过程非常相似。Briefcase 会处理 Android 上的依赖项的安装，包括 "
"Android SDK、Android 模拟器，和一个 Java 编译器。"

#: docs/en/tutorial/tutorial-5/android.md:7
msgid "Create an Android app and compile it"
msgstr "创建并编译 Android 应用程序"

#: docs/en/tutorial/tutorial-5/android.md:9
msgid ""
"First, run the `create` command. This downloads an Android app template and "
"adds your Python code to it."
msgstr "首先，运行 `create` 命令。这会下载一个 Android 应用程序模板，并在其中添加您的 Python 代码。"

#: docs/en/tutorial/tutorial-5/android.md:98
msgid ""
"When you run `briefcase create android` for the first time, Briefcase "
"downloads a Java JDK, and the Android SDK. File sizes and download times can"
" be considerable; this may take a while (10 minutes or longer, depending on "
"the speed of your Internet connection). When the download has completed, you"
" will be prompted to accept Google's Android SDK license. There's a number "
"of licenses you'll need to agree too - keep entering `y` at the prompt to "
"review and accept each of the necessary the license agreements."
msgstr ""
"首次运行 `briefcase create android` 时，Briefcase 会下载 Java JDK 和 Android "
"SDK。文件大小较大，且下载时间可能会较长（10 分钟或更长，取决于您的互联网连接速度）。下载完成后，您将会被提示接受 Google 的 Android"
" SDK 许可证。还有一些需要同意的许可证 -- 在提示符不停的按 `y` 以查看与接受所有所需的许可证协议。"

#: docs/en/tutorial/tutorial-5/android.md:100
msgid ""
"Once this completes, we'll have a `build\\helloworld\\android\\gradle` "
"directory in our project, which will contain an Android project with a "
"Gradle build configuration. This project will contain your application code,"
" and a support package containing the Python interpreter."
msgstr ""
"完成后，我们的项目中就会有一个\\ `build/helloworld/android/gradle`\\ 目录，其中包含一个带有 Gradle "
"构建配置的 Android 项目。这个项目将包含您的应用代码，以及一个包含 Python 解释器的支持包。"

#: docs/en/tutorial/tutorial-5/android.md:102
msgid ""
"We can then use Briefcase's `build` command to compile this into an Android "
"APK app file."
msgstr "然后我们可以使用 Briefcase 的 `build` 命令将其编译为 Android APK 应用程序文件。"

#: docs/en/tutorial/tutorial-5/android.md:164
#, fuzzy
msgid "/// admonition | Gradle may look stuck"
msgstr "/// admonition |Gradle 可能看起来卡住了"

#: docs/en/tutorial/tutorial-5/android.md:166
msgid ""
"During the `briefcase build android` step, Gradle (the Android platform "
"build tool) will print `CONFIGURING: 100%`, and appear to be doing nothing. "
"Don't worry, it's not stuck - it's downloading more Android SDK components. "
"Depending on your Internet connection speed, this may take another 10 "
"minutes (or longer). This lag should only happen the very first time you run"
" `build`; the tools are cached, and on your next build, the cached versions "
"will be used."
msgstr ""
"在 `briefcase build android` 步骤中，Gradle（Android 平台构建工具）会打印 \\ `CONFIGURING: "
"100%`，似乎什么也没做。别担心，这不是卡住了，而是在下载更多的 Android SDK 组件。根据您的网络连接速度，这可能还需要 10 "
"分钟（或更长时间）。只有在第一次运行 `build` 时才会出现这种滞后现象；这些工具将会被缓存，下次构建时将使用缓存版本。"

#: docs/en/tutorial/tutorial-5/android.md:170
msgid "Run the app on a virtual device"
msgstr "在虚拟设备上运行应用程序"

#: docs/en/tutorial/tutorial-5/android.md:172
msgid ""
"We're now ready to run our application. You can use Briefcase's `run` "
"command to run the app on an Android device. Let's start by running on an "
"Android emulator."
msgstr ""
"现在我们可以运行应用程序了。您可以使用 Briefcase 的 `run` 命令在 Android 设备上运行应用程序。让我们从在 Android "
"模拟器上运行开始。"

#: docs/en/tutorial/tutorial-5/android.md:174
msgid ""
"To run your application, run `briefcase run android`. When you do this, "
"you'll be prompted with a list of devices that you could run the app on. The"
" last item will always be an option to create a new Android emulator."
msgstr ""
"要运行应用程序，请运行 `briefcase run "
"android`。运行时，系统会提示你可以在哪些设备上运行应用程序。最后一项总会是创建新安卓模拟器的选项。"

#: docs/en/tutorial/tutorial-5/android.md:218
msgid ""
"We can now choose our desired device. Select the \"Create a new Android "
"emulator\" option, and accept the default choice for the device name "
"(`beePhone`)."
msgstr ""
"现在我们可以选择想要的设备。选择 \"Create a new Android emulator\" "
"选项，并接受默认的设备名称（`beePhone`）。"

#: docs/en/tutorial/tutorial-5/android.md:220
msgid ""
"Briefcase `run` will automatically boot the virtual device. When the device "
"is booting, you will see the Android logo:"
msgstr "Briefcase `run` 将自动启动虚拟设备。设备启动时，您将看到 Android 徽标："

#: docs/en/tutorial/tutorial-5/android.md:222
#, fuzzy
msgid "![Android virtual device booting]{1}"
msgstr "安卓虚拟设备启动]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:226
#, fuzzy
msgid "Android virtual device booting"
msgstr "启动安卓虚拟设备"

#: docs/en/tutorial/tutorial-5/android.md:230
msgid ""
"Once the device has finished booting, Briefcase will install your app on the"
" device. You will briefly see a launcher screen:"
msgstr "设备启动完成后，Briefcase 将在设备上安装您的应用程序。您将短暂看到一个启动页面："

#: docs/en/tutorial/tutorial-5/android.md:232
#, fuzzy
msgid "![Android virtual device fully started, on the launcher screen]{1}"
msgstr "安卓虚拟设备已完全启动，显示在启动器屏幕上]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:236
#, fuzzy
msgid "Android virtual device fully started, on the launcher screen"
msgstr "安卓虚拟设备已完全启动，显示在启动器屏幕上"

#: docs/en/tutorial/tutorial-5/android.md:240
msgid ""
"The app will then start. You'll see a splash screen while the app starts up:"
msgstr "然后，应用程序就会启动。程序启动时，你会看到一个闪屏："

#: docs/en/tutorial/tutorial-5/android.md:242
#, fuzzy
msgid "![App splash screen]{1}"
msgstr "应用程序闪屏]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:246
#, fuzzy
msgid "App splash screen"
msgstr "应用程序闪屏"

#: docs/en/tutorial/tutorial-5/android.md:250
#, fuzzy
msgid "/// admonition | The emulator didn't start!"
msgstr "/// admonition |模拟器没有启动！"

#: docs/en/tutorial/tutorial-5/android.md:252
msgid ""
"The Android emulator is a complex piece of software that relies on a number "
"of hardware and operating system features - features that may not be "
"available or enabled on older machines. If you experience any difficulties "
"starting the Android emulator, consult the [Requirements and "
"recommendations]{1} section of the Android developer documentation."
msgstr ""
"安卓模拟器是一个复杂的软件，依赖于许多硬件和操作系统功能，这些功能在旧机器上可能无法使用或启用。如果在启动 Android 模拟器时遇到任何困难，请查阅"
" Android 开发人员文档中的\\ [要求和建议]{1} 部分。"

#: docs/en/tutorial/tutorial-5/android.md:256
msgid ""
"The first time the app starts, it needs to unpack itself onto the device. "
"This may take a few seconds. Once it's unpacked, you'll see the Android "
"version of our desktop app:"
msgstr "首次启动应用程序时，它需要将自己解压缩到设备上。这可能需要几秒钟。解压完成后，您将看到桌面应用程序的 Android 版本："

#: docs/en/tutorial/tutorial-5/android.md:258
#, fuzzy
msgid "![Demo app fully launched]{1}"
msgstr "演示程序已完全启动]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:262
#, fuzzy
msgid "Demo app fully launched"
msgstr "演示应用程序全面启动"

#: docs/en/tutorial/tutorial-5/android.md:266
#, fuzzy
msgid ""
"If you fail to see your app launching, you may need to check your terminal "
"where you ran `briefcase run` and look for any error messages."
msgstr "如果看不到应用程序启动，可能需要检查运行 `briefcase run` 的终端，查看是否有错误信息。"

#: docs/en/tutorial/tutorial-5/android.md:268
#, fuzzy
msgid ""
"While the app is running, you'll see a lot of messages being streamed in the"
" console. This is a stream of the application's logs from the emulator. "
"Typing Ctrl+C into the terminal will halt the streamed information in the "
"console, but it will not close the emulator. This is so you can test new "
"changes without restarting the emulator."
msgstr ""
"程序运行时，你会在控制台中看到大量信息流。这是来自模拟器的应用程序日志流。在终端输入 Ctrl+C "
"将停止控制台中的信息流，但不会关闭模拟器。这样你就可以在不重启模拟器的情况下测试新的更改。"

#: docs/en/tutorial/tutorial-5/android.md:270
#, fuzzy
msgid ""
"In future, if you want to run on this device without using the menu, you can"
" provide the emulator's name to Briefcase, using `briefcase run android -d "
"\"@beePhone\"` to run on the virtual device directly."
msgstr ""
"今后，如果想在该设备上运行而不使用菜单，可以向 Briefcase 提供模拟器名称，使用 `briefcase run android -d "
"@beePhone` 直接在虚拟设备上运行。"

#: docs/en/tutorial/tutorial-5/android.md:272
#, fuzzy
msgid "Run the app on a physical device"
msgstr "在实体设备上运行应用程序"

#: docs/en/tutorial/tutorial-5/android.md:274
#, fuzzy
msgid ""
"If you have a physical Android phone or tablet, you can connect it to your "
"computer with a USB cable, and then use the Briefcase to target your "
"physical device."
msgstr "如果您有实体安卓手机或平板电脑，可以用 USB 线缆将其连接到电脑，然后使用公文包来定位您的实体设备。"

#: docs/en/tutorial/tutorial-5/android.md:276
#, fuzzy
msgid ""
"Android requires that you prepare your device before it can be used for "
"development. You will need to make 2 changes to the options on your device:"
msgstr "Android 要求您在设备用于开发前做好准备。您需要对设备上的选项进行两项更改："

#: docs/en/tutorial/tutorial-5/android.md:278
#, fuzzy
msgid "Enable developer options"
msgstr "启用开发人员选项"

#: docs/en/tutorial/tutorial-5/android.md:279
#, fuzzy
msgid "Enable USB debugging"
msgstr "启用 USB 调试"

#: docs/en/tutorial/tutorial-5/android.md:281
#, fuzzy
msgid ""
"Details on how to make these changes can be found [in the Android developer "
"documentation]{1}."
msgstr "有关如何进行这些更改的详细信息，请参阅 Android 开发人员文档]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:283
#, fuzzy
msgid ""
"Once these steps have been completed, your device should appear in the list "
"of available devices when you run `briefcase run android`."
msgstr "完成这些步骤后，在运行 `briefcase run android` 时，您的设备应出现在可用设备列表中。"

#: docs/en/tutorial/tutorial-5/android.md:333
#, fuzzy
msgid ""
"Here we can see a new physical device with it's serial number on the "
"deployment list - in this case, a Pixel 3a. In the future, if you want to "
"run on this device without using the menu, you can provide the phone's "
"serial number to Briefcase (in this case, `briefcase run android -d "
"94ZZY0LNE8`). This will run on the device directly, without prompting."
msgstr ""
"在这里，我们可以在部署列表中看到一个带有序列号的新物理设备--在本例中是 Pixel 3a。将来，如果你想不使用菜单而在该设备上运行，可以向 "
"Briefcase 提供手机序列号（本例中为 `briefcase run android -d "
"94ZZY0LNE8`）。这将直接在设备上运行，无需提示。"

#: docs/en/tutorial/tutorial-5/android.md:335
#, fuzzy
msgid "/// admonition | My device doesn't appear!"
msgstr "/// admonition |我的设备没有出现！"

#: docs/en/tutorial/tutorial-5/android.md:337
#, fuzzy
msgid ""
"If your device doesn't appear on this list at all, either you haven't "
"enabled USB debugging, (or the device isn't plugged in!)."
msgstr "如果你的设备根本没有出现在这个列表中，要么是你没有启用 USB 调试（要么是设备没有插上电源！）。"

#: docs/en/tutorial/tutorial-5/android.md:339
#, fuzzy
msgid ""
"If your device appears, but is listed as \"Unknown device (not authorized "
"for development)\", developer mode hasn't been correctly enabled. Re-run "
"[the steps to enable developer options]{1}, and re-run `briefcase run "
"android`."
msgstr ""
"如果你的设备出现了，但却被列为 \"未知设备（未授权开发）\"，那么开发者模式尚未正确启用。重新运行 [启用开发者选项的步骤]{1}，并重新运行 "
"\"briefcase run android\"。"

#: docs/en/tutorial/tutorial-5/android.md:345
#: docs/en/tutorial/tutorial-5/iOS.md:125
#, fuzzy
msgid ""
"We've now got an application on our phone! Is there anywhere else we can "
"deploy a BeeWare app? Turn to [Tutorial 6]{1} to find out..."
msgstr "我们现在已经在手机上安装了应用程序！还有其他地方可以部署 BeeWare 应用程序吗？转到[教程6]{1}就知道了..."

#: docs/en/tutorial/tutorial-5/iOS.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it mobile: iOS"
msgstr "教程 5 - 在移动设备上：iOS"

#: docs/en/tutorial/tutorial-5/iOS.md:3
msgid ""
"To compile iOS applications we'll need Xcode, which is available for free "
"from [the macOS App Store]{1}. Once Xcode is installed, launch it from "
"Applications and accept the Xcode License Agreement. Next, Xcode will show "
"which components are built-in, and which components you may download. Select"
" the checkbox next to iOS (followed by the current version number), and then"
" click \"Download and Install\" to install it. Xcode will install the system"
" components, followed by the iOS Simulator."
msgstr ""
"编译 iOS 应用程序需要 Xcode，可从 [macOS App Store]{1} 免费下载。当 Xcode 完成安装时，从“应用程序”打开它并接受"
" Xcode 许可协议。接下来，Xcode 会展示哪些模拟器运行时已内置，哪些可以下载。选择 iOS "
"模拟器运行时旁边的复选框，并点击“继续”来下载和安装它。"

#: docs/en/tutorial/tutorial-5/iOS.md:5
msgid ""
"Once we've got Xcode and the iOS simulator installed, we can take our "
"application and deploy it as an iOS app."
msgstr "安装好 Xcode 与 iOS 模拟器后，我们就可以将应用程序作为 iOS 应用程序进行部署。"

#: docs/en/tutorial/tutorial-5/iOS.md:7
#, fuzzy
msgid ""
"The process of deploying an application to iOS is very similar to the "
"process for deploying as a desktop application. First, you run the `create` "
"command - but this time, we specify that we want to create an iOS "
"application:"
msgstr ""
"将应用程序部署到 iOS 的过程与部署桌面应用程序的过程非常相似。首先，运行 `create` 命令，但这次我们指定要创建一个 iOS 应用程序："

#: docs/en/tutorial/tutorial-5/iOS.md:34
msgid ""
"Once this completes, we'll have a `build/helloworld/ios/xcode` directory "
"containing an Xcode project, as well as the support libraries and the "
"application code needed for the application."
msgstr ""
"完成此操作后，我们将拥有一个包含 Xcode 项目、支持库和应用程序所需应用程序代码的 `build/helloworld/ios/xcode` 目录。"

#: docs/en/tutorial/tutorial-5/iOS.md:36
msgid ""
"You can then use Briefcase to compile your app using `briefcase build iOS`:"
msgstr "然后，您可以使用 `briefcase build iOS` 来编译应用程序："

#: docs/en/tutorial/tutorial-5/iOS.md:51
msgid ""
"We're now ready to run our application, using `briefcase run iOS`. You'll be"
" prompted to select a device to compile for; if you've got simulators for "
"multiple iOS SDK versions installed, you may also be asked which iOS version"
" you want to target. The options you are shown may differ from the options "
"show in this output - at the very least, the list of devices will likely be "
"different. For our purposes, it doesn't matter which simulator you pick."
msgstr ""
"现在我们可以使用 `briefcase run iOS` 运行应用程序了。Briefcase 会提示你选择要编译的设备；如果你安装了多个 iOS SDK"
" 版本的模拟器，可能还会询问你要针对哪个 iOS "
"版本。所显示的选项可能与此输出中显示的选项不同，至少设备列表可能不同。就我们而言，选择哪个模拟器并不重要。"

#: docs/en/tutorial/tutorial-5/iOS.md:95
msgid ""
"This will start the iOS simulator, install your app, and start it. You "
"should see the simulator start, and eventually open your iOS application:"
msgstr "这将启动 iOS 模拟器，安装你的应用程序并启动它。你应该能看到模拟器启动，并最终打开你的 iOS 应用程序："

#: docs/en/tutorial/tutorial-5/iOS.md:97
#, fuzzy
msgid "![Hello World Tutorial 5 window, on iOS]{1}"
msgstr "![Hello World 教程 5 窗口，在 iOS 上]{1}。"

#: docs/en/tutorial/tutorial-5/iOS.md:103
msgid ""
"While the app is running, you'll see a series of Simulator log output "
"messages in the console. Typing Ctrl+C into the terminal will halt the "
"messages in the console, but it will not close the simulator. This is so you"
" can test new changes without restarting the simulator."
msgstr ""
"当应用程序运行时，您会在控制台中看到一系列模拟器输出信息。向命令行中按 Ctrl + C "
"会停止控制台中的信息，但不会关闭模拟器。这样，您无需重启模拟器，也能可以继续测试新更改。"

#: docs/en/tutorial/tutorial-5/iOS.md:105
msgid ""
"If you know ahead of time which iOS simulator you want to target, you can "
"tell Briefcase to use that simulator by providing a `-d` (or `--device`) "
"option. Using the name of the device you selected when you built your "
"application, run:"
msgstr ""
"如果事先知道要使用哪个 iOS 模拟器，可以通过提供 `-d`（或 `--device`）选项告诉 Briefcase "
"使用该模拟器。使用创建应用程序时选择的设备名称，运行:"

#: docs/en/tutorial/tutorial-5/iOS.md:111
msgid ""
"If you have multiple iOS versions available, Briefcase will pick the highest"
" iOS version; if you want to pick a particular iOS version, you tell it to "
"use that specific version:"
msgstr "如果你有多个 iOS 版本，Briefcase 会选择最高的 iOS 版本；如果你想选择某个 iOS 版本，你可以告诉它使用该特定版本："

#: docs/en/tutorial/tutorial-5/iOS.md:117
msgid "Or, you can name a specific device UDID:"
msgstr "或者，您也可以命名一个特定的设备 UDID："

#: docs/en/tutorial/tutorial-5/index.md:1
msgid "Tutorial 5 - Taking it Mobile"
msgstr "教程 5 - 在移动设备上"

#: docs/en/tutorial/tutorial-5/index.md:3
msgid ""
"So far, we've been running and testing our application on the desktop. "
"However, BeeWare also supports mobile platforms - and the application we've "
"written can be deployed to your mobile device, too!"
msgstr "到目前为止，我们一直在电脑上运行和测试应用程序。不过，BeeWare 同样支持移动平台，我们编写的应用程序也可以部署到您的移动设备上！"

#: docs/en/tutorial/tutorial-5/index.md:5
#, fuzzy
msgid "[Android]{1}"
msgstr "[Android]{1}"

#: docs/en/tutorial/tutorial-5/index.md:7
msgid "Android applications can be compiled on macOS, Windows or Linux."
msgstr "安卓应用程序可在 macOS、Windows 或 Linux 上编译。"

#: docs/en/tutorial/tutorial-5/index.md:9
#, fuzzy
msgid "[iOS]{1}"
msgstr "[iOS]{1}"

#: docs/en/tutorial/tutorial-5/index.md:11
msgid "iOS applications can only be compiled on macOS."
msgstr "iOS 应用程序只能在 macOS 上编译。"

#: docs/en/tutorial/tutorial-6.md:1
msgid "Tutorial 6 - Put it on the web!"
msgstr "教程 6 - 把它放上网！"

#: docs/en/tutorial/tutorial-6.md:3
msgid ""
"In addition to supporting mobile platforms, the Toga widget toolkit also "
"supports the web! Using the same API that you used to deploy your desktop "
"and mobile applications, you can deploy your application as a single-page "
"web app."
msgstr "除了支持移动平台，Toga 控件工具包还支持网络！使用与部署桌面和移动应用程序相同的应用程序接口，您可以将应用程序部署为单页网页应用程序。"

#: docs/en/tutorial/tutorial-6.md:5
msgid "/// admonition | Proof of Concept"
msgstr "/// admonition | 概念验证"

#: docs/en/tutorial/tutorial-6.md:7
msgid ""
"The Toga Web backend is the least mature of all the Toga backends. It's "
"mature enough to show off a few features, but it's likely to be buggy, and "
"will be missing many of the widgets that are available on other platforms. "
"At this point in time, Web deployment should be considered a \"Proof of "
"Concept\" - enough to demonstrate what can be done, but not enough to be "
"relied on for serious development."
msgstr ""
"Toga Web 后端是所有 Toga "
"后端中最不成熟的一个。它已经足够成熟，可以展示一些功能，但很可能会有问题，而且会缺少许多其他平台上可用的控件。目前，Web "
"部署应被视为“概念验证”--足以展示可以做什么，但还不足以作为严肃开发的依据。"

#: docs/en/tutorial/tutorial-6.md:9
msgid ""
"If you have problems with this step of the tutorial, you can skip to the "
"next page."
msgstr "如果您在教程的这一步遇到问题，可以跳到下一页。"

#: docs/en/tutorial/tutorial-6.md:13
msgid "Deploying as a web app"
msgstr "作为网页应用程序部署"

#: docs/en/tutorial/tutorial-6.md:15
msgid ""
"The process of deploying as a single-page web app follows the same familiar "
"pattern - you create the application, then build the application, then run "
"it. However, Briefcase can be a little bit smart; if you attempt to run an "
"application, and Briefcase determines that it hasn't been created or built "
"for the platform being targeted, it will do the create and build steps for "
"you. Since this is our first time running the app for the web, we can "
"perform all three steps with one command:"
msgstr ""
"作为单页面 Web 应用程序部署的过程遵循相同的熟悉模式--创建应用程序，然后构建应用程序，然后运行它。不过，Briefcase "
"也有一点小聪明；如果您尝试运行应用程序，而 Briefcase "
"确定该应用程序尚未针对目标平台创建或构建，那么它会为您执行创建和构建步骤。由于这是我们第一次为网络运行应用程序，我们可以用一条命令执行所有三个步骤："

#: docs/en/tutorial/tutorial-6.md:137
#, fuzzy
msgid "This will open a web browser, pointing at {1}:"
msgstr "这将打开一个网络浏览器，指向 {1}："

#: docs/en/tutorial/tutorial-6.md:139
#, fuzzy
msgid "![Hello World Tutorial 6 dialog, in a browser]{1}"
msgstr "![浏览器中的 \"你好世界教程 6 \"对话框]{1}。"

#: docs/en/tutorial/tutorial-6.md:141
msgid "If you enter your name and click the button, a dialog will appear."
msgstr "如果输入您的姓名并点击按钮，就会出现一个对话框。"

#: docs/en/tutorial/tutorial-6.md:143
msgid "How does this work?"
msgstr "这是怎么工作的？"

#: docs/en/tutorial/tutorial-6.md:145
msgid ""
"This web app is a static website - a single HTML source page, with some CSS "
"and other resources. Briefcase has started a local web server to serve this "
"page so your browser can view the page. If you wanted to put this web page "
"into production, you could copy the contents of the `www` folder onto any "
"web server that can serve static content."
msgstr ""
"此网络应用程序是一个静态网站 -- 一个 HTML 源页面，包含一些 CSS 和其他资源。Briefcase "
"启动了一个本地网络服务器来提供该页面，以便您的浏览器可以查看该页面。如果您想将此网页进入生产，可以将 `www` "
"文件夹中的内容复制到任何可以提供静态内容的网络服务器上。"

#: docs/en/tutorial/tutorial-6.md:147
#, fuzzy
msgid ""
"But when you press the button, you're running Python code... how does that "
"work? Toga uses [PyScript]{1} to provide a Python interpreter in the "
"browser. Briefcase packages your app's code as wheels that PyScript can load"
" in the browser. When the page is loaded, the application code runs in the "
"browser, building the UI using the browser DOM. When you click a button, "
"that button runs the event handling code in the browser."
msgstr ""
"但是，当你按下按钮时，你运行的是 Python 代码......这是怎么做到的呢？Toga 使用 [PyScript]{1} 在浏览器中提供 "
"Python 解释器。公文包将应用程序的代码打包成 PyScript 可以在浏览器中加载的轮子。加载页面时，应用代码会在浏览器中运行，并使用浏览器 "
"DOM 构建用户界面。当您点击按钮时，该按钮会在浏览器中运行事件处理代码。"

#: docs/en/tutorial/tutorial-6.md:151
#, fuzzy
msgid ""
"Although we've now deployed this app on desktop, mobile and the web, the app"
" is fairly simple, and doesn't involve any third-party libraries. Can we "
"include libraries from the Python Package Index (PyPI) in our app? Turn to "
"[Tutorial 7]{1} to find out..."
msgstr ""
"虽然我们现在已经在桌面、手机和网络上部署了这个应用程序，但该应用程序相当简单，不涉及任何第三方库。我们可以在应用程序中包含 Python 包索引 "
"(PyPI) 中的库吗？请访问 [教程7]{1} 了解详情..."

#: docs/en/tutorial/tutorial-7.md:1
#, fuzzy
msgid "Tutorial 7 - Get this (third-)party started"
msgstr "教程 7 - 使用第三方库"

#: docs/en/tutorial/tutorial-7.md:3
msgid ""
"So far, the app we've built has only used our own code, plus the code "
"provided by BeeWare. However, in a real-world app, you'll likely want to use"
" a third-party library, downloaded from the Python Package Index (PyPI)."
msgstr ""
"到目前为止，我们构建的应用程序只使用了我们自己的代码和 BeeWare 提供的代码。不过，在实际应用中，您很可能需要使用从 Python "
"软件包索引（PyPI）下载的第三方库。"

#: docs/en/tutorial/tutorial-7.md:5
msgid "Let's modify our app to include a third-party library."
msgstr "让我们修改应用程序，加入第三方库。"

#: docs/en/tutorial/tutorial-7.md:7
msgid "Adding a package"
msgstr "添加软件包"

#: docs/en/tutorial/tutorial-7.md:9
msgid ""
"Let's modify our application to say a little bit more than just \"Hi, "
"there!\"."
msgstr "让我们修改我们的应用程序，使其能够显示比“你好！”更丰富的内容。"

#: docs/en/tutorial/tutorial-7.md:11
#, fuzzy
msgid ""
"To generate some more interesting text for the dialog, we're going to use a "
"library called [Faker]{1}. Faker is a Python package that generates fake "
"content, including names and text blocks. The names and words in the text "
"block are generated from an arbitrary list of words provided by Faker. We're"
" going to use Faker to construct a fake message, as if someone is responding"
" to the user."
msgstr ""
"为了给对话框生成一些更有趣的文本，我们将使用一个名为 [Faker]{1} 的库。Faker 是一个 Python "
"软件包，用于生成虚假内容，包括名称和文本块。文本块中的名称和单词由 Faker 提供的任意单词列表生成。我们将使用 Faker "
"构建一条虚假信息，就像有人在回复用户一样。"

#: docs/en/tutorial/tutorial-7.md:13
msgid ""
"We start by adding `faker` to our app. Add an import to the top of the "
"`app.py` to import `faker`:"
msgstr "我们开始吧 `faker` 添加到我们的应用程序中。在 `app.py` 的最上方加入一个导入，用于导入 `faker`:"

#: docs/en/tutorial/tutorial-7.md:19 docs/en/tutorial/tutorial-8.md:32
msgid "Then modify the `say_hello()` callback so it looks like this:"
msgstr "然后修改 `say_hello()` 回调，使其看起来像这样:"

#: docs/en/tutorial/tutorial-7.md:32
msgid ""
"Let's run our updated app in Briefcase developer mode to check that our "
"change has worked."
msgstr "让我们在 Briefcase 开发者模式下运行更新后的应用程序，检查我们的更改是否有效。"

#: docs/en/tutorial/tutorial-7.md:102 docs/en/tutorial/tutorial-7.md:167
#: docs/en/tutorial/tutorial-8.md:124
#, fuzzy
msgid ""
"You can't run an Android app in developer mode - use the instructions for "
"your chosen desktop platform."
msgstr "您无法在开发者模式下运行 Android 应用程序，请使用所选桌面平台的说明。"

#: docs/en/tutorial/tutorial-7.md:108 docs/en/tutorial/tutorial-7.md:173
#: docs/en/tutorial/tutorial-8.md:130
#, fuzzy
msgid ""
"You can't run an iOS app in developer mode - use the instructions for your "
"chosen desktop platform."
msgstr "您无法在开发者模式下运行 iOS 应用程序，请使用所选桌面平台的说明。"

#: docs/en/tutorial/tutorial-7.md:112
msgid ""
"What happened? We've added `faker` to our *code*, but we haven't added it to"
" our development virtual environment. We can fix this by installing `faker` "
"with `pip`, and then re-running `briefcase dev`:"
msgstr ""
"发生了什么？我们已经将 `faker` 添加到我们的\\ *代码*\\ 中，但我们还没有将它添加到我们的开发虚拟环境中。要解决这个问题，我们可以用 "
"`pip` 安装 `faker`，然后重新运行 `briefcase dev`："

#: docs/en/tutorial/tutorial-7.md:121 docs/en/tutorial/tutorial-7.md:138
#: docs/en/tutorial/tutorial-7.md:155 docs/en/tutorial/tutorial-8.md:70
#: docs/en/tutorial/tutorial-8.md:91 docs/en/tutorial/tutorial-8.md:112
msgid ""
"When you enter a name and press the button, you should see a dialog that "
"looks something like:"
msgstr "输入名称并按下按钮后，您会看到一个类似如下的对话框："

#: docs/en/tutorial/tutorial-7.md:123
#, fuzzy
msgid "![Hello World Tutorial 7 dialog, on macOS]{1}"
msgstr "Hello World 教程 7 对话框，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:140
#, fuzzy
msgid "![Hello World Tutorial 7 dialog, on Linux]{1}"
msgstr "![Hello World 教程 7 对话框，在 Linux 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:157
#, fuzzy
msgid "![Hello World Tutorial 7 dialog, on Windows]{1}"
msgstr "![Hello World 教程 7 对话框，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-7.md:177
msgid ""
"We've now got a working app, using a third party library, running in "
"development mode!"
msgstr "现在，我们已经有了一个可正常运行的应用程序，它使用第三方库，并以开发模式运行！"

#: docs/en/tutorial/tutorial-7.md:179
msgid "Running the updated app"
msgstr "运行更新后的应用程序"

#: docs/en/tutorial/tutorial-7.md:181
#, fuzzy
msgid ""
"Let's get this updated application code packaged as a standalone app. Since "
"we've made code changes, we need to follow the same steps as in [Tutorial "
"4]{1}:"
msgstr ""
"让我们将更新后的应用程序代码打包为独立应用程序。由于我们对代码进行了修改，因此需要遵循 [Tutorial 4<tutorial-4>` 中的相同步骤："

#: docs/en/tutorial/tutorial-7.md:185 docs/en/tutorial/tutorial-7.md:226
#: docs/en/tutorial/tutorial-7.md:281 docs/en/tutorial/tutorial-7.md:322
#: docs/en/tutorial/tutorial-7.md:397
#, fuzzy
msgid "Update the code in the packaged app:"
msgstr "更新打包应用程序中的代码："

#: docs/en/tutorial/tutorial-7.md:196 docs/en/tutorial/tutorial-7.md:237
#: docs/en/tutorial/tutorial-7.md:292 docs/en/tutorial/tutorial-7.md:333
#: docs/en/tutorial/tutorial-7.md:408
#, fuzzy
msgid "Rebuild the app:"
msgstr "重建应用程序："

#: docs/en/tutorial/tutorial-7.md:205 docs/en/tutorial/tutorial-7.md:251
#: docs/en/tutorial/tutorial-7.md:301
#, fuzzy
msgid "And finally, run the app:"
msgstr "最后，运行应用程序："

#: docs/en/tutorial/tutorial-7.md:214 docs/en/tutorial/tutorial-7.md:310
#, fuzzy
msgid ""
"However, when the app runs, you'll see an error in the console, plus a crash"
" dialog:"
msgstr "但是，当程序运行时，你会在控制台中看到一个错误，还有一个崩溃对话框："

#: docs/en/tutorial/tutorial-7.md:216
#, fuzzy
msgid "![Hello World Tutorial 7 app crash, on macOS]{1}"
msgstr "你好世界教程 7》应用程序崩溃，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:260 docs/en/tutorial/tutorial-7.md:352
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console:"
msgstr "但是，当应用程序运行时，您会在控制台中看到一个错误："

#: docs/en/tutorial/tutorial-7.md:312
#, fuzzy
msgid "![Hello World Tutorial 7 app crash, on Windows]{1}"
msgstr "Hello World教程7应用程序崩溃，在Windows上]{1}。"

#: docs/en/tutorial/tutorial-7.md:343 docs/en/tutorial/tutorial-7.md:418
#, fuzzy
msgid "And finally, run the app (selecting a simulator when prompted):"
msgstr "最后，运行应用程序（根据提示选择模拟器）："

#: docs/en/tutorial/tutorial-7.md:428
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console"
msgstr "但是，当应用程序运行时，您会在控制台中看到一个错误："

#: docs/en/tutorial/tutorial-7.md:443
#, fuzzy
msgid ""
"Once again, the app has failed to start because `faker` has not been "
"installed - but why? Haven't we already installed `faker`?"
msgstr "又一次，应用程序无法启动，因为`faker`尚未安装--但为什么呢？我们不是已经安装了 `faker`吗？"

#: docs/en/tutorial/tutorial-7.md:445
#, fuzzy
msgid ""
"We have - but only in the development environment. Your development "
"environment is entirely local to your machine - and is only enabled when you"
" explicitly activate it. Although Briefcase has a development mode, the main"
" reason you'd use Briefcase is to package up your code so you can give it to"
" someone else."
msgstr ""
"我们有，但仅限于开发环境。你的开发环境完全在你的机器本地，只有当你明确激活它时才会启用。虽然公文包有开发模式，但使用公文包的主要原因是打包你的代码，这样你就可以把它交给别人。"

#: docs/en/tutorial/tutorial-7.md:447
#, fuzzy
msgid ""
"The only way to guarantee that someone else will have a Python environment "
"that contains everything it needs is to build a completely isolated Python "
"environment. This means there's a completely isolated Python install, and a "
"completely isolated set of dependencies. This is what Briefcase is building "
"when you run `briefcase build` - an isolated Python environment. This also "
"explains why `faker` isn't installed - it has been installed in your "
"*development* environment, but not in the packaged app."
msgstr ""
"要保证别人的 Python 环境包含它所需要的一切，唯一的办法就是构建一个完全隔离的 Python 环境。这意味着有一个完全独立的 Python "
"安装，和一套完全独立的依赖关系。这就是当你运行 `briefcase build` 时，Briefcase 正在构建的 - 一个隔离的 Python "
"环境。这也解释了为什么没有安装 `httpx` - 它已经安装在你的开发环境中，但没有安装在打包的应用程序中。"

#: docs/en/tutorial/tutorial-7.md:449
#, fuzzy
msgid ""
"So - we need to tell Briefcase that our app has an external dependency."
msgstr "因此，我们需要告诉 Briefcase，我们的应用程序有一个外部依赖关系。"

#: docs/en/tutorial/tutorial-7.md:451
#, fuzzy
msgid "Updating dependencies"
msgstr "更新依赖项"

#: docs/en/tutorial/tutorial-7.md:453
#, fuzzy
msgid ""
"In the root directory of your app, there is a file named `pyproject.toml`. "
"This file contains all the app configuration details that you provided when "
"you originally ran `briefcase new`."
msgstr ""
"在应用程序的根目录中，有一个名为 `pyproject.toml` 的文件。该文件包含您最初运行 `briefcase new` "
"时提供的所有应用程序配置详细信息。"

#: docs/en/tutorial/tutorial-7.md:455
#, fuzzy
msgid ""
"`pyproject.toml` is broken up into sections; one of the sections describes "
"the settings for your app:"
msgstr "pyproject.toml \"分为多个部分，其中一部分描述了应用程序的设置：："

#: docs/en/tutorial/tutorial-7.md:467
#, fuzzy
msgid ""
"The `requires` option describes the dependencies of our application. It is a"
" list of strings, specifying libraries (and, optionally, versions) of "
"libraries that you want to be included with your app."
msgstr "requires \"选项描述了应用程序的依赖关系。它是一个字符串列表，其中指定了您希望应用程序包含的库（以及可选的版本）。"

#: docs/en/tutorial/tutorial-7.md:469
#, fuzzy
msgid "Modify the `requires` setting so that it reads:"
msgstr "修改 `requires` 设置为：："

#: docs/en/tutorial/tutorial-7.md:477
#, fuzzy
msgid ""
"By adding this setting, we're telling Briefcase \"when you build my app, run"
" `pip install faker` into the application bundle\". Anything that would be "
"legal input to `pip install` can be used here - so, you could specify:"
msgstr ""
"通过添加此设置，我们告诉 Briefcase \"当你构建我的应用程序时，运行 `pip install httpx` "
"到应用程序捆绑包中\"。任何可以合法输入到 `pip install` 的内容都可以在这里使用--因此，你可以指定："

#: docs/en/tutorial/tutorial-7.md:479
#, fuzzy
msgid "A specific library version (e.g., `\"faker==37.3.0\"`);"
msgstr "特定的库版本（例如， `\"httpx===0.19.0\"` ）;"

#: docs/en/tutorial/tutorial-7.md:480
#, fuzzy
msgid "A range of library versions (e.g., `\"faker>=37\"`);"
msgstr "一系列库版本（例如， `\"httpx>=0.19\"` ）;"

#: docs/en/tutorial/tutorial-7.md:481
#, fuzzy
msgid ""
"A path to a git repository (e.g., "
"`\"git+https://github.com/joke2k/faker/\"`); or"
msgstr "指向 git 仓库的路径（例如，`\"git+https://github.com/encode/httpx\"`）；或"

#: docs/en/tutorial/tutorial-7.md:482
msgid ""
"A local file path (However - be warned: if you give your code to someone "
"else, this path probably won't exist on their machine!)"
msgstr "本地文件路径（不过需要注意的是：如果你把代码交给别人，这个路径很可能不存在于他们的机器上！）"

#: docs/en/tutorial/tutorial-7.md:484
#, fuzzy
msgid ""
"Further down in `pyproject.toml`, you'll notice other sections that are "
"operating system dependent, like `[tool.briefcase.app.helloworld.macOS]` and"
" `[tool.briefcase.app.helloworld.windows]`. These sections *also* have a "
"`requires` setting. These settings allow you to define additional platform-"
"specific dependencies - so, for example, if you need a platform-specific "
"library to handle some aspect of your app, you can specify that library in "
"the platform-specific `requires` section, and that setting will only be used"
" for that platform. You will notice that the `toga` libraries are all "
"specified in the platform-specific `requires` section - this is because the "
"libraries needed to display a user interface are platform specific."
msgstr ""
"在 `pyproject.toml` 中的更下面部分，你会注意到与操作系统相关的其他部分，如 "
"`[tool.briefcase.app.helloworld.macOS]` 和 "
"`[tool.briefcase.app.helloworld.windows]`。这些部分**也有一个 `requires` "
"设置。这些设置允许你定义额外的特定平台依赖关系，例如，如果你需要一个特定平台的库来处理应用程序的某些方面，你可以在特定平台的 `requires` "
"部分中指定该库，而该设置将仅用于该平台。你会注意到，所有的 `toga` 库都是在特定平台的 `requires` "
"部分中指定的，这是因为显示用户界面所需的库都是特定平台的。"

#: docs/en/tutorial/tutorial-7.md:486
#, fuzzy
msgid ""
"In our case, we want `faker` to be installed on all platforms, so we use the"
" app-level `requires` setting. The app-level dependencies will always be "
"installed; the platform-specific dependencies are installed *in addition* to"
" the app-level ones."
msgstr ""
"在我们的例子中，我们希望 `httpx` 安装在所有平台上，因此使用了应用程序级的 `requires` "
"设置。应用程序级的依赖项始终会被安装；特定平台的依赖项会在应用程序级的依赖项之外*安装。"

#: docs/en/tutorial/tutorial-7.md:488
#, fuzzy
msgid ""
"Now that we've told Briefcase about our additional requirements, we can try "
"packaging our app again. Ensure that you've saved your changes to "
"`pyproject.toml`, and then update your app again - this time, passing in the"
" `-r` flag. This tells Briefcase to update requirements in the packaged app:"
msgstr ""
"既然我们已经告诉了 Briefcase 我们的额外需求，那么我们就可以再次尝试打包应用程序了。确保已将更改保存到 "
"`pyproject.toml`，然后再次更新应用程序--这一次，传递 `-r` 标志。这将告诉 Briefcase 更新打包应用程序中的需求："

#: docs/en/tutorial/tutorial-7.md:608
#, fuzzy
msgid ""
"Once you've updated, you can run `briefcase build` and `briefcase run` - and"
" you should see your packaged app, with the new dialog behavior."
msgstr ""
"更新完成后，您可以运行 `briefcase build` 和 `briefcase run` - 您应该会看到打包后的应用程序，并带有新的对话框行为。"

#: docs/en/tutorial/tutorial-7.md:612
#, fuzzy
msgid ""
"The `-r` option for updating requirements is also honored by the `build` and"
" `run` command, so if you want to update, build, and run in one step, you "
"could use `briefcase run -u -r`."
msgstr ""
"用于更新需求的 `-r` 选项也会被 `build` 和 `run` 命令接受，因此如果你想一步完成更新、编译和运行，可以使用 `briefcase "
"run -u -r`。"

#: docs/en/tutorial/tutorial-7.md:616
#, fuzzy
msgid "Third-Party Python Packages for Mobile and Web"
msgstr "用于移动和网络的第三方 Python 软件包"

#: docs/en/tutorial/tutorial-7.md:618
#, fuzzy
msgid ""
"Faker is just one example of a third-party Python package - a collection of "
"code that isn't part what Python provides out of the box. These third-party "
"packages are most commonly distributed using the [Python Package Index "
"(PyPI)]{1}, and installed into your local virtual environment. We've been "
"using `pip` in this tutorial, but there are other options."
msgstr ""
"Faker 只是第三方 Python 软件包的一个例子，它是 Python 开箱即用之外的代码集合。这些第三方软件包通常使用 [Python "
"Package Index (PyPI)]{1} 发布，并安装到本地虚拟环境中。我们在本教程中使用了 `pip`，但也有其他选择。"

#: docs/en/tutorial/tutorial-7.md:620
#, fuzzy
msgid ""
"On desktop platforms (macOS, Windows, Linux), essentially any package on "
"PyPI package can be installed into your virtual environment, or added to "
"your app's requirements. However, when building an app for mobile or web "
"platforms, [your options are slightly limited]{1}."
msgstr ""
"在桌面平台（macOS、Windows、Linux）上，任何可安装的 \"pip "
"\"都可以添加到您的需求中。在移动和网络平台上，[您的选择略显有限]{1}。"

#: docs/en/tutorial/tutorial-7.md:622
#, fuzzy
msgid ""
"In short; any *pure Python* package (i.e. any package created from a project"
" written *only* in Python) can be used without difficulty. Some packages, "
"though, are created from projects that contain both Python and other "
"languages (e.g. C, C++, Rust, etc). Code written in those languages needs to"
" be compiled to platform-specific binary modules before it can be used, and "
"those pre-compiled binary modules are only available on specific platforms. "
"Mobile and web platforms have very different requirements than \"standard\" "
"desktop platforms. At this time, most Python packages don't provide pre-"
"compiled binaries for mobile and web platforms."
msgstr ""
"简而言之，任何*纯 Python* 包（即从*仅*用 Python 编写的项目中创建的包）都可以毫无困难地使用。不过，有些软件包是由包含 Python "
"和其他语言（如 C、C++、Rust "
"等）的项目创建的。使用这些语言编写的代码需要编译成特定平台的二进制模块才能使用，而这些预编译的二进制模块只能在特定平台上使用。移动平台和网络平台的要求与"
" \"标准 \"桌面平台截然不同。目前，大多数 Python 软件包都没有为移动平台和网络平台提供预编译二进制文件。"

#: docs/en/tutorial/tutorial-7.md:624
#, fuzzy
msgid ""
"On PyPI, packages are often provided in a pre-built distribution format "
"called *wheels*. To check whether a package is pure Python, look at the PyPI"
" downloads page for the project. If the wheels provided have a `-py3-none-"
"any.whl` suffix (e.g., [Faker]{1}), then they are pure Python wheels. "
"However, if the wheels have version and platform-specific extensions (e.g., "
"[Pillow]{2}, which has wheels with suffixes like "
"`-cp313-cp313-macosx_11_0_arm64.whl` and `-cp39-cp39-win_amd64.whl`), then "
"the wheel *contains a binary component*. That package cannot be installed on"
" mobile or web platforms unless a wheel compatible with those platforms has "
"been provided."
msgstr ""
"在 PyPI 上，软件包通常以一种名为 *wheels* 的预构建发布格式提供。要检查某个软件包是否是纯 Python，请查看该项目的 PyPI "
"下载页面。如果提供的轮子后缀是 `-py3-none-any.whl`（例如 [Faker]{1}），那么它们就是纯 Python "
"轮子。但是，如果这些轮子有特定版本和平台的扩展（例如 [Pillow]{2}，它的轮子后缀是 "
"`-cp313-cp313-macosx_11_0_arm64.whl` 和 "
"`cp39-cp39-win_amd64.whl`），那么这个轮子*包含一个二进制组件*。除非提供了与移动或网络平台兼容的滚轮，否则该软件包无法安装在这些平台上。"

#: docs/en/tutorial/tutorial-7.md:626
#, fuzzy
msgid ""
"At this time, *most* binary packages on PyPI don't provide mobile- or web-"
"compatible wheels. To fill this gap, BeeWare provides binaries for some "
"popular binary modules (including `numpy`, `pandas`, and `cryptography`). "
"These wheels are *not* distributed on PyPI, but Briefcase will install those"
" wheels if they're available."
msgstr ""
"目前，PyPI上**多的二进制包都没有提供移动或网络兼容的轮子。为了填补这一空白，BeeWare 为一些流行的二进制模块（包括 "
"`numpy`、`pandas` 和 `cryptography`）提供了二进制文件。这些轮子**没有发布在 PyPI "
"上，但如果这些轮子可用，Briefcase 会安装它们。"

#: docs/en/tutorial/tutorial-7.md:628
msgid ""
"It's *usually* possible to compile binary packages for mobile platforms, but"
" it's not easy to set up -- well outside the scope of an introductory "
"tutorial like this one."
msgstr "*通常*\\ 可以为移动平台编译二进制软件包，但是不容易设置，且远超出了本教程这样的入门教程涵盖的范围。"

#: docs/en/tutorial/tutorial-7.md:632
#, fuzzy
msgid ""
"We've now got an app that uses a third-party library! In [Tutorial 8]{1} "
"we'll learn how to ensure our app remains responsive as we add more complex "
"application logic."
msgstr "我们现在有了一个使用第三方库的应用程序！在 [教程 8]{1} 中，我们将学习如何在添加更复杂的应用程序逻辑时确保应用程序保持响应。"

#: docs/en/tutorial/tutorial-8.md:1
#, fuzzy
msgid "Tutorial 8 - Making it Smooooth"
msgstr "教程 8 - 使其光滑"

#: docs/en/tutorial/tutorial-8.md:3
msgid ""
"So far, our application has been relatively simple - displaying GUI widgets,"
" calling a simple third-party library, and displaying output in a dialog. "
"All these operations happen very quickly, and our application remains "
"responsive."
msgstr ""
"到目前为止，我们的应用程序相对简单——显示图形用户界面控件、调用一个简单的第三方库，以及在对话框中显示输出。所有这些操作都非常迅速，我们的应用程序始终保持响应。"

#: docs/en/tutorial/tutorial-8.md:5
msgid ""
"However, in a real world application, we'll need to perform complex tasks or"
" calculations that may take a while to complete - and as those tasks are "
"performed, we want our application to remain responsive. Let's make a change"
" to our application that might take a little time to complete, and see the "
"changes that need to be made to accommodate that behavior."
msgstr ""
"但是，在实际的应用中，我们将需要进行会需要一会儿才能完成的复杂任务。当这些任务进行时，我们想让我们的应用保持响应。让我们更改我们的应用程序，添加一个需要一些时间才能完成的任务，并看看需要怎样更改应用程序，适应这个新的行为。"

#: docs/en/tutorial/tutorial-8.md:7
msgid "Accessing an API"
msgstr "访问 API"

#: docs/en/tutorial/tutorial-8.md:9
msgid ""
"A common time-consuming task an app will need to perform is to make a "
"request on a web API to retrieve data, and display that data to the user. "
"Web APIs sometimes take a second or two to respond, so if we're calling an "
"API like that, we need to ensure our application doesn't become unresponsive"
" while we wait for the web API to return an answer."
msgstr ""
"应用程序需要进行的一个常见的耗时任务时在一个网络 API 上请求取回数据，并将数据显示给用户。网络 API "
"有时需要一两秒才能回应，所以如果我们将要访问这种 API，我们需要确保我们的应用在等待网络 API 返回答案时保持响应。"

#: docs/en/tutorial/tutorial-8.md:11
msgid ""
"This is a toy app, so we don't have a *real* API to work with, so we'll use "
"the [{JSON} Placeholder API]{1} as a source of data. The {JSON} Placeholder "
"API has a number of \"fake\" API endpoints you can use as test data. One of "
"those APIs is the `/posts/` endpoint, which returns fake blog posts. If you "
"open `https://jsonplaceholder.typicode.com/posts/42` in your browser, you'll"
" get a JSON payload describing a single post - some [Lorum ipsum]{2} content"
" for a blog post with ID 42."
msgstr ""
"这只是个入门级的应用，我们没有*真正*的API可供调用，所以我们将使用[{JSON}占位符API]{1} "
"作为数据来源。{JSON}占位符API有一系列“虚假”的API端点可以供您作为测试数据调用。其中之一就是`/posts/`端点，它会返回一些虚假的博客推文。如果您在浏览器中访问`https://jsonplaceholder.typicode.com/posts/42`，您将会得到一串看起来像是在发推文的JSON数据——不过内容是ID为42的一些`乱数假文"
" [Lorum ipsum]{2}。"

#: docs/en/tutorial/tutorial-8.md:13
msgid ""
"The Python standard library contains all the tools you'd need to access an "
"API. However, the built-in APIs are very low level. They are good "
"implementations of the HTTP protocol - but they require the user to manage "
"lots of low-level details, like URL redirection, sessions, authentication, "
"and payload encoding. As a \"normal browser user\" you're probably used to "
"taking these details for granted, as a browser manages them for you."
msgstr ""
"Python 标准库包含了需要访问一个 API 的所有工具，但这些内置 API 非常低级别。它们良好的实现了 HTTP 协议，但它们要求用户管理 URL"
" 重定向、会话、身份验证、数据编码等许多低级别细节。作为一个 “普通浏览器用户”，您可能会把这些细节的管理是为理所当然的，因为浏览器帮您管理它们。"

#: docs/en/tutorial/tutorial-8.md:15
#, fuzzy
msgid ""
"As a result, people have developed third-party libraries that wrap the "
"built-in APIs and provide a simpler API that is a closer match for the "
"everyday browser experience. We're going to use one of those libraries to "
"access the {JSON} Placeholder API - a library called [`httpx`]{1}. Briefcase"
" uses `httpx` internally, so it's already in your local environment - you "
"don't need to install it separately to use it here."
msgstr ""
"因此，人们开发了第三方库来封装内置 API，并提供更简单的 API，使其更符合日常的浏览器体验。我们将使用其中一个库来访问 {JSON}占位符 API "
"- 一个名为 [`httpx`]{1} 的库。公文包在内部使用 `httpx`，因此它已经存在于本地环境中，无需单独安装即可在此使用。"

#: docs/en/tutorial/tutorial-8.md:17
#, fuzzy
msgid ""
"Let's add a `httpx` API call to our app. Modify the `requires` setting in "
"our `pyproject.toml` to include the new requirement:"
msgstr ""
"让我们为应用程序添加一个 `httpx` API 调用。修改我们的 `pyproject.toml` 中的 `requires` 设置，以包含新需求："

#: docs/en/tutorial/tutorial-8.md:26
#, fuzzy
msgid "Add an import to the top of the `app.py` to import `httpx`:"
msgstr "在 `app.py` 顶部添加导入，以导入 `httpx`："

#: docs/en/tutorial/tutorial-8.md:50
#, fuzzy
msgid ""
"This will change the `say_hello()` callback so that when it is invoked, it "
"will:"
msgstr "这将更改`say_hello()` 回调，使其在被调用时，会"

#: docs/en/tutorial/tutorial-8.md:52
#, fuzzy
msgid "make a GET request on the JSON placeholder API to obtain post 42;"
msgstr "在 JSON 占位符 API 上发出 GET 请求，以获取职位 42；"

#: docs/en/tutorial/tutorial-8.md:53
#, fuzzy
msgid "decode the response as JSON;"
msgstr "将响应解码为 JSON 格式；"

#: docs/en/tutorial/tutorial-8.md:54
#, fuzzy
msgid "extract the body of the post; and"
msgstr "提取帖子正文；以及"

#: docs/en/tutorial/tutorial-8.md:55
#, fuzzy
msgid ""
"include the body of that post as the text of the \"message\" dialog, in "
"place of the text generated by Faker."
msgstr "在 \"消息 \"对话框中加入该帖子的正文，取代 Faker 生成的文本。"

#: docs/en/tutorial/tutorial-8.md:57
#, fuzzy
msgid ""
"Lets run our updated app in Briefcase developer mode to check that our "
"change has worked. As we've added a new requirement, we need to tell "
"developer mode to reinstall requirements, by using the `-r` argument:"
msgstr ""
"让我们在 Briefcase 开发人员模式下运行更新后的应用程序，检查我们的更改是否有效。由于我们添加了一个新需求，因此需要使用 `-r` "
"参数告诉开发者模式重新安装需求："

#: docs/en/tutorial/tutorial-8.md:72
#, fuzzy
msgid "![Hello World Tutorial 8 dialog, on macOS]{1}"
msgstr "![《Hello World》教程 8 对话框，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-8.md:93
#, fuzzy
msgid "![Hello World Tutorial 8 dialog, on Linux]{1}"
msgstr "![Hello World 教程 8 对话框，在 Linux 上]{1}!"

#: docs/en/tutorial/tutorial-8.md:114
#, fuzzy
msgid "![Hello World Tutorial 8 dialog, on Windows]{1}"
msgstr "![Hello World 教程 8 对话框，在 Windows 上]{1}!"

#: docs/en/tutorial/tutorial-8.md:134
#, fuzzy
msgid ""
"Unless you've got a *really* fast internet connection, you may notice that "
"when you press the button, the GUI for your app locks up for a little bit. "
"The operating system may even manifest this with a \"beachball\" or "
"\"spinner\" cursor to indicate that the app is being unresponsive."
msgstr ""
"除非你的网络连接速度非常快，否则你可能会发现，当你按下按钮时，应用程序的图形用户界面会锁定一小会儿。操作系统甚至会用 \"沙滩球 \"或 \"旋转器 "
"\"光标来表示应用程序反应迟钝。"

#: docs/en/tutorial/tutorial-8.md:136
msgid ""
"This is because the web request we have made is *synchronous*. When our "
"application makes the web request, it waits for the API to return a response"
" before continuing. While it's waiting, it *isn't* allowing the application "
"to redraw - and as a result, the application locks up."
msgstr ""
"除非您的网络连接速度*非常*快，否则您可能会注意到，当您按下按钮时，应用程序的图形用户界面会锁定一会儿。这是因为我们发出的网络请求是\\ *同步*\\ "
"的。当我们的应用程序发出网络请求时，它会等待应用程序接口返回响应，然后再继续。在等待的过程中，应用程序*不*允许重新绘制，结果导致应用程序锁定。"

#: docs/en/tutorial/tutorial-8.md:138
msgid "GUI Event Loops"
msgstr "图形用户界面事件循环"

#: docs/en/tutorial/tutorial-8.md:140
msgid ""
"To understand why this happens, we need to dig into the details of how a GUI"
" application works. The specifics vary depending on the platform; but the "
"high level concepts are the same, no matter the platform or GUI environment "
"you're using."
msgstr ""
"要理解为什么会出现这种情况，我们需要深入了解图形用户界面应用程序的工作原理。具体细节因平台而异，但无论使用何种平台或图形用户界面环境，高层概念都是相同的。"

#: docs/en/tutorial/tutorial-8.md:142
msgid "A GUI app is, fundamentally, a single loop that looks something like:"
msgstr "从根本上说，图形用户界面应用程序就是一个单一的循环，看起来就像:"

#: docs/en/tutorial/tutorial-8.md:150
#, fuzzy
msgid ""
"This loop is called the *Event Loop*. (These aren't actual method names - "
"it's an illustration of what is going on using \"pseudo-code\")."
msgstr "这个循环被称为 *事件循环*。(这些并不是实际的方法名称，而是 \"伪代码 \"的说明）。"

#: docs/en/tutorial/tutorial-8.md:152
#, fuzzy
msgid ""
"When you click on a button, or drag a scroll bar, or type a key, you are "
"generating an \"event\". That \"event\" is put onto a queue, and the app "
"will process the queue of events when it next has the opportunity to do so. "
"The user code that is triggered in response to the event is called an *event"
" handler*. These event handlers are invoked as part of the "
"`process_events()` call."
msgstr ""
"当你点击一个按钮、拖动一个滚动条或输入一个键时，你就产生了一个 \"事件\"。该 \\\"事件 "
"\"被放入一个队列，应用程序将在下一次有机会时处理队列中的事件。为响应事件而触发的用户代码称为*事件处理程序*。这些事件处理程序作为`process_events()`调用的一部分被调用。"

#: docs/en/tutorial/tutorial-8.md:154
msgid ""
"Once an app has processed all the available events, it will `redraw()` the "
"GUI. This takes into account any changes that the events have caused to the "
"display of the app, as well as anything else that is going on in the "
"operating system - for example, the windows of another app may obscure or "
"reveal part of our app's window, and our app's redraw will need to reflect "
"the portion of the window that is currently visible."
msgstr ""
"应用程序处理完所有可用事件后，就会 重绘 "
"（`redraw()`）图形用户界面。这将考虑到事件对应用程序显示所造成的任何变化，以及操作系统中发生的任何其他情况，例如，其他应用程序的窗口可能会遮挡或显示我们应用程序的部分窗口，而我们应用程序的重绘将需要反映当前可见的窗口部分。"

#: docs/en/tutorial/tutorial-8.md:156
#, fuzzy
msgid ""
"The important detail to notice: while an application is processing an event,"
" *it can't redraw*, and *it can't process other events*."
msgstr "需要注意的重要细节是：当应用程序在处理事件时，*不能重绘*，*也不能处理其他事件*。"

#: docs/en/tutorial/tutorial-8.md:158
#, fuzzy
msgid ""
"This means any user logic contained in an event handler needs to complete "
"quickly. Any delay in completing the event handler will be observed by the "
"user as a slowdown (or stop) in GUI updates. If this delay is long enough, "
"your operating system may report this as a problem - the macOS \"beachball\""
" and Windows \"spinner\" icons are the operating system telling you that "
"your app is taking too long in an event handler."
msgstr ""
"这意味着事件处理程序中包含的任何用户逻辑都需要快速完成。完成事件处理程序的任何延迟都会被用户观察到，表现为图形用户界面更新的减慢（或停止）。如果延迟时间足够长，操作系统可能会将此报告为问题"
"--macOS 的 \"沙滩球 \"和 Windows 的 \"旋转器 \"图标就是操作系统在告诉你，你的应用程序在事件处理程序中耗时过长。"

#: docs/en/tutorial/tutorial-8.md:160
#, fuzzy
msgid ""
"Simple operations like \"update a label\", or \"recompute the total of the "
"inputs\" are easy to complete quickly. However, there are a lot of "
"operations that can't be completed quickly. If you're performing a complex "
"mathematical calculation, or indexing all the files on a file system, or "
"performing a large network request, you can't \"just do it quickly\" - the "
"operations are inherently slow."
msgstr ""
"像 \"更新标签 \"或 \"重新计算输入总和 "
"\"这样的简单操作很容易快速完成。然而，有很多操作是无法快速完成的。如果要执行复杂的数学计算，或为文件系统中的所有文件编制索引，或执行大型网络请求，就不能"
" \"快速完成\"--这些操作本身就很慢。"

#: docs/en/tutorial/tutorial-8.md:162
#, fuzzy
msgid "So - how do we perform long-lived operations in a GUI application?"
msgstr "那么，我们如何在图形用户界面应用程序中执行长期操作呢？"

#: docs/en/tutorial/tutorial-8.md:164
#, fuzzy
msgid "Asynchronous programming"
msgstr "异步编程"

#: docs/en/tutorial/tutorial-8.md:166
#, fuzzy
msgid ""
"What we need is a way to tell an app in the middle of a long-lived event "
"handler that it is OK to temporarily release control back to the event loop,"
" as long as we can resume where we left off. It's up to the app to determine"
" when this release can occur; but if the app releases control to the event "
"loop regularly, we can have a long-running event handler *and* maintain a "
"responsive UI."
msgstr ""
"我们需要的是一种方法，让处于长期事件处理程序中间的应用程序知道，只要我们能从上次中断的地方继续运行，就可以暂时将控制权释放回事件循环。应用程序可以自行决定何时释放控制权；但如果应用程序定期向事件循环释放控制权，我们就可以拥有一个长期运行的事件处理程序，并**保持响应式用户界面。"

#: docs/en/tutorial/tutorial-8.md:168
#, fuzzy
msgid ""
"We can do this by using *asynchronous programming*. Asynchronous programming"
" is a way to describe a program that allows the interpreter to run multiple "
"functions at the same time, sharing resources between all the concurrently "
"running functions."
msgstr "我们可以通过使用*异步编程*来实现这一点。异步编程是一种描述程序的方法，它允许解释器同时运行多个函数，在所有并发运行的函数之间共享资源。"

#: docs/en/tutorial/tutorial-8.md:170
#, fuzzy
msgid ""
"Asynchronous functions (known as *coroutines*) need to be explicitly "
"declared as being asynchronous. They also need to internally declare when an"
" opportunity exists to change context to another coroutine."
msgstr "异步函数（称为 * 协同例程*）需要明确声明为异步函数。它们还需要在内部声明何时有机会将上下文切换到另一个共同例程。"

#: docs/en/tutorial/tutorial-8.md:172
#, fuzzy
msgid ""
"In Python, asynchronous programming is implemented using the `async` and "
"`await` keywords, and the [asyncio]{1} module in the standard library. The "
"`async` keyword allows us to declare that a function is an asynchronous "
"coroutine. The `await` keyword provides a way to declare when an opportunity"
" exists to change context to another coroutine. The [asyncio]{2} module "
"provides some other useful tools and primitives for asynchronous coding."
msgstr ""
"在 Python 中，异步编程是通过 `async` 和 `await` 关键字以及标准库中的 [asyncio]{1} 模块来实现的。[async` "
"关键字允许我们声明一个函数是异步协程。关键字 `await` 提供了一种方法来声明何时有机会将上下文切换到另一个协程。[asyncio]{2} "
"模块为异步编码提供了一些其他有用的工具和原语。"

#: docs/en/tutorial/tutorial-8.md:174
#, fuzzy
msgid "Making the tutorial asynchronous"
msgstr "使教程异步化"

#: docs/en/tutorial/tutorial-8.md:176
#, fuzzy
msgid ""
"To make our tutorial asynchronous, modify the `say_hello()` event handler so"
" it looks like this:"
msgstr "为了使我们的教程成为异步教程，请修改事件处理程序 \"say_hello()\"，使其看起来像这样：："

#: docs/en/tutorial/tutorial-8.md:194
#, fuzzy
msgid ""
"There are only three changes to this callback from the previous version:"
msgstr "与上一版本相比，该代码只有 4 处改动："

#: docs/en/tutorial/tutorial-8.md:196
#, fuzzy
msgid ""
"The client that is created is an asynchronous `AsyncClient()`, rather than a"
" synchronous `Client()`. This tells `httpx` that it should operate in "
"asynchronous mode, rather than synchronous mode."
msgstr ""
"创建的客户端是异步的 `AsyncClient()` 而不是同步的 `Client()[。这就告诉 `httpx` 应在异步模式而非同步模式下运行。"

#: docs/en/tutorial/tutorial-8.md:197
#, fuzzy
msgid ""
"The context manager used to create the client is marked as `async`. This "
"tells Python that there is an opportunity to release control as the context "
"manager is entered and exited."
msgstr "用于创建客户端的上下文管理器被标记为 `async`。这就告诉 Python，当上下文管理器进入和退出时，有机会释放控制。"

#: docs/en/tutorial/tutorial-8.md:198
#, fuzzy
msgid ""
"The `get` call is made with an `await` keyword. This instructs the app that "
"while we are waiting for the response from the network, the app can release "
"control to the event loop. We've seen this keyword before - we also use "
"`await` when displaying the dialog box. The reason for that usage is the "
"same as it is for the HTTP request - we need to tell the app that while the "
"dialog is displayed, and we're waiting for the user to push a button, it's "
"OK to release control back to the event loop."
msgstr ""
"get \"调用带有 \"等待 \"关键字。这指示应用程序在等待网络响应时，可以将控制权释放给事件循环。我们以前见过这个关键字--"
"在显示对话框时我们也使用了`await`。使用该关键字的原因与 HTTP 请求相同--"
"我们需要告诉应用程序，在显示对话框并等待用户按下按钮时，可以将控制权释放回事件循环。"

#: docs/en/tutorial/tutorial-8.md:200
#, fuzzy
msgid ""
"It's also important to note that the handler itself is defined as `async "
"def`, rather than just `def`. This tells Python that the method is an "
"asynchronous coroutine. We made this change back in Tutorial 3 when we added"
" the dialog box. You can only use `await` statements inside a method that is"
" declared as `async def`."
msgstr ""
"还需要注意的是，处理程序本身被定义为 `async def`，而不仅仅是 `def`。这告诉 Python 该方法是一个异步的例程。我们在教程 3 "
"中添加对话框时做了这一更改。您只能在声明为 `async def` 的方法中使用 `await` 语句。"

#: docs/en/tutorial/tutorial-8.md:202
#, fuzzy
msgid ""
"Toga allows you to use regular methods or asynchronous coroutines as "
"handlers; Toga manages everything behind the scenes to make sure the handler"
" is invoked or awaited as required."
msgstr "Toga 允许你使用常规方法或异步协程作为处理程序；Toga 在幕后管理一切，确保处理程序按要求被调用或等待。"

#: docs/en/tutorial/tutorial-8.md:204
#, fuzzy
msgid ""
"If you save these changes and re-run the app in development mode, there "
"won't be any obvious changes to the app. However, when you click on the "
"button to trigger the dialog, you may notice a number of subtle "
"improvements:"
msgstr ""
"如果保存这些更改并重新运行应用程序（在开发模式下使用 `briefcase dev` "
"或更新并重新运行打包的应用程序），应用程序不会有任何明显的变化。不过，当您点击按钮触发对话框时，您可能会注意到一些细微的改进："

#: docs/en/tutorial/tutorial-8.md:206
#, fuzzy
msgid ""
"The button returns to an \"unclicked\" state, rather than being stuck in a "
"\"clicked\" state."
msgstr "按钮会返回到 \"未点击 \"状态，而不是停留在 \"已点击 \"状态。"

#: docs/en/tutorial/tutorial-8.md:207
#, fuzzy
msgid "The \"beachball\"/\"spinner\" icon won't appear."
msgstr "沙滩球\"/\"旋转器 \"图标不会出现。"

#: docs/en/tutorial/tutorial-8.md:208
msgid ""
"If you move/resize the app window while waiting for the dialog to appear, "
"the window will redraw."
msgstr "如果在等待对话框出现时移动或调整应用程序窗口的大小，窗口将重新绘制。"

#: docs/en/tutorial/tutorial-8.md:209
#, fuzzy
msgid "If you try to open an app menu, the menu will appear immediately."
msgstr "如果尝试打开应用程序菜单，菜单会立即出现。"

#: docs/en/tutorial/tutorial-8.md:211
#, fuzzy
msgid ""
"We can now run the full app. However, as we've added an extra requirement "
"(`httpx`) we also need to update our app's requirements; we can do this by "
"passing `-r` to `briefcase run`. This will update our app's requirements, "
"then re-build the app, then launch the app:"
msgstr ""
"现在我们可以运行完整的应用程序了。不过，由于我们添加了一个额外的需求（`httpx`），因此还需要更新应用程序的需求；我们可以通过向 "
"`briefcase run` 传递 `-r` 来做到这一点。这将更新应用程序的需求，然后重新构建应用程序，最后启动应用程序："

#: docs/en/tutorial/tutorial-8.md:253
#, fuzzy
msgid ""
"You should see you app running, and remaining responsive when you press the "
"button and network content is retrieved."
msgstr "当您按下按钮并检索网络内容时，您应该会看到应用程序正在运行并保持响应。"

#: docs/en/tutorial/tutorial-8.md:257
#, fuzzy
msgid ""
"This has been a taste for what you can do with the tools provided by the "
"BeeWare project. Over the course of this tutorial, you have:"
msgstr "通过本教程，您可以了解到 BeeWare 项目提供的工具可以做些什么。在本教程中，您可以"

#: docs/en/tutorial/tutorial-8.md:259
#, fuzzy
msgid "Created a new GUI app project;"
msgstr "创建一个新的图形用户界面应用程序项目；"

#: docs/en/tutorial/tutorial-8.md:260
#, fuzzy
msgid "Run that app in development mode;"
msgstr "在开发者模式下运行应用程序"

#: docs/en/tutorial/tutorial-8.md:261
#, fuzzy
msgid "Built the app as a standalone binary for a desktop operating system;"
msgstr "将应用程序作为桌面操作系统的独立二进制文件构建；"

#: docs/en/tutorial/tutorial-8.md:262
#, fuzzy
msgid "Packaged that project for distribution to others;"
msgstr "将该项目打包分发给其他人；"

#: docs/en/tutorial/tutorial-8.md:263
#, fuzzy
msgid "Run the app on a mobile simulator and/or device;"
msgstr "在移动模拟器和/或设备上运行应用程序；"

#: docs/en/tutorial/tutorial-8.md:264
#, fuzzy
msgid "Run the app as a web app;"
msgstr "将应用程序作为网络应用程序运行；"

#: docs/en/tutorial/tutorial-8.md:265
#, fuzzy
msgid "Added a third-party dependency to your app; and"
msgstr "在应用程序中添加了第三方依赖；以及"

#: docs/en/tutorial/tutorial-8.md:266
#, fuzzy
msgid "Modified the app so that it remains responsive."
msgstr "修改应用程序，使其保持响应速度。"

#: docs/en/tutorial/tutorial-8.md:268
#, fuzzy
msgid "So - where to from here?"
msgstr "那么--何去何从？"

#: docs/en/tutorial/tutorial-8.md:270
#, fuzzy
msgid ""
"If you'd like to go further, there are some additional [topic tutorials]{1} "
"that go into detail on specific aspects of application development."
msgstr "如果你想进一步了解，还有一些额外的 [主题教程]{1}，详细介绍了应用程序开发的具体方面。"

#: docs/en/tutorial/tutorial-8.md:271
#, fuzzy
msgid ""
"If you'd like to know more about how to build complex user interfaces with "
"Toga, you can dive into [Toga's documentation]{1}. Toga also has its own "
"tutorial [demonstrating how to use various features of the widget "
"toolkit]{2}."
msgstr ""
"如果你想进一步了解如何使用 Toga 构建复杂的用户界面，可以查阅 [Toga 文档]{1}。Toga 也有自己的教程[演示如何使用 widget "
"工具包的各种功能]{2}。"

#: docs/en/tutorial/tutorial-8.md:273
#, fuzzy
msgid ""
"If you'd like to know more about the capabilities of Briefcase, you can dive"
" into [Briefcase's documentation]{1}."
msgstr "如果你想了解更多有关公文包功能的信息，可以查阅[公文包文档]{1}。"

#, fuzzy
#~ msgid ""
#~ "Xcode and the Command-line Developer Tools provide a version of Python; "
#~ "however that Python is version 3.9. Python 3.9 has reached end-of-life, and "
#~ "is no longer supported by Python or BeeWare. You will *not* be able to the "
#~ "Xcode-provided version of Python to run this tutorial."
#~ msgstr ""
#~ "Xcode 和命令行开发工具提供了一个 Python 版本，但该 Python 版本为 3.9。Python 3.9 已达到生命周期终点，Python "
#~ "或 BeeWare 不再支持该版本。您将**无法使用 Xcode 提供的 Python 版本来运行本教程。"

#~ msgid ""
#~ "Your Windows account doesn't have permissions to run scripts. To fix this:"
#~ msgstr "您的 Windows 账户没有运行脚本的权限。要解决这个问题："

#, fuzzy
#~ msgid ""
#~ "This tutorial describes how to set the *application icon*. It will not "
#~ "discuss how to package and use runtime icons."
#~ msgstr "本教程介绍如何设置 * 应用程序图标*。它不会讨论如何打包和使用运行时图标。"

#, fuzzy
#~ msgid ""
#~ "/// note | Note In BeeWare, the term *icon* can refer to two different "
#~ "things:"
#~ msgstr "/// note |注意 在 BeeWare 中，*icon* 一词可指代两种不同的事物："

#, fuzzy
#~ msgid ""
#~ "This tutorial describes how to set the *application icon*. It will not "
#~ "discuss how to package and use runtime icons. ///"
#~ msgstr "本教程介绍如何设置 * 应用程序图标*。它不会讨论如何打包和使用运行时图标。///"

#~ msgid ""
#~ "Next, go to [the BeeWare Tutorial page on GitHub]{1}, fork the repository "
#~ "into your own account, and then clone a copy of that repository onto your "
#~ "computer by clicking on \"Clone or Download\". If you have the GitHub "
#~ "desktop application installed on your computer, you can select \"Open in "
#~ "Desktop\"; otherwise, copy the URL provided, and use it to clone using the "
#~ "command line:"
#~ msgstr ""
#~ "接下来，访问 [GitHub 上的 BeeWare 教程页面]{1}，将仓库 fork 到自己的账户中，然后点击 “Clone or Download”"
#~ " 以将仓库克隆到电脑上。如果电脑上安装了 GitHub Desktop 程序，可以选择 “Open in Desktop”；否则，请复制显示的 "
#~ "URL，然后使用命令行克隆："

#, fuzzy
#~ msgid "Tutorial 0 - Let's get set up"
#~ msgstr "教程 0 - 让我们开始吧！"

#~ msgid ""
#~ "It **generated an application template**. There's a lot of files and "
#~ "configurations required to build a native installer, above and beyond the "
#~ "code of your actual application. This extra scaffolding is almost the same "
#~ "for every application on the same platform, except for the name of the "
#~ "actual application being constructed - so Briefcase provides an application "
#~ "template for each platform it supports. This step rolls out the template, "
#~ "substituting the name of your application, bundle ID, and other properties "
#~ "of your configuration file as required to support the platform you're "
#~ "building on."
#~ msgstr ""
#~ "它生成了一个应用程序模板。除了实际应用程序的代码之外，构建本机安装程序还需要许多文件和配置。这些额外的脚手架对于同一平台上的每个应用程序几乎都是一样的，除了正在构建的实际应用程序的名称"
#~ "--因此，Briefcase 为其支持的每个平台提供了一个应用程序模板。这一步将推出模板，替换应用程序名称、捆绑 ID "
#~ "和配置文件中的其他属性，以支持正在构建的平台。"

#~ msgid ""
#~ "If you're not happy with the template provided by Briefcase, you can provide"
#~ " your own. However, you probably don't want to do this until you've got a "
#~ "bit more experience using Briefcase's default template."
#~ msgstr ""
#~ "如果您对 Briefcase 提供的模板不满意，可以提供自己的模板。不过，在使用 Briefcase 的默认模板获得更多经验之前，您可能不想这样做。"

#~ msgid ""
#~ "It **downloaded and installed a support package**. The packaging approach "
#~ "taken by Briefcase is best described as \"the simplest thing that could "
#~ "possibly work\" - it ships a complete, isolated Python interpreter as part "
#~ "of every application it builds (except for Linux native system package "
#~ "builds). This is slightly space inefficient - if you have 5 applications "
#~ "packaged with Briefcase, you'll have 5 copies of the Python interpreter. "
#~ "However, this approach guarantees that every application is completely "
#~ "independent, using a specific version of Python that is known to work with "
#~ "the application."
#~ msgstr ""
#~ "它下载并安装了一个支持包。Briefcase 所采用的打包方法被描述为“最简单可行的方法”--它将一个完整、独立的 Python "
#~ "解释器作为其构建的每个应用程序的一部分（除了了、 Linux 上的原生系统包构建）。这种打包方式在空间利用上略显不足--如果有 5 个应用程序使用 "
#~ "Briefcase 打包，那么就会有 5 份 Python "
#~ "解释器副本。但是，这种方法保证了每个应用程序都是完全独立的，使已知的能与应用程序一起工作的特定 Python版本。"

#~ msgid ""
#~ "Again, Briefcase provides a default support package for each platform; if "
#~ "you want, you can provide your own support package, and have that package "
#~ "included as part of the build process. You may want to do this if you have "
#~ "particular options in the Python interpreter that you need to have enabled, "
#~ "or if you want to strip modules out of the standard library that you don't "
#~ "need at runtime."
#~ msgstr ""
#~ "同样，Briefcase 为每个平台提供了默认的支持包；如果需要，您可以提供自己的支持包，并将其作为构建过程的一部分。如果您需要启用 Python "
#~ "解释器中的特定选项，或者如果您想从标准库中剥离运行时不需要的模块，您可能需要这样做。"

#~ msgid ""
#~ "Briefcase maintains a local cache of support packages, so once you've "
#~ "downloaded a specific support package, that cached copy will be used on "
#~ "future builds."
#~ msgstr "Briefcase 维护支持包的本地缓存，因此一旦您下载了特定的支持包，该缓存副本将用于未来的构建。"

#~ msgid ""
#~ "As noted above, when Briefcase packages an app as a native Linux system "
#~ "package (the default package format for Linux), a support package is not "
#~ "included with the app. Instead, the app will use the Python that is provided"
#~ " by the distribution of Linux being targeted."
#~ msgstr ""
#~ "如上所述，当 Briefcase 将一个应用程序打包成 Linux 上的原生系统包（Linux "
#~ "上的默认包格式），应用程序中将不会包含任何的支持包；应用程序将会使用将要被分发到的 Linux 发行版提供的 Python。"

#, fuzzy
#~ msgid "Tutorial 6 - Put it on the web"
#~ msgstr "教程 6 - 把它放上网！"

#~ msgid "**Fedora**"
#~ msgstr "**Fedora**"

#~ msgid "Install Python"
#~ msgstr "安装 Python"

#~ msgid "Install dependencies"
#~ msgstr "安装依赖项"
