msgid ""
msgstr ""
"Project-Id-Version: BeeWare 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-26 02:25-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: zh_TW <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.16.1\n"

#: docs/en/SUMMARY.md:1
#, fuzzy
msgid "[Tutorial 0 - Let's get set up!]{1}"
msgstr "[教學 0 - 讓我們開始設定吧！]{1}"

#: docs/en/SUMMARY.md:2
#, fuzzy
msgid "[Tutorial 1 - Your first app]{1}"
msgstr "[教學 1 - 您的第一個應用程式]{1}"

#: docs/en/SUMMARY.md:3
#, fuzzy
msgid "[Tutorial 2 - Making it interesting]{1}"
msgstr "[教學 2 - 讓它變得有趣]{1}"

#: docs/en/SUMMARY.md:4
#, fuzzy
msgid "[Tutorial 3 - Packaging for distribution]{1}"
msgstr "[教學 3 - 分發包裝]{1}"

#: docs/en/SUMMARY.md:5
#, fuzzy
msgid "[Tutorial 4 - Updating your application]{1}"
msgstr "[教程 4 - 更新您的應用程式]{1}"

#: docs/en/SUMMARY.md:6
#, fuzzy
msgid "Tutorial 5 - Taking it mobile"
msgstr "教程 5 - 移動使用"

#: docs/en/SUMMARY.md:6
#, fuzzy
msgid "[Tutorial 5 - Taking it mobile]{1}"
msgstr "[教程 5 - 移動使用]{1}"

#: docs/en/SUMMARY.md:6
#, fuzzy
msgid "[Tutorial 5 - Taking it mobile: Android]{1}"
msgstr "[教學 5 - 行動裝置：Android]{1}"

#: docs/en/SUMMARY.md:6
#, fuzzy
msgid "[Tutorial 5 - Taking it mobile: iOS]{1}"
msgstr "[教學 5 - 行動裝置：iOS]{1}"

#: docs/en/SUMMARY.md:10
#, fuzzy
msgid "[Tutorial 6 - Put it on the web!]{1}"
msgstr "[教程 6 - 將其放在網路上！]{1}"

#: docs/en/SUMMARY.md:11
#, fuzzy
msgid "[Tutorial 7 - Get this (third-)party started]{1}"
msgstr "[教學 7 - 啟動此（第三方）]{1}"

#: docs/en/SUMMARY.md:12
#, fuzzy
msgid "[Tutorial 8 - Making it Smooooth]{1}"
msgstr "[教學 8 - 使其順～暢]{1}"

#: docs/en/SUMMARY.md:13
#: docs/en/tutorial/topics/index.md:1
msgid "Going further"
msgstr ""

#: docs/en/SUMMARY.md:13
msgid "[Going further]{1}"
msgstr ""

#: docs/en/SUMMARY.md:13
#: docs/en/tutorial/topics/index.md:8
msgid "[Customizing icons]{1}"
msgstr ""

#: docs/en/SUMMARY.md:13
#: docs/en/tutorial/topics/index.md:13
msgid "[Using the camera]{1}"
msgstr ""

#: docs/en/SUMMARY.md:13
#: docs/en/tutorial/topics/index.md:18
msgid "[Testing times]{1}"
msgstr ""

#: docs/en/SUMMARY.md:18
msgid "How-to guides"
msgstr ""

#: docs/en/SUMMARY.md:18
msgid "[Contributing to this tutorial]{1}"
msgstr ""

#: docs/en/SUMMARY.md:18
msgid "[Style guide]{1}"
msgstr ""

#: docs/en/how-to/contribute.md:1
msgid "Contributing to this tutorial"
msgstr ""

#: docs/en/how-to/contribute.md:3
msgid ""
"This tutorial is written using [MkDocs and Markdown]{1}. This guide will "
"help you contribute fixes or new content to this tutorial."
msgstr ""

#: docs/en/how-to/contribute.md:7
msgid ""
"Translations of this tutorial are managed using [Weblate]{1}. If you'd like "
"to contribute to the translation effort, join the `#translations` channel on "
"[Discord]{2} and introduce yourself!"
msgstr ""

#: docs/en/how-to/contribute.md:12
msgid "Set up your development environment"
msgstr ""

#: docs/en/how-to/contribute.md:14
msgid ""
"To build the BeeWare tutorial you **must** have a Python 3.12 interpreter "
"installed and available on your path (i.e., `python3` must start a Python "
"3.12 interpreter)."
msgstr ""

#: docs/en/how-to/contribute.md:18
#: docs/en/how-to/contribute.md:51
#: docs/en/how-to/contribute.md:92
#: docs/en/how-to/contribute.md:135
#: docs/en/how-to/contribute.md:169
#: docs/en/how-to/contribute.md:201
#: docs/en/how-to/contribute.md:264
#: docs/en/how-to/contribute.md:318
#: docs/en/how-to/contribute.md:350
#: docs/en/how-to/contribute.md:385
#: docs/en/how-to/contribute.md:437
#: docs/en/how-to/contribute.md:469
#: docs/en/how-to/contribute.md:502
#: docs/en/how-to/contribute.md:566
#: docs/en/tutorial/topics/camera-access.md:159
#: docs/en/tutorial/topics/custom-icons.md:34
#: docs/en/tutorial/topics/custom-icons.md:215
#: docs/en/tutorial/topics/custom-icons.md:412
#: docs/en/tutorial/topics/testing.md:32
#: docs/en/tutorial/topics/testing.md:145
#: docs/en/tutorial/topics/testing.md:220
#: docs/en/tutorial/topics/testing.md:343
#: docs/en/tutorial/topics/testing.md:416
#: docs/en/tutorial/tutorial-0.md:10
#: docs/en/tutorial/tutorial-0.md:87
#: docs/en/tutorial/tutorial-0.md:156
#: docs/en/tutorial/tutorial-1.md:14
#: docs/en/tutorial/tutorial-1.md:62
#: docs/en/tutorial/tutorial-1.md:156
#: docs/en/tutorial/tutorial-1.md:204
#: docs/en/tutorial/tutorial-2.md:293
#: docs/en/tutorial/tutorial-2.md:334
#: docs/en/tutorial/tutorial-3.md:21
#: docs/en/tutorial/tutorial-3.md:192
#: docs/en/tutorial/tutorial-3.md:277
#: docs/en/tutorial/tutorial-3.md:379
#: docs/en/tutorial/tutorial-4.md:41
#: docs/en/tutorial/tutorial-4.md:87
#: docs/en/tutorial/tutorial-4.md:204
#: docs/en/tutorial/tutorial-5/android.md:16
#: docs/en/tutorial/tutorial-5/android.md:121
#: docs/en/tutorial/tutorial-5/android.md:204
#: docs/en/tutorial/tutorial-5/android.md:340
#: docs/en/tutorial/tutorial-6.md:32
#: docs/en/tutorial/tutorial-7.md:46
#: docs/en/tutorial/tutorial-7.md:130
#: docs/en/tutorial/tutorial-7.md:207
#: docs/en/tutorial/tutorial-7.md:555
#: docs/en/tutorial/tutorial-8.md:96
#: docs/en/tutorial/tutorial-8.md:332
msgid "/// tab | macOS"
msgstr ""

#: docs/en/how-to/contribute.md:25
#: docs/en/how-to/contribute.md:34
#: docs/en/how-to/contribute.md:43
#: docs/en/how-to/contribute.md:58
#: docs/en/how-to/contribute.md:67
#: docs/en/how-to/contribute.md:76
#: docs/en/how-to/contribute.md:102
#: docs/en/how-to/contribute.md:114
#: docs/en/how-to/contribute.md:126
#: docs/en/how-to/contribute.md:142
#: docs/en/how-to/contribute.md:151
#: docs/en/how-to/contribute.md:160
#: docs/en/how-to/contribute.md:176
#: docs/en/how-to/contribute.md:185
#: docs/en/how-to/contribute.md:194
#: docs/en/how-to/contribute.md:219
#: docs/en/how-to/contribute.md:239
#: docs/en/how-to/contribute.md:259
#: docs/en/how-to/contribute.md:278
#: docs/en/how-to/contribute.md:294
#: docs/en/how-to/contribute.md:308
#: docs/en/how-to/contribute.md:324
#: docs/en/how-to/contribute.md:332
#: docs/en/how-to/contribute.md:340
#: docs/en/how-to/contribute.md:356
#: docs/en/how-to/contribute.md:364
#: docs/en/how-to/contribute.md:372
#: docs/en/how-to/contribute.md:391
#: docs/en/how-to/contribute.md:399
#: docs/en/how-to/contribute.md:407
#: docs/en/how-to/contribute.md:443
#: docs/en/how-to/contribute.md:451
#: docs/en/how-to/contribute.md:459
#: docs/en/how-to/contribute.md:475
#: docs/en/how-to/contribute.md:483
#: docs/en/how-to/contribute.md:491
#: docs/en/how-to/contribute.md:508
#: docs/en/how-to/contribute.md:516
#: docs/en/how-to/contribute.md:524
#: docs/en/how-to/contribute.md:572
#: docs/en/how-to/contribute.md:580
#: docs/en/how-to/contribute.md:588
#: docs/en/index.md:24
#: docs/en/index.md:40
#: docs/en/index.md:56
#: docs/en/tutorial/topics/camera-access.md:24
#: docs/en/tutorial/topics/camera-access.md:167
#: docs/en/tutorial/topics/camera-access.md:177
#: docs/en/tutorial/topics/custom-icons.md:51
#: docs/en/tutorial/topics/custom-icons.md:75
#: docs/en/tutorial/topics/custom-icons.md:94
#: docs/en/tutorial/topics/custom-icons.md:132
#: docs/en/tutorial/topics/custom-icons.md:166
#: docs/en/tutorial/topics/custom-icons.md:201
#: docs/en/tutorial/topics/custom-icons.md:239
#: docs/en/tutorial/topics/custom-icons.md:271
#: docs/en/tutorial/topics/custom-icons.md:298
#: docs/en/tutorial/topics/custom-icons.md:344
#: docs/en/tutorial/topics/custom-icons.md:346
#: docs/en/tutorial/topics/custom-icons.md:382
#: docs/en/tutorial/topics/custom-icons.md:391
#: docs/en/tutorial/topics/custom-icons.md:427
#: docs/en/tutorial/topics/custom-icons.md:444
#: docs/en/tutorial/topics/custom-icons.md:461
#: docs/en/tutorial/topics/custom-icons.md:477
#: docs/en/tutorial/topics/custom-icons.md:493
#: docs/en/tutorial/topics/testing.md:55
#: docs/en/tutorial/topics/testing.md:83
#: docs/en/tutorial/topics/testing.md:111
#: docs/en/tutorial/topics/testing.md:162
#: docs/en/tutorial/topics/testing.md:181
#: docs/en/tutorial/topics/testing.md:200
#: docs/en/tutorial/topics/testing.md:252
#: docs/en/tutorial/topics/testing.md:288
#: docs/en/tutorial/topics/testing.md:322
#: docs/en/tutorial/topics/testing.md:361
#: docs/en/tutorial/topics/testing.md:381
#: docs/en/tutorial/topics/testing.md:401
#: docs/en/tutorial/topics/testing.md:458
#: docs/en/tutorial/topics/testing.md:492
#: docs/en/tutorial/topics/testing.md:531
#: docs/en/tutorial/tutorial-0.md:42
#: docs/en/tutorial/tutorial-0.md:62
#: docs/en/tutorial/tutorial-0.md:80
#: docs/en/tutorial/tutorial-0.md:97
#: docs/en/tutorial/tutorial-0.md:130
#: docs/en/tutorial/tutorial-0.md:143
#: docs/en/tutorial/tutorial-0.md:165
#: docs/en/tutorial/tutorial-0.md:176
#: docs/en/tutorial/tutorial-0.md:209
#: docs/en/tutorial/tutorial-0.md:211
#: docs/en/tutorial/tutorial-0.md:229
#: docs/en/tutorial/tutorial-1.md:20
#: docs/en/tutorial/tutorial-1.md:34
#: docs/en/tutorial/tutorial-1.md:36
#: docs/en/tutorial/tutorial-1.md:52
#: docs/en/tutorial/tutorial-1.md:54
#: docs/en/tutorial/tutorial-1.md:68
#: docs/en/tutorial/tutorial-1.md:76
#: docs/en/tutorial/tutorial-1.md:84
#: docs/en/tutorial/tutorial-1.md:169
#: docs/en/tutorial/tutorial-1.md:184
#: docs/en/tutorial/tutorial-1.md:199
#: docs/en/tutorial/tutorial-1.md:210
#: docs/en/tutorial/tutorial-1.md:212
#: docs/en/tutorial/tutorial-1.md:220
#: docs/en/tutorial/tutorial-1.md:222
#: docs/en/tutorial/tutorial-1.md:230
#: docs/en/tutorial/tutorial-1.md:248
#: docs/en/tutorial/tutorial-1.md:250
#: docs/en/tutorial/tutorial-2.md:113
#: docs/en/tutorial/tutorial-2.md:148
#: docs/en/tutorial/tutorial-2.md:211
#: docs/en/tutorial/tutorial-2.md:302
#: docs/en/tutorial/tutorial-2.md:313
#: docs/en/tutorial/tutorial-2.md:324
#: docs/en/tutorial/tutorial-2.md:340
#: docs/en/tutorial/tutorial-2.md:342
#: docs/en/tutorial/tutorial-2.md:350
#: docs/en/tutorial/tutorial-2.md:352
#: docs/en/tutorial/tutorial-2.md:360
#: docs/en/tutorial/tutorial-2.md:362
#: docs/en/tutorial/tutorial-3.md:48
#: docs/en/tutorial/tutorial-3.md:94
#: docs/en/tutorial/tutorial-3.md:96
#: docs/en/tutorial/tutorial-3.md:122
#: docs/en/tutorial/tutorial-3.md:211
#: docs/en/tutorial/tutorial-3.md:245
#: docs/en/tutorial/tutorial-3.md:269
#: docs/en/tutorial/tutorial-3.md:271
#: docs/en/tutorial/tutorial-3.md:300
#: docs/en/tutorial/tutorial-3.md:328
#: docs/en/tutorial/tutorial-3.md:352
#: docs/en/tutorial/tutorial-3.md:429
#: docs/en/tutorial/tutorial-3.md:543
#: docs/en/tutorial/tutorial-3.md:595
#: docs/en/tutorial/tutorial-4.md:47
#: docs/en/tutorial/tutorial-4.md:49
#: docs/en/tutorial/tutorial-4.md:57
#: docs/en/tutorial/tutorial-4.md:59
#: docs/en/tutorial/tutorial-4.md:67
#: docs/en/tutorial/tutorial-4.md:69
#: docs/en/tutorial/tutorial-4.md:101
#: docs/en/tutorial/tutorial-4.md:124
#: docs/en/tutorial/tutorial-4.md:140
#: docs/en/tutorial/tutorial-4.md:157
#: docs/en/tutorial/tutorial-4.md:225
#: docs/en/tutorial/tutorial-4.md:254
#: docs/en/tutorial/tutorial-4.md:272
#: docs/en/tutorial/tutorial-5/android.md:43
#: docs/en/tutorial/tutorial-5/android.md:72
#: docs/en/tutorial/tutorial-5/android.md:101
#: docs/en/tutorial/tutorial-5/android.md:139
#: docs/en/tutorial/tutorial-5/android.md:159
#: docs/en/tutorial/tutorial-5/android.md:179
#: docs/en/tutorial/tutorial-5/android.md:192
#: docs/en/tutorial/tutorial-5/android.md:216
#: docs/en/tutorial/tutorial-5/android.md:230
#: docs/en/tutorial/tutorial-5/android.md:244
#: docs/en/tutorial/tutorial-5/android.md:259
#: docs/en/tutorial/tutorial-5/android.md:270
#: docs/en/tutorial/tutorial-5/android.md:281
#: docs/en/tutorial/tutorial-5/android.md:293
#: docs/en/tutorial/tutorial-5/android.md:305
#: docs/en/tutorial/tutorial-5/android.md:354
#: docs/en/tutorial/tutorial-5/android.md:370
#: docs/en/tutorial/tutorial-5/android.md:386
#: docs/en/tutorial/tutorial-5/android.md:406
#: docs/en/tutorial/tutorial-5/iOS.md:124
#: docs/en/tutorial/tutorial-6.md:20
#: docs/en/tutorial/tutorial-6.md:70
#: docs/en/tutorial/tutorial-6.md:110
#: docs/en/tutorial/tutorial-6.md:150
#: docs/en/tutorial/tutorial-7.md:66
#: docs/en/tutorial/tutorial-7.md:88
#: docs/en/tutorial/tutorial-7.md:110
#: docs/en/tutorial/tutorial-7.md:117
#: docs/en/tutorial/tutorial-7.md:124
#: docs/en/tutorial/tutorial-7.md:144
#: docs/en/tutorial/tutorial-7.md:146
#: docs/en/tutorial/tutorial-7.md:162
#: docs/en/tutorial/tutorial-7.md:164
#: docs/en/tutorial/tutorial-7.md:180
#: docs/en/tutorial/tutorial-7.md:182
#: docs/en/tutorial/tutorial-7.md:189
#: docs/en/tutorial/tutorial-7.md:196
#: docs/en/tutorial/tutorial-7.md:245
#: docs/en/tutorial/tutorial-7.md:247
#: docs/en/tutorial/tutorial-7.md:302
#: docs/en/tutorial/tutorial-7.md:342
#: docs/en/tutorial/tutorial-7.md:344
#: docs/en/tutorial/tutorial-7.md:419
#: docs/en/tutorial/tutorial-7.md:467
#: docs/en/tutorial/tutorial-7.md:576
#: docs/en/tutorial/tutorial-7.md:605
#: docs/en/tutorial/tutorial-7.md:628
#: docs/en/tutorial/tutorial-7.md:647
#: docs/en/tutorial/tutorial-7.md:671
#: docs/en/tutorial/tutorial-7.md:682
#: docs/en/tutorial/tutorial-8.md:114
#: docs/en/tutorial/tutorial-8.md:116
#: docs/en/tutorial/tutorial-8.md:136
#: docs/en/tutorial/tutorial-8.md:138
#: docs/en/tutorial/tutorial-8.md:158
#: docs/en/tutorial/tutorial-8.md:160
#: docs/en/tutorial/tutorial-8.md:167
#: docs/en/tutorial/tutorial-8.md:174
#: docs/en/tutorial/tutorial-8.md:338
#: docs/en/tutorial/tutorial-8.md:346
#: docs/en/tutorial/tutorial-8.md:354
#: docs/en/tutorial/tutorial-8.md:362
#: docs/en/tutorial/tutorial-8.md:370
msgid "///"
msgstr ""

#: docs/en/how-to/contribute.md:27
#: docs/en/how-to/contribute.md:60
#: docs/en/how-to/contribute.md:104
#: docs/en/how-to/contribute.md:144
#: docs/en/how-to/contribute.md:178
#: docs/en/how-to/contribute.md:221
#: docs/en/how-to/contribute.md:280
#: docs/en/how-to/contribute.md:326
#: docs/en/how-to/contribute.md:358
#: docs/en/how-to/contribute.md:393
#: docs/en/how-to/contribute.md:445
#: docs/en/how-to/contribute.md:477
#: docs/en/how-to/contribute.md:510
#: docs/en/how-to/contribute.md:574
#: docs/en/tutorial/topics/custom-icons.md:53
#: docs/en/tutorial/topics/custom-icons.md:241
#: docs/en/tutorial/topics/custom-icons.md:429
#: docs/en/tutorial/topics/testing.md:57
#: docs/en/tutorial/topics/testing.md:164
#: docs/en/tutorial/topics/testing.md:254
#: docs/en/tutorial/topics/testing.md:363
#: docs/en/tutorial/topics/testing.md:460
#: docs/en/tutorial/tutorial-0.md:44
#: docs/en/tutorial/tutorial-0.md:99
#: docs/en/tutorial/tutorial-0.md:167
#: docs/en/tutorial/tutorial-1.md:22
#: docs/en/tutorial/tutorial-1.md:70
#: docs/en/tutorial/tutorial-1.md:171
#: docs/en/tutorial/tutorial-1.md:214
#: docs/en/tutorial/tutorial-2.md:304
#: docs/en/tutorial/tutorial-2.md:344
#: docs/en/tutorial/tutorial-3.md:50
#: docs/en/tutorial/tutorial-3.md:213
#: docs/en/tutorial/tutorial-3.md:302
#: docs/en/tutorial/tutorial-3.md:431
#: docs/en/tutorial/tutorial-4.md:51
#: docs/en/tutorial/tutorial-4.md:103
#: docs/en/tutorial/tutorial-4.md:227
#: docs/en/tutorial/tutorial-5/android.md:45
#: docs/en/tutorial/tutorial-5/android.md:141
#: docs/en/tutorial/tutorial-5/android.md:218
#: docs/en/tutorial/tutorial-5/android.md:356
#: docs/en/tutorial/tutorial-6.md:72
#: docs/en/tutorial/tutorial-7.md:68
#: docs/en/tutorial/tutorial-7.md:148
#: docs/en/tutorial/tutorial-7.md:249
#: docs/en/tutorial/tutorial-7.md:578
#: docs/en/tutorial/tutorial-8.md:118
#: docs/en/tutorial/tutorial-8.md:340
msgid "/// tab | Linux"
msgstr ""

#: docs/en/how-to/contribute.md:36
#: docs/en/how-to/contribute.md:69
#: docs/en/how-to/contribute.md:116
#: docs/en/how-to/contribute.md:153
#: docs/en/how-to/contribute.md:187
#: docs/en/how-to/contribute.md:241
#: docs/en/how-to/contribute.md:296
#: docs/en/how-to/contribute.md:334
#: docs/en/how-to/contribute.md:366
#: docs/en/how-to/contribute.md:401
#: docs/en/how-to/contribute.md:453
#: docs/en/how-to/contribute.md:485
#: docs/en/how-to/contribute.md:518
#: docs/en/how-to/contribute.md:582
#: docs/en/tutorial/topics/custom-icons.md:77
#: docs/en/tutorial/topics/custom-icons.md:273
#: docs/en/tutorial/topics/custom-icons.md:446
#: docs/en/tutorial/topics/testing.md:85
#: docs/en/tutorial/topics/testing.md:183
#: docs/en/tutorial/topics/testing.md:290
#: docs/en/tutorial/topics/testing.md:383
#: docs/en/tutorial/topics/testing.md:494
#: docs/en/tutorial/tutorial-0.md:64
#: docs/en/tutorial/tutorial-0.md:132
#: docs/en/tutorial/tutorial-0.md:178
#: docs/en/tutorial/tutorial-1.md:38
#: docs/en/tutorial/tutorial-1.md:78
#: docs/en/tutorial/tutorial-1.md:186
#: docs/en/tutorial/tutorial-1.md:224
#: docs/en/tutorial/tutorial-2.md:315
#: docs/en/tutorial/tutorial-2.md:354
#: docs/en/tutorial/tutorial-3.md:98
#: docs/en/tutorial/tutorial-3.md:247
#: docs/en/tutorial/tutorial-3.md:330
#: docs/en/tutorial/tutorial-3.md:545
#: docs/en/tutorial/tutorial-4.md:61
#: docs/en/tutorial/tutorial-4.md:126
#: docs/en/tutorial/tutorial-4.md:256
#: docs/en/tutorial/tutorial-5/android.md:74
#: docs/en/tutorial/tutorial-5/android.md:161
#: docs/en/tutorial/tutorial-5/android.md:232
#: docs/en/tutorial/tutorial-5/android.md:372
#: docs/en/tutorial/tutorial-6.md:112
#: docs/en/tutorial/tutorial-7.md:90
#: docs/en/tutorial/tutorial-7.md:166
#: docs/en/tutorial/tutorial-7.md:304
#: docs/en/tutorial/tutorial-7.md:607
#: docs/en/tutorial/tutorial-8.md:140
#: docs/en/tutorial/tutorial-8.md:348
msgid "/// tab | Windows"
msgstr ""

#: docs/en/how-to/contribute.md:45
#, fuzzy
msgid "Create a virtual environment"
msgstr "設定虛擬環境"

#: docs/en/how-to/contribute.md:47
msgid ""
"The recommended way of setting up your development environment for BeeWare "
"is to install a virtual environment, install the required dependencies and "
"start coding. To set up a virtual environment, run:"
msgstr ""

#: docs/en/how-to/contribute.md:78
msgid "Your prompt should now have a `(.venv)` prefix in front of it."
msgstr ""

#: docs/en/how-to/contribute.md:80
msgid "Clone the BeeWare Tutorial repository"
msgstr ""

#: docs/en/how-to/contribute.md:82
msgid "For updates to BeeWare documentation:"
msgstr ""

#: docs/en/how-to/contribute.md:84
msgid ""
"Next, go to [the BeeWare Tutorial page on GitHub]{1}, fork the repository "
"into your own account, and then clone a copy of that repository onto your "
"computer by clicking on \"Clone or Download\". If you have the GitHub "
"desktop application installed on your computer, you can select "
"\"Open in Desktop\"; otherwise, copy the URL provided, and use it to clone "
"using the command line:"
msgstr ""

#: docs/en/how-to/contribute.md:94
#: docs/en/how-to/contribute.md:106
#: docs/en/how-to/contribute.md:118
msgid "Fork the BeeWare Tutorial repository, and then:"
msgstr ""

#: docs/en/how-to/contribute.md:100
#: docs/en/how-to/contribute.md:112
#: docs/en/how-to/contribute.md:124
msgid "(substituting your GitHub username)"
msgstr ""

#: docs/en/how-to/contribute.md:128
msgid "Install BeeWare tutorial docs dependencies"
msgstr ""

#: docs/en/how-to/contribute.md:130
msgid ""
"Now that you have the source code, you can install BeeWare docs requirements "
"into your development environment. Since we're installing from source, we "
"can't rely on pip to resolve the dependencies to source packages, so we have "
"to manually install each package:"
msgstr ""

#: docs/en/how-to/contribute.md:162
msgid "Install pre-commit"
msgstr ""

#: docs/en/how-to/contribute.md:164
msgid ""
"BeeWare uses a tool called [Pre-Commit]{1} to identify simple issues and "
"standardize code formatting. It does this by installing a git hook that "
"automatically runs a series of code linters prior to finalizing any git "
"commit. To enable pre-commit, run:"
msgstr ""

#: docs/en/how-to/contribute.md:196
msgid ""
"When you commit any change, pre-commit will run automatically. If there are "
"any issues found with the commit, this will cause your commit to fail. Where "
"possible, pre-commit will make the changes needed to correct the problems it "
"has found:"
msgstr ""

#: docs/en/how-to/contribute.md:261
msgid ""
"You can then re-add any files that were modified as a result of the pre-"
"commit checks, and re-commit the change."
msgstr ""

#: docs/en/how-to/contribute.md:310
msgid "Now you are ready to start hacking on BeeWare docs!"
msgstr ""

#: docs/en/how-to/contribute.md:312
msgid "Building the BeeWare Tutorial"
msgstr ""

#: docs/en/how-to/contribute.md:314
msgid "Build the Tutorial locally"
msgstr ""

#: docs/en/how-to/contribute.md:316
msgid "Once your development environment is set up, run:"
msgstr ""

#: docs/en/how-to/contribute.md:342
msgid ""
"The output of the file should be in the `_build/html` folder. If there are "
"any markup problems, they'll raise an error."
msgstr ""

#: docs/en/how-to/contribute.md:345
msgid "Live Tutorial preview"
msgstr ""

#: docs/en/how-to/contribute.md:347
msgid ""
"To support rapid editing of documentation, BeeWare also has a "
"\"live preview\" mode:"
msgstr ""

#: docs/en/how-to/contribute.md:374
msgid ""
"This will build the documentation, start a web server to serve the build "
"documentation, and watch the file system for any changes to the "
"documentation source. If a change is detected, the documentation will be "
"rebuilt, and any browser viewing the modified page will be automatically "
"refreshed."
msgstr ""

#: docs/en/how-to/contribute.md:380
msgid "Tutorial linting"
msgstr ""

#: docs/en/how-to/contribute.md:382
msgid ""
"The build process will identify most Markdown problems, but BeeWare performs "
"some additional \"lint\" checks. To run the lint checks:"
msgstr ""

#: docs/en/how-to/contribute.md:409
msgid "This will validate the documentation does not contain:"
msgstr ""

#: docs/en/how-to/contribute.md:411
msgid "dead hyperlinks"
msgstr ""

#: docs/en/how-to/contribute.md:412
msgid "misspelled words"
msgstr ""

#: docs/en/how-to/contribute.md:414
msgid ""
"If a valid spelling of a word is identified as misspelled, then add the word "
"to the list in `docs/spelling_wordlist`. This will add the word to the "
"spellchecker's dictionary. When adding to this list, remember:"
msgstr ""

#: docs/en/how-to/contribute.md:418
msgid ""
"We prefer US spelling, with some liberties for programming-specific "
"colloquialisms (e.g., \"apps\") and verbing of nouns (e.g., \"scrollable\")"
msgstr ""

#: docs/en/how-to/contribute.md:420
msgid ""
"Any reference to a product name should use the product's preferred "
"capitalization. (e.g., \"macOS\", \"GTK\", \"pytest\", \"Pygame\", "
"\"PyScript\")."
msgstr ""

#: docs/en/how-to/contribute.md:423
msgid ""
"If a term is being used \"as code\", then it should be quoted as inline code "
"rather than being added to the dictionary."
msgstr ""

#: docs/en/how-to/contribute.md:426
msgid "Translations"
msgstr ""

#: docs/en/how-to/contribute.md:428
msgid ""
"The BeeWare tutorial is available in multiple languages, which you can build "
"individually or all at the same time."
msgstr ""

#: docs/en/how-to/contribute.md:431
msgid "Updating translations"
msgstr ""

#: docs/en/how-to/contribute.md:433
msgid ""
"If you have made changes to the English content, the first step to building "
"the translations is to update the translation files. To update the "
"translations:"
msgstr ""

#: docs/en/how-to/contribute.md:461
msgid "This will update the"
msgstr ""

#: docs/en/how-to/contribute.md:463
msgid "Building translations"
msgstr ""

#: docs/en/how-to/contribute.md:465
msgid ""
"To build a single translation, you run the `docs` command with the language "
"code for the translation you wish to build. For example, to build French:"
msgstr ""

#: docs/en/how-to/contribute.md:493
msgid ""
"The French translation should be built in the `_build/html` folder. If there "
"are any markup problems, they'll raise an error."
msgstr ""

#: docs/en/how-to/contribute.md:496
msgid ""
"An error is also raised if you enter a language code for an unavailable "
"language. If this happens, verify that you are using the proper language "
"code."
msgstr ""

#: docs/en/how-to/contribute.md:500
msgid "To build all the translations at the same time:"
msgstr ""

#: docs/en/how-to/contribute.md:526
msgid ""
"This will build all available translations in the `_build/html` directory, "
"inside a language-specific subdirectory. For example, the French translation "
"would be available in `_build/html/fr`."
msgstr ""

#: docs/en/how-to/contribute.md:530
msgid "What to work on?"
msgstr ""

#: docs/en/how-to/contribute.md:532
msgid ""
"If you're looking for specific areas to improve, there are "
"[tickets tagged \"documentation\"]{1} in BeeWare's issue tracker."
msgstr ""

#: docs/en/how-to/contribute.md:536
msgid ""
"However, you don't need to be constrained by these tickets. If you can "
"identify an error in the tutorial, or an improvement that can be made, start "
"writing! Anything that improves the experience of the end user is a welcome "
"change."
msgstr ""

#: docs/en/how-to/contribute.md:541
msgid "Submitting a pull request"
msgstr ""

#: docs/en/how-to/contribute.md:543
msgid ""
"Before you submit a pull request, there's a few bits of housekeeping to do."
msgstr ""

#: docs/en/how-to/contribute.md:546
msgid "Submit from a feature branch, not your `main` branch"
msgstr ""

#: docs/en/how-to/contribute.md:548
msgid ""
"Before you start working on your change, make sure you've created a branch. "
"By default, when you clone your repository fork, you'll be checked out on "
"your `main` branch. This is a direct copy of BeeWare's `main` branch. To "
"contribute to BeeWare itself, not the docs, please review the repo README."
msgstr ""

#: docs/en/how-to/contribute.md:554
msgid ""
"While you *can* submit a pull request from your `main` branch, it's "
"preferable if you *don't* do this. If you submit a pull request that is "
"*almost* right, the core team member who reviews your pull request may be "
"able to make the necessary changes, rather than giving feedback asking for a "
"minor change. However, if you submit your pull request from your `main` "
"branch, reviewers are prevented from making modifications."
msgstr ""

#: docs/en/how-to/contribute.md:561
msgid ""
"Instead, you should make your changes on a *feature branch*. A feature "
"branch has a simple name to identify the change that you've made."
msgstr ""

#: docs/en/how-to/contribute.md:564
msgid "To create a feature branch, run:"
msgstr ""

#: docs/en/how-to/contribute.md:590
msgid ""
"Commit your changes to this branch, then push to GitHub and create a pull "
"request."
msgstr ""

#: docs/en/how-to/style-guide.md:1
msgid "-8<- \"style_guide.md\""
msgstr ""

#: docs/en/index.md:1
msgid "Welcome to the BeeWare Tutorial!"
msgstr "歡迎來到 BeeWare 教學！"

#: docs/en/index.md:3
msgid "**Write Python. Run Anywhere.**"
msgstr "**在任何地方執行你寫的Python。**"

#: docs/en/index.md:5
msgid ""
"Welcome to BeeWare! In this tutorial, we're going to build a graphical user "
"interface using Python, and deploy it as a desktop application, as a mobile "
"application, and as a single page web app. We'll also look at how you can "
"use BeeWare tools to perform some of the common tasks that you'll need to do "
"as an app developer, such as testing your app."
msgstr ""
"歡迎來到 BeeWare！在本教學中，我們將使用 Python 建立一個 "
"GUI，並將其部署為桌面應用程式、行動應用程式和網頁。我們還將了解如何使用 "
"BeeWare "
"工具來執行作為應用程式開發人員所需執行的一些常見任務，例如測試應用程式。"

#: docs/en/index.md:11
msgid "{% if config.extra.translation_type == \"original\" %}"
msgstr ""

#: docs/en/index.md:13
msgid "/// admonition | Translations are available"
msgstr ""

#: docs/en/index.md:15
msgid ""
"If you're not comfortable with English, translations of this tutorial are "
"available in [Deutsch]{1}, [Español]{2}, [Français]{3}, [Italiano]{4}, "
"[Português]{5}, [中文(简体)]{6}, and [中文(繁體)]{7}."
msgstr ""
"如果您不熟悉中文，可以使用本教學的翻譯版本 [English]{1} [Deutsch]{2}, "
"[Español]{3}, [Français]{4}, [Italiano]{5}, [Português]{6}, [简体中文]{7} 。"

#: docs/en/index.md:26
#: docs/en/index.md:42
#: docs/en/index.md:58
msgid "{% endif %}"
msgstr ""

#: docs/en/index.md:28
msgid "{% if config.extra.translation_type == \"machine\" %}"
msgstr ""

#: docs/en/index.md:30
msgid "/// admonition | This is a machine translation!"
msgstr ""

#: docs/en/index.md:32
msgid ""
"This version of the tutorial has been generated by machine translation. We "
"know this isn't ideal, but we felt that a bad translation was better than no "
"translation at all."
msgstr "此版本的教學是透過機器翻譯產生的。我們知道這並不理想，但我們認為糟糕的翻譯總"
"比沒有翻譯好。"

#: docs/en/index.md:36
#: docs/en/index.md:52
msgid ""
"If you'd like the help improve the translation, get in touch! We have a "
"`#translations` channel in [Discord]{1}. Introduce yourself there and we "
"will add you to the translation team."
msgstr ""
"如果您想要協助改進翻譯，請聯絡我們！我們在 [Discord]{1} 中有一個 "
"`#translations` 頻道。在那裡進行自我介紹，我們會將您加入翻譯團隊。"

#: docs/en/index.md:44
msgid "{% if config.extra.translation_type == \"human\" %}"
msgstr ""

#: docs/en/index.md:46
msgid "/// admonition | This is a translation!"
msgstr ""

#: docs/en/index.md:48
msgid ""
"This document is a translation of the English version. The translation has "
"been reviewed by humans, but newer sections may be generated by machine "
"translation, or not translated at all."
msgstr "本文檔是英文版本的翻譯。翻譯已經過人工審核，但較新的部分可能是由機器翻譯產生"
"的，或者根本不翻譯。"

#: docs/en/index.md:61
msgid "What is BeeWare?"
msgstr "什麼是 BeeWare？"

#: docs/en/index.md:63
msgid ""
"BeeWare is not a single product, or tool, or library - it's a collection of "
"tools and libraries, each of which works together to help you write cross "
"platform Python applications with a native GUI. It includes:"
msgstr ""
"BeeWare 不是一個單一的產品、工具或函式庫 - "
"它是工具和函式庫的集合，每個工具和函式庫協同工作，幫助您編寫跨平台的原生 "
"Python GUI 應用程式。這包括："

#: docs/en/index.md:67
msgid "[Toga]{1}, a cross-platform widget toolkit;"
msgstr ""

#: docs/en/index.md:68
#, fuzzy
msgid ""
"[Briefcase]{1}, a tool for packaging Python projects as distributable "
"artefacts that can be shipped to end users;"
msgstr "[Briefcase]{1} ，一種將 Python "
"專案打包為可分發形式(apk、exe等)並可傳送給最終使用者的工具;"

#: docs/en/index.md:71
#, fuzzy
msgid ""
"Libraries (such as [Rubicon ObjC]{1}) for accessing platform-native "
"libraries;"
msgstr "用於存取各個平臺的原生庫的庫（例如 [Rubicon ObjC]{1} ）;"

#: docs/en/index.md:73
msgid ""
"Pre-compiled builds of Python that can be used on platforms where official "
"Python installers aren't available."
msgstr "預編譯版本的 Python 可在無官方 Python 安裝程式的平台上使用。"

#: docs/en/index.md:76
msgid ""
"In this tutorial, we'll be using all these tools, but as a user, you'll only "
"need to interact with the first two (Toga and Briefcase). However, each of "
"the tools can also be used individually - for example, you can use Briefcase "
"to deploy an app without using Toga as a GUI toolkit."
msgstr ""
"在本教程中，我們將使用所有這些工具，但作為用戶，您只需要與前兩個工具（Toga "
"和 Briefcase）進行互動。每個工具也可以單獨使用 - 舉例來說，您可以使用 "
"Briefcase 來部署應用程序，而不使用 Toga 作為 GUI 工具包。"

#: docs/en/index.md:81
msgid ""
"The BeeWare suite is available on macOS, Windows, Linux (using GTK); on "
"mobile platforms such as Android and iOS; and for the Web."
msgstr "BeeWare 套件可在 macOS、Windows、Linux（使用 "
"GTK）上使用，也在Android和iOS等行動平台上，甚至是網頁。"

#: docs/en/index.md:84
#, fuzzy
msgid "Let's go!"
msgstr "讓我們開始吧！"

#: docs/en/index.md:86
msgid ""
"Ready to try BeeWare for yourself? "
"[Let's build a cross-platform application in Python!]{1}"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:1
msgid "Using the camera"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:3
msgid ""
"Almost every modern computing device has a camera of some sort. In this "
"tutorial, we'll write new application that is able to request access to this "
"camera, take a photograph, and then display that photograph in the new "
"application that uses your device's camera."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:8
msgid "/// admonition | This tutorial won't work on all platforms!"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:10
msgid ""
"Unfortunately, at present, this tutorial will only work on macOS and Android."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:13
msgid ""
"Although iPhones all have cameras, the iOS *Simulator* doesn't have a "
"working camera. Windows and Linux devices also have cameras, but Toga "
"doesn't currently have the ability to access the camera on these platforms."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:18
msgid ""
"The code presented here will *run* on Windows or Linux; but it will raise an "
"error when you try to take a photograph."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:21
msgid ""
"The code will work if it is run on an actual iOS device, but will fail to "
"take a photograph if deployed to the iOS simulator."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:26
msgid "Start a new project"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:28
msgid ""
"For this tutorial, we're not going to build onto the application from the "
"core tutorial - we're going to start a fresh project. You can use the same "
"virtual environment you used in the first project; but we need to re-run the "
"`briefcase new` wizard."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:33
msgid ""
"Change back to the directory that contains the `helloworld` project folder, "
"and start a new project named \"Hello Camera\":"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:50
msgid "Add code to take a photo"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:52
msgid ""
"The wizard has generated a new empty Toga project. We can now add the code "
"to take and display a photograph. Edit the `app.py` for the new application "
"so that it has the following content:"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:107
msgid ""
"This code has two changes over the default app that is generated by "
"Briefcase. These additions are highlighted above:"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:110
msgid ""
"The first highlighted code block (in the `startup()` method) adds the two "
"widgets needed to control the camera: an `ImageView` to display a photo; and "
"a `Button` to trigger the camera."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:113
msgid ""
"The second highlighted code block (the `take_photo()` method) defines the "
"event handler when the button is pressed. This handler first confirms if the "
"application has permission to take a photo; if permission doesn't exist, it "
"is requested. Then, a photo is taken. The request for permission and the "
"request to take a photo are both asynchronous requests, so they require the "
"use of `await`; while the app is waiting for the user to confirm permissions "
"or take the photo, the app's event loop can continue in the background."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:122
msgid ""
"If the camera successfully takes a photo, it will return an `Image` object "
"that can be assigned as the content of the `ImageView`. If the photo request "
"was canceled by the user, the `self.camera.take_photo()` call will return "
"`None`, and the result can be ignored. If the user doesn't grant permission "
"to use the camera, or the camera isn't implemented on the current platform, "
"an error will be raised, and a dialog will be shown to the user."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:130
msgid "Adding device permissions"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:132
msgid ""
"Part of this code we've just added asks for permission to use the camera. "
"This is a common feature of modern app platforms - you can't access hardware "
"features without explicitly asking the user's permission first."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:137
msgid ""
"However, this request comes in two parts. The first is in the code we've "
"just seen; but before the app can ask for permissions, it needs to declare "
"the permissions it is going to ask for."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:141
msgid ""
"The permissions required by each platform are slightly different, but "
"Briefcase has a cross-platform representation for many common hardware "
"permissions. In the `[tool.briefcase.app.hellocamera]` configuration section "
"of your app's `pyproject.toml` file, add the following (just above the "
"`sources` declaration):"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:151
msgid ""
"This declares that your app needs to access the camera, and provides a short "
"description why the camera is required. This description is needed on some "
"platforms (most notably macOS and iOS) and will be displayed to the user as "
"a additional information when the permission dialog is presented."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:157
msgid "We can now generate and run the app:"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:169
#: docs/en/tutorial/topics/custom-icons.md:96
#: docs/en/tutorial/topics/custom-icons.md:300
#: docs/en/tutorial/topics/custom-icons.md:463
#: docs/en/tutorial/tutorial-7.md:112
#: docs/en/tutorial/tutorial-7.md:184
#: docs/en/tutorial/tutorial-7.md:346
#: docs/en/tutorial/tutorial-7.md:630
#: docs/en/tutorial/tutorial-8.md:162
#: docs/en/tutorial/tutorial-8.md:356
msgid "/// tab | Android"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:179
msgid ""
"When the app runs, you'll be presented with a button. Press the button, and "
"the platform's default camera dialog will be displayed. Take a photo; the "
"camera dialog will disappear, and the photo will be displayed on in the app, "
"just above the button. You could then take another photo; this will replace "
"the first photo."
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:185
msgid "Adding more permissions"
msgstr ""

#: docs/en/tutorial/topics/camera-access.md:187
msgid ""
"Permissions are declared in the files that are generated during the original "
"call to `briefcase create`. Unfortunately, Briefcase can't update these "
"files once they've been initially generated; so if you want to add a new "
"permission to your app, or modify existing permissions, you'll need to re-"
"create the app. You can do this by re-running `briefcase create`; this will "
"warn you that the existing app will be overwritten, and then regenerate the "
"application with the new permissions."
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:1
msgid "Customizing icons"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:3
#, fuzzy
msgid ""
"The app we developed in the main tutorial uses a default \"gray bee\" icon "
"when it is packaged. Let's personalize this application by configuring it to "
"use our own icon."
msgstr "到目前為止，我們的應用程式使用了預設的 `灰色蜜蜂` "
"圖示。我們如何更新應用程式以使用我們自己的圖標？"

#: docs/en/tutorial/topics/custom-icons.md:7
msgid "Adding an icon"
msgstr "新增圖示"

#: docs/en/tutorial/topics/custom-icons.md:9
msgid ""
"Every platform uses a different format for application icons - and some "
"platforms need *multiple* icons in different sizes and shapes. To account "
"for this, Briefcase provides a shorthand way to configure an icon once, and "
"then have that definition expand in to all the different icons needed for "
"each individual platform."
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:15
msgid ""
"Edit your `pyproject.toml`, adding a new `icon` configuration item in the `"
"[tool.briefcase.app.helloworld]` configuration section, just above the "
"`sources` definition:"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:23
msgid ""
"This icon definition doesn't specify any file extension. The value will be "
"used as a prefix; each platform will add additional items to this prefix to "
"build the files needed for each platform. Some platforms require *multiple* "
"icon files; this prefix will be combined with file size and variant "
"modifiers to generate the list of icon files that are used."
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:30
msgid ""
"We can now run `briefcase update` again - but this time, we pass in the "
"`--update-resources` flag, telling Briefcase that we want to install new "
"application resources (i.e., the icons):"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:134
#: docs/en/tutorial/topics/custom-icons.md:348
#: docs/en/tutorial/topics/custom-icons.md:479
#: docs/en/tutorial/tutorial-7.md:119
#: docs/en/tutorial/tutorial-7.md:191
#: docs/en/tutorial/tutorial-7.md:421
#: docs/en/tutorial/tutorial-7.md:649
#: docs/en/tutorial/tutorial-8.md:169
#: docs/en/tutorial/tutorial-8.md:364
msgid "/// tab | iOS"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:168
msgid ""
"This reports the specific icon file (or files) that Briefcase is expecting. "
"However, as we haven't provided the actual icon files, the install fails, "
"and Briefcase falls back to a default value (the same \"gray bee\" icon)."
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:173
msgid ""
"Let's provide some actual icons. Download [this icons.zip bundle]{1}, and "
"unzip it into the root of your project directory. After unzipping, your "
"project directory should look something like:"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:194
msgid ""
"There's a *lot* of icons in this folder, but most of them should look the "
"same: a green snake on a light blue background:"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:197
msgid "![Icon of green snake with a light blue background]{1}"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:199
#: docs/en/tutorial/tutorial-1.md:208
#: docs/en/tutorial/tutorial-1.md:218
#: docs/en/tutorial/tutorial-1.md:228
#: docs/en/tutorial/tutorial-2.md:338
#: docs/en/tutorial/tutorial-2.md:348
#: docs/en/tutorial/tutorial-2.md:358
#: docs/en/tutorial/tutorial-4.md:45
#: docs/en/tutorial/tutorial-4.md:55
#: docs/en/tutorial/tutorial-4.md:65
#: docs/en/tutorial/tutorial-5/android.md:255
#: docs/en/tutorial/tutorial-5/android.md:266
#: docs/en/tutorial/tutorial-5/android.md:277
#: docs/en/tutorial/tutorial-5/android.md:301
#: docs/en/tutorial/tutorial-5/iOS.md:122
#: docs/en/tutorial/tutorial-7.md:142
#: docs/en/tutorial/tutorial-7.md:160
#: docs/en/tutorial/tutorial-7.md:178
#: docs/en/tutorial/tutorial-7.md:243
#: docs/en/tutorial/tutorial-7.md:340
#: docs/en/tutorial/tutorial-8.md:112
#: docs/en/tutorial/tutorial-8.md:134
#: docs/en/tutorial/tutorial-8.md:156
msgid "/// caption"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:203
msgid ""
"The only exception will be the icons with `-adaptive-` in their name; these "
"will have a transparent background. This represents all the different icon "
"sizes and shapes you need to support an app on every platform that Briefcase "
"supports."
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:208
msgid ""
"Now that we have icons, we can update the application again. However, `"
"briefcase update` will only copy the updated resources into the build "
"directory; we also want to rebuild the app to make sure the new icon is "
"included, then start the app. We can shortcut this process by passing "
"`--update-resources` to our call to `run` - this will update the app, update "
"the app's resources, and then start the app:"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:338
#: docs/en/tutorial/topics/custom-icons.md:384
#: docs/en/tutorial/tutorial-2.md:142
#: docs/en/tutorial/tutorial-2.md:201
#: docs/en/tutorial/tutorial-4.md:150
#: docs/en/tutorial/tutorial-7.md:676
msgid "/// note | Note"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:340
msgid ""
"If you're using a recent version of Android, you may notice that the app "
"icon has been changed to a green snake, but the background of the icon is "
"*white*, rather than light blue. We'll fix this in the next step."
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:386
msgid ""
"If you get a stack trace referencing `faker` or `httpx` when you run the "
"app, it's possible you missed running your app during step 7 or 8 of the "
"tutorial. Re-run the app, adding the `-r` argument to update the app "
"requirements."
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:393
msgid ""
"When you run the app on iOS or Android, in addition to the icon change, you "
"should also notice that the splash screen incorporates the new icon. "
"However, the light blue background of the icon looks a little out of place "
"against the white background of the splash screen. We can fix this by "
"customizing the background color of the splash screen. Add the following "
"definition to your `pyproject.toml`, just after the `icon` definition:"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:405
msgid ""
"Unfortunately, Briefcase isn't able to apply this change to an already "
"generated project, as it requires making modifications to one of the files "
"that was generated during the original call to `briefcase create`. To apply "
"this change, we have to re-create the app by re-running `briefcase create`. "
"When we do this, we'll be prompted to confirm that we want to overwrite the "
"existing project:"
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:496
msgid ""
"You can then re-build and re-run the app using `briefcase run`. You won't "
"notice any changes to the desktop app; but the Android or iOS apps should "
"now have a light blue splash screen background."
msgstr ""

#: docs/en/tutorial/topics/custom-icons.md:500
msgid ""
"You'll need to re-create the app like this whenever you make a change to "
"your `pyproject.toml` that doesn't relate to source code or dependencies. "
"Any change to descriptions, version numbers, colors, or permissions will "
"require a re-create step. Because of this, while you are developing your "
"project, you shouldn't make any manual changes to the contents of the `build`"
" folder, and you shouldn't add the `build` folder to your version control "
"system. The `build` folder should be considered entirely ephemeral - an "
"output of the build system that can be recreated as needed to reflect the "
"current configuration of your project."
msgstr ""

#: docs/en/tutorial/topics/index.md:3
msgid ""
"Want to go deeper on specific topics? Here are some additional tutorials "
"that explore common aspects of application development. Each tutorial is "
"standalone, and can be completed in any order; but they all assume you've "
"completed the core tutorial."
msgstr ""

#: docs/en/tutorial/topics/index.md:10
msgid ""
"Customize your application's appearance by replacing the default \"gray bee\""
" icon."
msgstr ""

#: docs/en/tutorial/topics/index.md:15
msgid ""
"Use the camera on your mobile or desktop device to take and view a picture "
"from within your application."
msgstr ""

#: docs/en/tutorial/topics/index.md:20
msgid ""
"How do you ensure that your application works, and stays working? By adding "
"a test suite to your project!"
msgstr ""

#: docs/en/tutorial/topics/testing.md:1
msgid "Testing times"
msgstr ""

#: docs/en/tutorial/topics/testing.md:3
msgid ""
"Most software development doesn't involve writing new code - it's modifying "
"existing code. Ensuring that existing code continues to work in the way we "
"expect is a key part of the software development process. One way to do "
"ensure the behavior of our app is with a *test suite*."
msgstr ""
"大多數軟體開發並不涉及編寫新程式碼，而是修改現有程式碼。確保現有程式碼繼續按"
"照我們期望的方式運作是軟體開發過程的關鍵部分。"
"確保我們的應用程式行為的一種方法是使用 *測試套件* 。"

#: docs/en/tutorial/topics/testing.md:8
msgid "Running the test suite"
msgstr "運行測試套件"

#: docs/en/tutorial/topics/testing.md:10
#, fuzzy
msgid ""
"It turns out the project from the core tutorial already has a test suite! "
"When we originally generated our project, two top-level directories were "
"generated: `src` and `tests`. The `src` folder contains the code for our app;"
" the `tests` folder contains our test suite. Inside the `tests` folder is a "
"file named `test_app.py` with the following content:"
msgstr ""
"事實上，我們的專案已經有測試套件了！當我們最初產生專案時，產生了兩個資料夾： "
"`src` 和 `tests` 。 `src` 資料夾包含我們應用程式的程式碼； `tests` "
"資料夾包含我們的測試套件。在 `tests` 資料夾內有一個名為 `test_app.py` "
"的文件，其中包含以下內容："

#: docs/en/tutorial/topics/testing.md:23
msgid ""
"This is a [Pytest]{1} *test case* - a block of code that can be executed to "
"verify some behavior of your app. In this case, the test is a placeholder, "
"and doesn't test anything about our app - but it is a test that we can "
"perform."
msgstr ""
"這是一個 [Pytest]{1} 的 *測試範例* - "
"可以執行以驗證應用程式的某些行為的程式碼區塊。在本例中，測試僅是一個範例，"
"不會測試有關我們應用程式的任何內容 - 但它是我們可以執行的測試。"

#: docs/en/tutorial/topics/testing.md:28
msgid ""
"We can run this test suite using the `--test` option to `briefcase dev`. As "
"this is the first time we are running tests, we also need to pass in the `-r`"
" option to ensure that the test requirements are also installed:"
msgstr ""
"我們可以使用 `briefcase dev` 的 `--test` "
"選項來執行這個測試套件。由於這是我們第一次執行測試，我們還需要傳入 `-r` "
"選項以確保測試要求也已安裝："

#: docs/en/tutorial/topics/testing.md:114
msgid ""
"Success! We've just executed a single test that verifies Python math works "
"in the way we'd expect (What a relief!)."
msgstr "成功了！我們剛剛執行了一個測試，證實了 Python "
"的數學按照我們期望的方式工作（真是鬆了一口氣！）。"

#: docs/en/tutorial/topics/testing.md:117
msgid ""
"Let's replace this placeholder test with a test to verify that our "
"`greeting()` method behaves the way we'd expect. Replace the contents of "
"`test_app.py` with the following:"
msgstr ""
"讓我們用一個測試來取代這個範例，以驗證我們的 `greeting()` "
"方法的行為是否符合我們的預期。將 `test_app.py` 的內容替換為以下內容："

#: docs/en/tutorial/topics/testing.md:137
msgid ""
"This defines two new tests, verifying the two behaviors we expect to see: "
"the output when a name is provided, and the output when the name is empty."
msgstr "這定義了兩個新的測試，驗證我們期望看到的兩個行為：提供名稱時的輸出，以及名稱"
"為空時的輸出。"

#: docs/en/tutorial/topics/testing.md:141
msgid ""
"We can now re-run the test suite. This time, we don't need to provided the "
"`-r` option, as the test requirements have already been installed; we only "
"need to use the `--test` option:"
msgstr "我們現在可以重新運行測試套件。這次，我們不需要提供 `-r` "
"選項，因為測試要求已經安裝了；我們只需要使用 `--test` 選項："

#: docs/en/tutorial/topics/testing.md:202
msgid "Excellent! Our `greeting()` utility method is working as expected."
msgstr "非常好！我們的 `greeting()` 實用方法按預期工作。"

#: docs/en/tutorial/topics/testing.md:204
msgid "Test driven development"
msgstr "用測試來驅動開發"

#: docs/en/tutorial/topics/testing.md:206
msgid ""
"Now that we have a test suite, we can use it to drive the development of new "
"features. Let's modify our app to have a special greeting for one particular "
"user. We can start by adding a test case for the new behavior that we'd like "
"to see to the bottom of `test_app.py`:"
msgstr ""
"現在我們有了測試套件，我們可以用它來驅動新功能的開發。讓我們修改我們的應用程"
"序，為某個特定用戶提供特殊的問候語。我們可以先為我們希望在 `test_app.py` "
"底部看到的新行為新增一個測試案例:"

#: docs/en/tutorial/topics/testing.md:218
msgid "Then, run the test suite with this new test:"
msgstr "然後，使用這個新測試來執行測試套件："

#: docs/en/tutorial/topics/testing.md:324
msgid ""
"This time, we see a test failure - and the output explains the source of the "
"failure: the test is expecting the output \"BeeWare the IDEs of Python!\", "
"but our implementation of `greeting()` is returning \"Hello, Brutus\". Let's "
"modify the implementation of `greeting()` in `src/helloworld/app.py` to have "
"the new behavior:"
msgstr ""
"這次，我們看到測試失敗 - 輸出解釋了失敗的根源：測試期望輸出 `BeeWare the "
"IDEs of Python!` ，但我們的 `greeting()` 實現返回 `Hello, Brutus` 。"
"讓我們修改 src/helloworld/app.py 中的 greeting() 實作以獲得新的行為："

#: docs/en/tutorial/topics/testing.md:341
msgid "If we run the tests again, we'll now see our tests pass:"
msgstr "如果我們再次運行測試，我們現在將看到測試通過："

#: docs/en/tutorial/topics/testing.md:403
msgid "Runtime tests"
msgstr "運行時測試"

#: docs/en/tutorial/topics/testing.md:405
msgid ""
"So far, we've been running the tests in development mode. This is especially "
"useful when you're developing new features, as you can rapidly iterate on "
"adding tests, and adding code to make those tests pass. However, at some "
"point, you'll want to verify that your code also runs correctly when inside "
"the bundle app environment."
msgstr ""
"到目前為止，我們一直在開發模式下執行測試。當您開發新功能時，這特別有用，因為"
"您可以快速迭代添加測試，並添加程式碼以使這些測試通過。但是，在某些時候，您需"
"要驗證您的程式碼在部署的環境中是否也可以正確運行。"

#: docs/en/tutorial/topics/testing.md:411
msgid ""
"The `--test` and `-r` options can also be passed to the `run` command. If "
"you use `briefcase run --test -r`, the same test suite will run, but it will "
"run inside the packaged application bundle rather than your development "
"environment:"
msgstr ""
"`--test` 和 `-r` 選項也可以傳遞給 `run` 指令。如果您使用 `briefcase run --"
"test -r` "
"，將運行相同的測試套件，但它將在部署的環境中運行，而不是在您的開發環境中運行"
"："

#: docs/en/tutorial/topics/testing.md:534
msgid ""
"As with `briefcase dev --test`, the `-r` option is only needed the first "
"time you run the test suite to ensure that the test dependencies are "
"present. On subsequent runs, you can omit this option."
msgstr ""
"與 `briefcase dev --test` 一樣，僅在第一次執行測試套件時才需要 `-r` "
"選項，以確保測試依賴項存在。在後續運行中，您可以忽略此選項。"

#: docs/en/tutorial/topics/testing.md:538
msgid ""
"You can also use the `--test` option on mobile backends: - so `briefcase run "
"iOS --test` and `briefcase run android --test` will both work, running the "
"test suite on the mobile device you select."
msgstr ""
"您還可以在移動環境下使用 `--test` 選項： - 因此 `briefcase run iOS --test` "
"和 `briefcase run android --test` "
"都可以工作，在您選擇的移動設備上運行測試套件。"

#: docs/en/tutorial/tutorial-0.md:1
#, fuzzy
msgid "Tutorial 0 - Let's get set up!"
msgstr "教學 0 - 讓我們開始設定吧！"

#: docs/en/tutorial/tutorial-0.md:3
msgid ""
"Before we build our first BeeWare app, we have to make sure we've got all "
"the prerequisites for running BeeWare."
msgstr "在建立第一個 BeeWare 應用程式之前，我們必須確保具備運行 BeeWare "
"的所有先決條件。"

#: docs/en/tutorial/tutorial-0.md:6
msgid "Install Python { id=\"install-python\" }"
msgstr ""

#: docs/en/tutorial/tutorial-0.md:8
msgid "The first thing we'll need is a working Python interpreter."
msgstr "我們首先需要的是一個可用的 Python 直譯器。"

#: docs/en/tutorial/tutorial-0.md:12
#, fuzzy
msgid ""
"If you're on macOS, you can get an official Python installer from "
"[the Python website]{1}. You can use any version of Python from 3.10 or "
"newer (although you should avoid alphas, betas and release candidates). We "
"strongly recommend using Python 3.13 or newer."
msgstr ""
"如果您使用的是 Windows，則可以從 [Python 網站]{1} 取得官方安裝程式。"
"您可以使用 3.8 及以上的任何穩定版本的 Python。我們建議避免 alpha、beta "
"和候選版本，除非您 **真的** 知道自己在做什麼。"

#: docs/en/tutorial/tutorial-0.md:18
#, fuzzy
msgid ""
"You can also install Python through [Homebrew]{1}, use [pyenv]{2} to manage "
"multiple Python installs, or use [Anaconda]{3} or [Miniconda]{4}. It doesn't "
"matter *how* you've installed Python - it only matters that you can run "
"`python3` from your terminal and get a working, supported Python interpreter."
msgstr ""
"安裝 Python 有很多不同的方法。您可以透過 [homebrew]{1} 安裝 Python。"
"您可以使用 [pyenv]{2} 來管理同一台電腦上的多個 Python 安裝。 Windows "
"使用者可以從 Windows App Store 安裝 Python。有數據科學背景的用戶可能希望使用 "
"[Anaconda]{3} 或 [Miniconda]{4} 。"

#: docs/en/tutorial/tutorial-0.md:28
msgid ""
"Xcode and the Command-line Developer Tools provide a version of Python; "
"however that Python is version 3.9. Python 3.9 has reached end-of-life, and "
"is no longer supported by Python or BeeWare. You will *not* be able to the "
"Xcode-provided version of Python to run this tutorial."
msgstr ""

#: docs/en/tutorial/tutorial-0.md:33
msgid ""
"To check the version of Python that you have installed, run the following "
"command:"
msgstr ""

#: docs/en/tutorial/tutorial-0.md:40
msgid "If Python is installed, you'll see its version number."
msgstr ""

#: docs/en/tutorial/tutorial-0.md:46
msgid ""
"If you're on Linux, you'll install Python using the system package manager "
"(`apt` on Debian/Ubuntu/Mint, `dnf` on Fedora, or `pacman` on Arch)."
msgstr ""
"如果您使用的是 Linux，則會使用系統套件管理器（Debian/Ubuntu/Mint 上的 `apt` "
"、Fedora 上的 `dnf` 或 Arch 上的 `pacman` ）安裝 Python。"

#: docs/en/tutorial/tutorial-0.md:50
#, fuzzy
msgid ""
"You should ensure that the system Python is Python 3.10 or newer; if it "
"isn't (e.g., Ubuntu 20.04 ships with Python 3.8), you'll need to upgrade "
"your Linux distribution to something more recent."
msgstr ""
"您應該確保系統Python是Python 3.8或更高版本；如果不是（例如，Ubuntu 18.04 "
"附帶 Python 3.6），則需要將 Linux 發行版升級到更新的版本。"

#: docs/en/tutorial/tutorial-0.md:54
msgid "Support for Raspberry Pi is limited at this time."
msgstr "目前對 Raspberry Pi 的支援有限。"

#: docs/en/tutorial/tutorial-0.md:56
msgid ""
"**Important:** You *must* use the system Python provided by your operating "
"system. Alternative Python installations (pyenv, Anaconda, manually compiled "
"Python, etc.) will prevent you from successfully packaging your application "
"for distribution in later steps of this tutorial."
msgstr ""

#: docs/en/tutorial/tutorial-0.md:66
#, fuzzy
msgid ""
"If you're on Windows, you can get the official installer from "
"[the Python website]{1}. You can use any version of Python from 3.10 to 3.13 "
"(although you should avoid alphas, betas and release candidates). We "
"strongly recommend using Python 3.13."
msgstr ""
"如果您使用的是 Windows，則可以從 [Python 網站]{1} 取得官方安裝程式。"
"您可以使用 3.8 及以上的任何穩定版本的 Python。我們建議避免 alpha、beta "
"和候選版本，除非您 **真的** 知道自己在做什麼。"

#: docs/en/tutorial/tutorial-0.md:71
#, fuzzy
msgid "Support for Windows on ARM64 is limited at this time."
msgstr "目前對 Raspberry Pi 的支援有限。"

#: docs/en/tutorial/tutorial-0.md:73
#, fuzzy
msgid ""
"You can also install Python from the Windows App Store, or use [Anaconda]{1} "
"or [Miniconda]{2}. It doesn't matter *how* you've installed Python - it only "
"matters that you can run `python3` from your command prompt and get a "
"working, supported Python interpreter."
msgstr ""
"如果你在 macOS 或 Windows 上，你如何安裝 Python 並不重要 - "
"重要的是你可以從作業系統的命令提示字元/終端應用程式運行 `python3` ，"
"並獲得一個可用的 Python 直譯器。"

#: docs/en/tutorial/tutorial-0.md:82
msgid "Install dependencies { id=\"install-dependencies\" }"
msgstr ""

#: docs/en/tutorial/tutorial-0.md:84
msgid ""
"Next, install the additional dependencies needed for your operating system:"
msgstr "接下來，安裝作業系統所需的其他依賴項："

#: docs/en/tutorial/tutorial-0.md:89
msgid "Building BeeWare apps on macOS requires:"
msgstr "在 macOS 上建立 BeeWare 應用程式需要："

#: docs/en/tutorial/tutorial-0.md:91
msgid ""
"**Git**, a version control system. This is included with Xcode or the "
"command line developer tools, which you installed above. You may need to "
"open Xcode for the first time in order for Git to work in your terminal "
"session. If it still doesn't register that Git is installed, you may need to "
"restart your terminal session."
msgstr ""

#: docs/en/tutorial/tutorial-0.md:101
msgid ""
"To support local development, you'll need to install some system packages. "
"The list of packages required varies depending on your distribution:"
msgstr "為了支援本地開發，您需要安裝一些系統軟體包。所需的軟體包清單因您的發行版而異"
"："

#: docs/en/tutorial/tutorial-0.md:105
#, fuzzy
msgid "**Ubuntu / Debian**"
msgstr "**Ubuntu 20.04+ / Debian 10+**"

#: docs/en/tutorial/tutorial-0.md:112
msgid "**Fedora**"
msgstr "**Fedora**"

#: docs/en/tutorial/tutorial-0.md:118
#, fuzzy
msgid "**Arch / Manjaro**"
msgstr "**Arch, Manjaro**"

#: docs/en/tutorial/tutorial-0.md:124
msgid "**OpenSUSE Tumbleweed**"
msgstr ""

#: docs/en/tutorial/tutorial-0.md:134
msgid "Building BeeWare apps on Windows requires:"
msgstr "在 Windows 上建立 BeeWare 應用程式需要："

#: docs/en/tutorial/tutorial-0.md:136
#, fuzzy
msgid ""
"**Git**, a version control system. You can download Git from from {1}[git-"
"scm.com]{2}."
msgstr "**Git** ，版本控制系統。您可以從 [git-scm.com]{1} 下載 Git。"

#: docs/en/tutorial/tutorial-0.md:139
msgid ""
"After installing these tools, you should ensure you restart any terminal "
"sessions. Windows will only expose newly installed tools terminals started "
"*after* the install has completed."
msgstr "安裝這些工具後，您應該確保重新啟動所有終端會話。 Windows 只會公開安裝完成 "
"*之後* 啟動的新安裝的工具終端。"

#: docs/en/tutorial/tutorial-0.md:145
msgid "Set up a virtual environment"
msgstr "設定虛擬環境"

#: docs/en/tutorial/tutorial-0.md:147
msgid ""
"We're now going to create a virtual environment - a \"sandbox\" that we can "
"use to isolate our work on this tutorial from our main Python installation. "
"If we install packages into the virtual environment, our main Python "
"installation (and any other Python projects on our computer) won't be "
"affected. If we make a complete mess of our virtual environment, we'll be "
"able to simply delete it and start again, without affecting any other Python "
"project on our computer, and without the need to re-install Python."
msgstr ""
"現在，我們將創建一個虛擬環境 - 一個 [沙箱` ，"
"我們可以使用它來將本教程的工作與主 Python "
"安裝隔離。如果我們將套件安裝到虛擬環境中，我們的主要 Python 安裝（"
"以及我們電腦上的任何其他 Python "
"專案）將不會受到影響。如果我們把虛擬環境弄得一團糟，我們只需刪除它並重新開始"
"，就不會影響我們電腦上的任何其他 Python 項目，也不需要重新安裝 Python。"

#: docs/en/tutorial/tutorial-0.md:187
msgid ""
"If you're not using Python 3.12, replace the `-3.12` in these instructions "
"with the version number that you are using."
msgstr ""

#: docs/en/tutorial/tutorial-0.md:190
msgid "/// admonition | Errors running PowerShell Scripts"
msgstr ""

#: docs/en/tutorial/tutorial-0.md:192
msgid "If you're using PowerShell, and you receive the error:"
msgstr "如果您使用 PowerShell，並且收到錯誤:"

#: docs/en/tutorial/tutorial-0.md:198
msgid ""
"Your Windows account doesn't have permissions to run scripts. To fix this:"
msgstr "您的 Windows 帳戶沒有執行腳本的權限。要解決此問題："

#: docs/en/tutorial/tutorial-0.md:201
msgid "Run [Windows PowerShell as Administrator]{1}."
msgstr ""

#: docs/en/tutorial/tutorial-0.md:202
msgid "Run `set-executionpolicy RemoteSigned`"
msgstr "運行 `set-executionpolicy RemoteSigned`"

#: docs/en/tutorial/tutorial-0.md:203
msgid "Select `Y` to change the execution policy."
msgstr "選擇 `Y` 更改執行策略。"

#: docs/en/tutorial/tutorial-0.md:205
msgid ""
"Once you've done this you can rerun `beeware-venv\\Scripts\\activate.ps1` in "
"your original PowerShell session (or a new session in the same directory)."
msgstr ""
"完成此操作後，您可以在原始 PowerShell 會話（或同一目錄中的新會話）中重新執行 "
"`beeware-venv\\Scripts\\activate.ps1` 。"

#: docs/en/tutorial/tutorial-0.md:213
msgid ""
"If this worked, your prompt should now be changed - it should have a "
"`(beeware-venv)` prefix. This lets you know that you're currently in your "
"BeeWare virtual environment. Whenever you're working on this tutorial, you "
"should make sure your virtual environment is activated. If it isn't, re-run "
"the last command (the `activate` command) to re-activate your environment."
msgstr ""
"如果這有效，你的提示現在應該改變 - 它應該有一個 `(beeware-venv)` 前綴。"
"這可以讓您知道您目前處於 BeeWare "
"虛擬環境。每當您學習本教學時，您都應該確保您的虛擬環境已啟動。如果不是，請重"
"新執行最後一個命令（ `activate` 命令）以啟動您的虛擬環境。"

#: docs/en/tutorial/tutorial-0.md:220
msgid "/// admonition | Alternative virtual environments"
msgstr ""

#: docs/en/tutorial/tutorial-0.md:222
msgid ""
"If you're using Anaconda or miniconda, you may be more familiar with using "
"conda environments. You might also have heard of `virtualenv`, a predecessor "
"to Python's built in `venv` module. As with Python installs -if you're on "
"macOS or Windows, it doesn't matter *how* you create your virtual "
"environment, as long as you have one. If you're on Linux, you should stick "
"to `venv` and the system Python."
msgstr ""

#: docs/en/tutorial/tutorial-0.md:231
#: docs/en/tutorial/tutorial-1.md:258
#: docs/en/tutorial/tutorial-2.md:373
#: docs/en/tutorial/tutorial-3.md:597
#: docs/en/tutorial/tutorial-4.md:278
#: docs/en/tutorial/tutorial-5/android.md:408
#: docs/en/tutorial/tutorial-5/iOS.md:154
#: docs/en/tutorial/tutorial-6.md:174
#: docs/en/tutorial/tutorial-7.md:733
#: docs/en/tutorial/tutorial-8.md:375
msgid "Next steps"
msgstr "下一步"

#: docs/en/tutorial/tutorial-0.md:233
#, fuzzy
msgid ""
"We've now set up our environment. We're ready to "
"[create our first BeeWare application]{1}."
msgstr "我們現在已經設定好了我們的環境。我們準備好 [創建我們的第一個 BeeWare "
"應用程式<tutorial-1>[。"

#: docs/en/tutorial/tutorial-1.md:1
#, fuzzy
msgid "Tutorial 1 - Your first app"
msgstr "教學 1 - 您的第一個應用程式"

#: docs/en/tutorial/tutorial-1.md:3
msgid "We're ready to create our first application."
msgstr "我們已準備好創建我們的第一個應用程式。"

#: docs/en/tutorial/tutorial-1.md:5
msgid "Install the BeeWare tools"
msgstr "安裝 BeeWare 工具"

#: docs/en/tutorial/tutorial-1.md:7
#, fuzzy
msgid ""
"First, we need to install **Briefcase**. Briefcase is a BeeWare tool that "
"can be used to package your application for distribution to end users - but "
"it can also be used to bootstrap a new project. Make sure you're in the "
"`beeware-tutorial` directory you created in [Tutorial 0]{1}, with the "
"`beeware-venv` virtual environment activated, and run:"
msgstr ""
"首先，我們需要安裝 **Briefcase**。 它是一個 BeeWare 工具，"
"可用於打包應用程式以分發給最終用戶 - 但它也可用於引導新專案。確保您位於 "
"[教學 0]{1} 中建立的 `beeware-tutorial` 目錄中，啟動 `beeware-venv` "
"虛擬環境，然後執行："

#: docs/en/tutorial/tutorial-1.md:28
#: docs/en/tutorial/tutorial-1.md:44
msgid "/// admonition | Possible errors during installation"
msgstr ""

#: docs/en/tutorial/tutorial-1.md:30
msgid ""
"If you see errors during installation, it's almost certainly because some of "
"the system requirements haven't been installed. Make sure you have "
"[installed all the platform pre-requisites][install-dependencies]."
msgstr ""

#: docs/en/tutorial/tutorial-1.md:46
msgid ""
"It is important that you use `python -m pip`, rather than a bare `pip`. "
"Briefcase needs to ensure that it has an up-to-date version of `pip` and "
"`setuptools`, and a bare invocation of `pip` can't self-update. If you want "
"to know more, [Brett Cannon has a detailed blog post about the issue]{1}."
msgstr ""
"使用 `python -m pip` ，而不是只有 `pip` ，這一點很重要。 "
"Briefcase需要確保它有最新版本的 `pip` 和 `setuptools` ，並且單純調用 `pip` "
"無法自我更新。如果您想了解更多信息，"
"[Brett Cannon 有一篇關於該問題的詳細博客文章]{1} 。"

#: docs/en/tutorial/tutorial-1.md:56
msgid "Bootstrap a new project"
msgstr "開始一個新項目"

#: docs/en/tutorial/tutorial-1.md:58
msgid ""
"Let's start our first BeeWare project! We're going to use the Briefcase `new`"
" command to create an application called **Hello World**. Run the following "
"from your command prompt:"
msgstr ""

#: docs/en/tutorial/tutorial-1.md:86
msgid ""
"Briefcase will ask us for some details of our new application. For the "
"purposes of this tutorial, use the following:"
msgstr "Briefcase "
"將詢問我們新應用程式的一些詳細資訊。出於本教學的目的，請使用以下內容："

#: docs/en/tutorial/tutorial-1.md:89
msgid "**Formal Name** - Accept the default value: `Hello World`."
msgstr "**正式名稱** - 接受預設值： `Hello World` 。"

#: docs/en/tutorial/tutorial-1.md:90
msgid "**App Name** - Accept the default value: `helloworld`."
msgstr "**應用程式名稱** - 接受預設值： `helloworld` 。"

#: docs/en/tutorial/tutorial-1.md:91
#, fuzzy
msgid ""
"**Bundle Identifier** - If you own your own domain, enter that domain in "
"reversed order. (For example, if you own the domain \"cupcakes.com\", enter "
"`com.cupcakes` as the bundle). If you don't own your own domain, accept the "
"default bundle (`com.example`)."
msgstr ""
"**封裝名稱** - 如果您擁有自己的網域，請以相反的順序輸入該網域。 （例如，"
"如果您擁有網域名稱 `cupcakes.com` ，請輸入 `com.cupcakes` "
"作為捆綁包）。如果您不擁有自己的網域，請接受預設捆綁包（ `com.example` ）。"

#: docs/en/tutorial/tutorial-1.md:95
msgid "**Project Name** - Accept the default value: `Hello World`."
msgstr "**項目名稱** - 接受預設值： `Hello World` 。"

#: docs/en/tutorial/tutorial-1.md:96
msgid ""
"**Description** - Accept the default value (or, if you want to be really "
"creative, come up with your own description!)"
msgstr "**描述** - 接受預設值（或者，如果您想真正發揮創意，請提出您自己的描述！）"

#: docs/en/tutorial/tutorial-1.md:98
msgid "**Author** - Enter your own name here."
msgstr "**作者** - 在此輸入您自己的姓名。"

#: docs/en/tutorial/tutorial-1.md:99
#, fuzzy
msgid ""
"**Author's Email** - Enter your own email address. This will be used in the "
"configuration file, in help text, and anywhere that an email is required "
"when submitting the app to an app store."
msgstr "**作者的電子郵件** - "
"輸入您自己的電子郵件地址。這將用在設定檔、說明文字以及將應用程式提交到應用程"
"式商店時需要電子郵件的任何地方。"

#: docs/en/tutorial/tutorial-1.md:102
#, fuzzy
msgid ""
"**Application URL** - The URL of the landing page for your application. "
"Again, if you own your own domain, enter a URL at that domain (including the "
"`https://`). Otherwise, just accept the default URL (`https://example.com/"
"helloworld`). This URL doesn't need to actually exist (for now); it will "
"only be used if you publish your application to an app store."
msgstr ""
"**URL** - 您的應用程式的登入頁面的 URL。同樣，如果您擁有自己的網域，"
"請輸入該網域的 URL（包括 `https://` ）。否則，只需接受預設 URL (`https://"
"example.com/helloworld`)。該 URL "
"不需要實際存在（目前）；只有當您將應用程式發佈到應用程式商店時才會使用它。"

#: docs/en/tutorial/tutorial-1.md:108
#, fuzzy
msgid ""
"**Project License** - Accept the default license (BSD). This won't affect "
"anything about the operation of the tutorial, though - so if you have "
"particularly strong feelings about license choice, feel free to choose "
"another license."
msgstr ""
"**許可證** - 接受預設許可證 (BSD)。不過，這不會影響本教學的操作 - "
"因此，如果您對許可證選擇有特別強烈的感覺，請隨意選擇其他許可證。"

#: docs/en/tutorial/tutorial-1.md:112
msgid ""
"**GUI framework** - Accept the default option, Toga (BeeWare's own GUI "
"toolkit)."
msgstr "**GUI 框架** - 接受預設選項 Toga（BeeWare 自己的 GUI 工具）。"

#: docs/en/tutorial/tutorial-1.md:115
msgid ""
"Briefcase will then generate a project skeleton for you to use. If you've "
"followed this tutorial so far, and accepted the defaults as described, your "
"file system should look something like:"
msgstr "然後，Briefcase "
"將產生一個專案框架供您使用。如果您到目前為止已經遵循了本教學，並接受了所描述"
"的預設設置，您的資料夾應該類似於："

#: docs/en/tutorial/tutorial-1.md:141
msgid ""
"This skeleton is actually a fully functioning application without adding "
"anything else. The `src` folder contains all the code for the application, "
"the `tests` folder contains an initial test suite, and the `pyproject.toml` "
"file describes how to package the application for distribution. If you open "
"`pyproject.toml` in an editor, you'll see the configuration details you just "
"provided to Briefcase."
msgstr ""
"這個框架實際上是一個功能齊全的應用程式，無需添加任何其他內容。 `src` "
"資料夾包含應用程式的所有程式碼， `tests` 資料夾包含初始測試套件， "
"`pyproject.toml` 檔案描述如何打包應用程式以進行分發。如果您在編輯器中開啟 "
"`pyproject.toml` ，您將看到剛剛提供給 `Briefcase` 的設定詳細資訊。"

#: docs/en/tutorial/tutorial-1.md:148
msgid ""
"Now that we have a stub application, we can use Briefcase to run the "
"application."
msgstr "現在我們有了一個未打包的應用程式，我們可以使用 Briefcase 來運行該應用程式。"

#: docs/en/tutorial/tutorial-1.md:151
msgid "Run the app in developer mode"
msgstr "在開發者模式下運行應用程式"

#: docs/en/tutorial/tutorial-1.md:153
msgid ""
"Move into the `helloworld` project directory and tell briefcase to start the "
"project in Developer (or `dev`) mode:"
msgstr "進入 `helloworld` 專案目錄並告訴公事包以開發人員（或 `dev` ）模式啟動專案："

#: docs/en/tutorial/tutorial-1.md:202
#: docs/en/tutorial/tutorial-2.md:332
msgid "This should open a GUI window:"
msgstr "這應該打開一個 GUI 視窗："

#: docs/en/tutorial/tutorial-1.md:206
msgid "![Hello World Tutorial 1 window, on macOS]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-1.md:216
msgid "![Hello World Tutorial 1 window, on Linux]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-1.md:226
msgid "![Hello World Tutorial 1 window, on Windows]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-1.md:232
msgid "/// admonition | Invalid requirements or pip unable to connect"
msgstr ""

#: docs/en/tutorial/tutorial-1.md:234
msgid "If you encounter the error:"
msgstr ""

#: docs/en/tutorial/tutorial-1.md:242
msgid ""
"Confirm that you are running a "
"[version of python that this tutorial supports][install-python]."
msgstr ""

#: docs/en/tutorial/tutorial-1.md:245
msgid ""
"If your version of python is *not* a supported version, you will have to "
"restart the tutorial."
msgstr ""

#: docs/en/tutorial/tutorial-1.md:252
#, fuzzy
msgid ""
"Close the application - either by pressing the close button on the "
"application window, by selecting Quit/Exit from the application's menu, or "
"by typing **Ctrl+C** in the terminal where you ran `briefcase dev` - and "
"you're done! Congratulations - you've just written a standalone, native "
"application in Python!"
msgstr "按下關閉按鈕（或從應用程式的選單中選擇退出），就完成了！恭喜 - 您剛剛用 "
"Python 編寫了一個獨立的本機應用程式！"

#: docs/en/tutorial/tutorial-1.md:260
#, fuzzy
msgid ""
"We now have a working application, running in developer mode. Now we can add "
"some logic of our own to make our application do something a little more "
"interesting. In [Tutorial 2]{1}, we'll put a more useful user interface onto "
"our application."
msgstr ""
"我們現在有了一個可以運行的應用程序，在開發人員模式下運行。現在我們可以添加一"
"些我們自己的邏輯，使我們的應用程式做一些更有趣的事情。在 :doc:`教程 2 "
"中<tutorial-2>`，我們將在我們的應用程式中放置一個更有用的使用者介面。"

#: docs/en/tutorial/tutorial-2.md:1
#, fuzzy
msgid "Tutorial 2 - Making it interesting"
msgstr "教學 2 - 讓它變得有趣"

#: docs/en/tutorial/tutorial-2.md:3
#, fuzzy
msgid ""
"In [Tutorial 1]{1}, we generated a stub project that was able to run, but we "
"didn't write any code ourselves. Let's take a look at what was generated for "
"us."
msgstr "在 [教程 1 "
"中<tutorial-1>`，我們產生了一個能夠運行的存根項目，但我們自己沒有寫任何程式碼"
"。讓我們看看為我們產生了什麼。"

#: docs/en/tutorial/tutorial-2.md:7
#, fuzzy
msgid "What was generated"
msgstr "生成了什麼"

#: docs/en/tutorial/tutorial-2.md:9
#, fuzzy
msgid ""
"In the `src/helloworld` directory, you should see 3 files: `__init__.py`, "
"`__main__.py` and `app.py`."
msgstr "在 src/helloworld 目錄中，您應該會看到 3 個檔案：__init__.py、__main__.py 和 "
"app.py。"

#: docs/en/tutorial/tutorial-2.md:12
#, fuzzy
msgid ""
"`__init__.py` marks the `helloworld` directory as an importable Python "
"module. It is an empty file; the very fact it exists tells the Python "
"interpreter that the `helloworld` directory defines a module."
msgstr ""
"`__init__.py` 將`helloworld` 目錄標記為可匯入的Python 模組。這是一個空文件；"
"它的存在告訴 Python 解釋器`helloworld`目錄定義了一個模組。"

#: docs/en/tutorial/tutorial-2.md:16
msgid ""
"`__main__.py` marks the `helloworld` module as a special kind of module -an "
"executable module. If you try to run the `helloworld` module using `python -"
"m helloworld`, the `__main__.py` file is where Python will start executing. "
"The contents of `__main__.py` is relatively simple:"
msgstr ""

#: docs/en/tutorial/tutorial-2.md:28
msgid "This file does two things:"
msgstr ""

#: docs/en/tutorial/tutorial-2.md:30
msgid "It imports the `main` method from the `helloworld` app."
msgstr ""

#: docs/en/tutorial/tutorial-2.md:31
#, fuzzy
msgid ""
"Then, it starts the application’s main loop. The main loop is the way a GUI "
"application listens for user input (like mouse clicks and keyboard presses)."
msgstr ""
"也就是說 - 它從`helloworld`應用程式導入`main`方法；如果它是作為入口點執行，"
"則呼叫 main() 方法，並啟動應用程式的主循環。主循環是 GUI "
"應用程式偵聽使用者輸入（如滑鼠點擊和鍵盤按下）的方式。"

#: docs/en/tutorial/tutorial-2.md:35
#, fuzzy
msgid ""
"The more interesting file is `app.py` - this contains the logic that creates "
"our application window:"
msgstr "更有趣的檔案是`app.py`——它包含創建我們的應用程式視窗的邏輯:"

#: docs/en/tutorial/tutorial-2.md:54
#, fuzzy
msgid "Let's go through this line by line:"
msgstr "讓我們逐行瀏覽一下："

#: docs/en/tutorial/tutorial-2.md:61
#, fuzzy
msgid ""
"First, we import the `toga` widget toolkit, as well as some style-related "
"utility constants. Our code doesn't use these yet - but we'll make use of "
"them shortly."
msgstr "首先，我們匯入`toga`小工具工具包，以及一些與樣式相關的實用程式類別和常數。"
"我們的程式碼尚未使用它們 - 但我們很快就會使用它們。"

#: docs/en/tutorial/tutorial-2.md:65
#, fuzzy
msgid "Then, we define a class:"
msgstr "然後，我們定義一個類別：："

#: docs/en/tutorial/tutorial-2.md:71
#, fuzzy
msgid ""
"Each Toga application has a single `toga.App` instance, representing the "
"running entity that is the application. The app may end up managing multiple "
"windows; but for simple applications, there will be a single main window."
msgstr ""
"每個 Toga "
"應用程式都有一個`toga.App`實例，代表應用程式的運作實體。該應用程式最終可能會"
"管理多個視窗；但對於簡單的應用程序，將有一個主視窗。"

#: docs/en/tutorial/tutorial-2.md:76
#, fuzzy
msgid "Next, we define a `startup()` method:"
msgstr "接下來，我們定義一個`startup()`方法："

#: docs/en/tutorial/tutorial-2.md:83
#, fuzzy
msgid ""
"The first thing the startup method does is to define a main box. Toga's "
"layout scheme behaves similar to HTML. You build an application by "
"constructing a collection of boxes, each of which contains other boxes, or "
"actual widgets. You then apply styles to these boxes to define how they will "
"consume the available window space."
msgstr ""
"啟動方法所做的第一件事是定義一個主框。 Toga 的佈局方案的行為與 HTML "
"類似。您可以透過建立一組框來建立應用程序，每個框都包含其他框或實際的小部件。"
"然後，您可以將樣式套用到這些方塊來定義它們將如何使用可用的視窗空間。"

#: docs/en/tutorial/tutorial-2.md:89
#, fuzzy
msgid ""
"In this application, we define a single box, but we don't put anything into "
"it."
msgstr "在此應用程式中，我們定義了一個框，但沒有在其中放入任何內容。"

#: docs/en/tutorial/tutorial-2.md:92
#, fuzzy
msgid "Next, we define a window into which we can put this empty box:"
msgstr "接下來，我們定義一個窗口，可以將這個空框放入其中："

#: docs/en/tutorial/tutorial-2.md:98
#, fuzzy
msgid ""
"This creates an instance of a `toga.MainWindow`, which will have a title "
"matching the application's name. A Main Window is a special kind of window "
"in Toga - it's a window that is closely bound to the life cycle of the app. "
"When the Main Window is closed, the application exits. The Main Window is "
"also the window that has the application's menu (if you're on a platform "
"like Windows where menu bars are part of the window)."
msgstr ""
"這將建立一個`toga.MainWindow`實例，它將具有與應用程式名稱相符的標題。"
"主視窗是 Toga 中的一種特殊視窗 - "
"它是與應用程式的生命週期密切相關的視窗。當主視窗關閉時，應用程式退出。主視窗"
"也是具有應用程式選單的視窗（如果您使用的是 Windows "
"等平台，其中功能表列是視窗的一部分）"

#: docs/en/tutorial/tutorial-2.md:106
msgid "/// admonition | Where is my window?"
msgstr ""

#: docs/en/tutorial/tutorial-2.md:108
msgid ""
"If you have made an error in your code, the main window of the app may not "
"display. If this happens, you can type **Ctrl+C** in the terminal where you "
"started the app. This will stop the app. You can then fix the error and "
"restart the app."
msgstr ""

#: docs/en/tutorial/tutorial-2.md:115
#, fuzzy
msgid ""
"We then add our empty box as the content of the main window, and instruct "
"the application to show our window:"
msgstr "然後，我們添加空框作為主視窗的內容，並指示應用程式顯示我們的視窗:"

#: docs/en/tutorial/tutorial-2.md:123
msgid ""
"Last of all, we define a `main()` function. This is what creates the "
"instance of our application:"
msgstr "最後，我們定義一個`main()`方法。這就是創建我們的應用程式實例的原因:"

#: docs/en/tutorial/tutorial-2.md:131
#, fuzzy
msgid ""
"This `main()` method is the one that is imported and invoked by `__main__.py`"
". It creates and returns an instance of our `HelloWorld` application."
msgstr "這個`main()`方法是由`__main__.py`導入和呼叫的方法。它創建並傳回我們的`HelloWo"
"rld`應用程式的實例。"

#: docs/en/tutorial/tutorial-2.md:135
#, fuzzy
msgid ""
"That's the simplest possible Toga application. Let's put some of our own "
"content into the application, and make the app do something interesting."
msgstr "這是最簡單的 Toga "
"應用程式。讓我們將一些我們自己的內容放入應用程式中，並使應用程式做一些有趣的"
"事情。"

#: docs/en/tutorial/tutorial-2.md:138
#, fuzzy
msgid "Adding some content of our own"
msgstr "添加一些我們自己的內容"

#: docs/en/tutorial/tutorial-2.md:140
msgid "Let's do something more interesting with our `HelloWorld` app."
msgstr ""

#: docs/en/tutorial/tutorial-2.md:144
#, fuzzy
msgid ""
"When you make these changes, make sure you keep the imports at the top of "
"the file, and the `main()` at the bottom of the file. You only need to "
"update the `HelloWorld` class."
msgstr "不要刪除文件頂部的導入或底部的`main()`。您只需要更新`HelloWorld`類別。"

#: docs/en/tutorial/tutorial-2.md:150
#, fuzzy
msgid ""
"Modify your `HelloWorld` class inside `src/helloworld/app.py` so that it "
"looks like this:"
msgstr "修改`src/helloworld/app.py`中的`HelloWorld`類，使其看起來像這樣:"

#: docs/en/tutorial/tutorial-2.md:185
#, fuzzy
msgid "Let's look in detail at what has changed."
msgstr "讓我們詳細看看發生了什麼變化。"

#: docs/en/tutorial/tutorial-2.md:187
#, fuzzy
msgid "We're still creating a main box; however, we are now applying a style:"
msgstr "我們仍在創建一個主盒子；然而，我們現在正在應用一種風格:"

#: docs/en/tutorial/tutorial-2.md:193
#, fuzzy
msgid ""
"Toga's built-in layout system is called \"Pack\". It behaves a lot like CSS. "
"You define objects in a hierarchy - in HTML, the objects are `<div>`, "
"`<span>`, and other DOM elements; in Toga, they're widgets and boxes. You "
"can then assign styles to the individual elements. In this case, we're "
"indicating that this is a `COLUMN` box - that is, it is a box that will "
"consume all the available width, and will expand its height as content is "
"added, but it will try to be as short as possible."
msgstr ""
"Toga 的內建佈局系統稱為`Pack`。它的行為很像 CSS。您可以在層次結構中定義物件 -"
" 在 HTML 中，物件是`<div>`、`][span]` 和其他 DOM 元素；在 Toga "
"中，它們是小部件和盒子。然後，您可以為各個元素指定樣式。在這種情況下，我們表"
"明這是一個`COLUMN`框 - "
"也就是說，它是一個將消耗所有可用寬度的框，並且會在添加內容時擴展其高度，但它"
"會嘗試盡可能短。</span>"

#: docs/en/tutorial/tutorial-2.md:203
msgid ""
"For more advanced uses, Toga also supports a separate style object, which is "
"used like this:"
msgstr ""

#: docs/en/tutorial/tutorial-2.md:213
msgid "Next, we define a couple of widgets:"
msgstr "接下來，我們定義幾個小工具:"

#: docs/en/tutorial/tutorial-2.md:223
#, fuzzy
msgid ""
"Here, we define a Label and a TextInput. Both widgets have styles associated "
"with them; the label will have 5px of margin on its left and right, and no "
"margin on the top and bottom. The TextInput is marked as being flexible - "
"that is, it will absorb all available space in its layout axis."
msgstr ""
"在這裡，我們定義了一個 Label 和一個 "
"TextInput。這兩個小部件都有與之相關的樣式；標籤的左側和右側將有 5 "
"個像素的內邊距，頂部和底部將沒有內邊距。 TextInput 被標記為靈活的 - "
"也就是說，它將吸收其佈局軸中的所有可用空間。"

#: docs/en/tutorial/tutorial-2.md:229
#, fuzzy
msgid ""
"The TextInput is assigned as an instance variable of the class. This gives "
"us easy access to the widget instance - something that we'll use in a moment."
msgstr "TextInput 被指定為該類別的實例變數。這使我們可以輕鬆存取小部件實例 - "
"我們稍後將使用它。"

#: docs/en/tutorial/tutorial-2.md:233
#, fuzzy
msgid "Next, we define a box to hold these two widgets:"
msgstr "接下來，我們定義一個盒子來容納這兩個小工具："

#: docs/en/tutorial/tutorial-2.md:241
#, fuzzy
msgid ""
"The `name_box` is a box just like the main box; however, this time, it's a "
"`ROW` box. That means content will be added horizontally, and it will try to "
"make its width as narrow as possible. The box also has some margin - 5px on "
"all sides."
msgstr ""
"`name_box` "
"是一個像主盒子一樣的盒子；然而，這一次，它是一個`ROW`盒子。這意味著內容將水平"
"添加，並且它將嘗試使其寬度盡可能窄。盒子還有一些內邊距 - 所有邊都是 5px。"

#: docs/en/tutorial/tutorial-2.md:246
#, fuzzy
msgid "Now we define a button:"
msgstr "現在我們定義一個按鈕:"

#: docs/en/tutorial/tutorial-2.md:256
msgid ""
"The button also has 5px of margin on all sides. We also define a *handler* - "
"a method to invoke when the button is pressed."
msgstr ""

#: docs/en/tutorial/tutorial-2.md:259
#, fuzzy
msgid "Then, we add the name box and the button to the main box:"
msgstr "然後，我們將名稱框和按鈕新增到主框："

#: docs/en/tutorial/tutorial-2.md:266
#, fuzzy
msgid ""
"This completes our layout; the rest of the startup method is as it was "
"previously - defining a `MainWindow`, and assigning the main box as the "
"window's content:"
msgstr "這樣就完成了我們的佈局；啟動方法的其餘部分與之前一樣 - 定義一個 "
"MainWindow，並將主框指定為視窗的內容:"

#: docs/en/tutorial/tutorial-2.md:276
#, fuzzy
msgid ""
"The last thing we need to do is define the handler for the button. A handler "
"can be any method, generator, or asynchronous coroutine; it accepts the "
"widget that generated the event as an argument, and will be invoked whenever "
"the button is pressed:"
msgstr ""
"我們需要做的最後一件事是定義按鈕的處理程序。處理程序可以是任何方法、生成器或"
"非同步協程；它接受生成事件的小部件作為參數，並且每當按下按鈕時就會調用:"

#: docs/en/tutorial/tutorial-2.md:286
#, fuzzy
msgid ""
"The body of the method is a simple print statement - however, it will "
"interrogate the current value of the name input, and use that content as the "
"text that is printed."
msgstr "該方法的主體是一個簡單的列印語句 - "
"但是，它將詢問名稱輸入的當前值，並使用該內容作為列印的文字。"

#: docs/en/tutorial/tutorial-2.md:290
#, fuzzy
msgid ""
"Now that we've made these changes we can see what they look like by starting "
"the application again. As before, we'll use developer mode:"
msgstr "現在我們已經進行了這些更改，我們可以透過再次啟動應用程式來查看它們的外觀。和"
"以前一樣，我們將使用開發者模式："

#: docs/en/tutorial/tutorial-2.md:326
#, fuzzy
msgid ""
"You'll notice that this time, it *doesn't* install dependencies. Briefcase "
"can detect that the application has been run before, and to save time, will "
"only run the application. If you add new dependencies to your app, you need "
"to make sure that they're installed by passing in a `-r` option when you run "
"`briefcase dev`."
msgstr ""
"您會注意到，這一次，它`不`安裝依賴項。公文包可以檢測到該應用程式之前已經運行"
"過，為了節省時間，只會運行該應用程式。如果您為應用程式新增的依賴項，則可以在"
"執行`briefcase dev`時傳入`-r`選項來確保它們已安裝。"

#: docs/en/tutorial/tutorial-2.md:336
msgid "![Hello World Tutorial 2 window, on macOS]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-2.md:346
msgid "![Hello World Tutorial 2 window, on Linux]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-2.md:356
msgid "![Hello World Tutorial 2 window, on Windows]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-2.md:364
#, fuzzy
msgid ""
"If you enter a name in the text box, and press the GUI button, you should "
"see output appear in the console where you started the application."
msgstr "如果您在文字方塊中輸入名稱，然後按 GUI "
"按鈕，您應該會看到啟動應用程式的控制台中出現輸出。"

#: docs/en/tutorial/tutorial-2.md:368
msgid ""
"Before continuing, close the app. As with Tutorial 1, you can do this by "
"pressing the close button on the application window, by selecting Quit/Exit "
"from the application's menu, or by typing **Ctrl+C** in the terminal where "
"you ran `briefcase dev`."
msgstr ""

#: docs/en/tutorial/tutorial-2.md:375
#, fuzzy
msgid ""
"We've now got an application that does something a little more interesting. "
"But it only runs on our own computer. Let's package this application for "
"distribution. In [Tutorial 3]{1}, we'll wrap our application up as a "
"standalone installer that we could send to a friend, a customer, or upload "
"to an App Store."
msgstr ""
"我們現在有了一個可以做一些更有趣的事情的應用程式。但它只能在我們自己的計算機"
"上運行。讓我們打包這個應用程式以進行分發。在 :doc:`教程 3 "
"中<tutorial-3>`，我們將把我們的應用程式打包為一個獨立的安裝程序，我們可以將其"
"發送給朋友、客戶，或上傳到應用程式商店。"

#: docs/en/tutorial/tutorial-3.md:1
#, fuzzy
msgid "Tutorial 3 - Packaging for distribution"
msgstr "教學 3 - 分發包裝"

#: docs/en/tutorial/tutorial-3.md:3
#, fuzzy
msgid ""
"So far, we've been running our application in \"Developer mode\". This makes "
"it easy for us to run our application locally - but what we really want is "
"to be able to give our application to others."
msgstr ""
"到目前為止，我們一直在`開發人員模式`下運行我們的應用程式。"
"這使我們可以輕鬆地在本地運行我們的應用程式 - "
"但我們真正想要的是能夠將我們的應用程式提供給其他人。"

#: docs/en/tutorial/tutorial-3.md:7
#, fuzzy
msgid ""
"However, we don't want to have to teach our users how to install Python, "
"create a virtual environment, clone a git repository, and run Briefcase in "
"developer mode. We'd rather just give them an installer, and have the "
"application Just Work."
msgstr ""
"但是，我們不想教導使用者如何安裝 Python、建立虛擬環境、複製 git "
"儲存庫以及在開發人員模式下執行 "
"Briefcase。我們寧願只給他們一個安裝程序，然後讓應用程式正常工作。"

#: docs/en/tutorial/tutorial-3.md:12
#, fuzzy
msgid ""
"Briefcase can be used to package your application for distribution in this "
"way."
msgstr "公文包可用於打包您的應用程式以透過這種方式進行分發。"

#: docs/en/tutorial/tutorial-3.md:15
#, fuzzy
msgid "Creating your application scaffold"
msgstr "創建您的應用程式支架"

#: docs/en/tutorial/tutorial-3.md:17
#, fuzzy
msgid ""
"Since this is the first time we're packaging our application, we need to "
"create some configuration files and other scaffolding to support the "
"packaging process. From the `helloworld` directory, run:"
msgstr "由於這是我們第一次打包應用程序，因此我們需要創建一些配置文件和其他腳手架來支"
"援打包過程。從`helloworld`目錄中，運行："

#: docs/en/tutorial/tutorial-3.md:83
msgid "/// admonition | Errors about Python versions"
msgstr ""

#: docs/en/tutorial/tutorial-3.md:85
msgid "If you receive an error that reads something like:"
msgstr ""

#: docs/en/tutorial/tutorial-3.md:87
msgid ""
"The version of Python being used to run Briefcase (3.12) is not the system "
"python3 (3.10)."
msgstr ""

#: docs/en/tutorial/tutorial-3.md:90
msgid ""
"You will need to recreate your virtual environment using the system `python3`"
". Using the system Python is a requirement for packaging your application."
msgstr ""

#: docs/en/tutorial/tutorial-3.md:124
#, fuzzy
msgid ""
"You've probably just seen pages of content go past in your terminal... so "
"what just happened? Briefcase has done the following:"
msgstr "您可能剛剛在終端機中看到了內容頁面……那麼剛剛發生了什麼？公事包做了以下事情："

#: docs/en/tutorial/tutorial-3.md:127
#, fuzzy
msgid ""
"It **generated an application template**. There's a lot of files and "
"configurations required to build a native installer, above and beyond the "
"code of your actual application. This extra scaffolding is almost the same "
"for every application on the same platform, except for the name of the "
"actual application being constructed - so Briefcase provides an application "
"template for each platform it supports. This step rolls out the template, "
"substituting the name of your application, bundle ID, and other properties "
"of your configuration file as required to support the platform you're "
"building on."
msgstr ""
"它**生成了一個應用程式模板**。建立本機安裝程式需要大量檔案和配置，超出了實際"
"應用程式的程式碼。對於同一平台上的每個應用程式來說，這個額外的腳手架幾乎都是"
"相同的，除了正在構建的實際應用程式的名稱之外- 因此，Briefcase "
"為其支援的每個平台提供了一個應用程式模板。此步驟將推出模板，根據需要替換應用"
"程式的名稱、捆綁 ID 和設定檔的其他屬性，以支援您正在建置的平台。"

#: docs/en/tutorial/tutorial-3.md:127
#, fuzzy
msgid ""
"If you're not happy with the template provided by Briefcase, you can provide "
"your own. However, you probably don't want to do this until you've got a bit "
"more experience using Briefcase's default template."
msgstr "如果您對公文包提供的範本不滿意，您可以提供自己的範本。但是，在使用公文包的預"
"設範本有更多經驗之前，您可能不想這樣做。"

#: docs/en/tutorial/tutorial-3.md:142
#, fuzzy
msgid ""
"It **downloaded and installed a support package**. The packaging approach "
"taken by Briefcase is best described as "
"\"the simplest thing that could possibly work\" - it ships a complete, "
"isolated Python interpreter as part of every application it builds (except "
"for Linux native system package builds). This is slightly space inefficient -"
" if you have 5 applications packaged with Briefcase, you'll have 5 copies of "
"the Python interpreter. However, this approach guarantees that every "
"application is completely independent, using a specific version of Python "
"that is known to work with the application."
msgstr ""
"它**下載並安裝了支援包**。公事包採用的打包方法最好被描述為`可能有效的最簡單的"
"方法`——它提供了一個完整的、獨立的 Python "
"解釋器，作為它構建的每個應用程式的一部分。這在空間效率方面稍顯低下 - "
"如果您有 5 個使用 Briefcase 打包的應用程序，那麼您將擁有 5 個 Python "
"解釋器副本。然而，這種方法保證每個應用程式都是完全獨立的，"
"使用已知可與該應用程式配合使用的特定 Python 版本。"

#: docs/en/tutorial/tutorial-3.md:142
#, fuzzy
msgid ""
"Again, Briefcase provides a default support package for each platform; if "
"you want, you can provide your own support package, and have that package "
"included as part of the build process. You may want to do this if you have "
"particular options in the Python interpreter that you need to have enabled, "
"or if you want to strip modules out of the standard library that you don't "
"need at runtime."
msgstr ""
"同樣，Briefcase "
"為每個平台提供了預設的支援包；如果需要，您可以提供自己的支援包，並將該包包含"
"在建置過程中。如果您需要啟用 Python "
"解釋器中的特定選項，或者想要從標準庫中刪除執行時間不需要的模組，您可能需要執"
"行此操作。"

#: docs/en/tutorial/tutorial-3.md:142
#, fuzzy
msgid ""
"Briefcase maintains a local cache of support packages, so once you've "
"downloaded a specific support package, that cached copy will be used on "
"future builds."
msgstr "公文包維護支援包的本機緩存，因此一旦您下載了特定的支援包，該快取的副本將在未"
"來的版本中使用。"

#: docs/en/tutorial/tutorial-3.md:142
msgid ""
"As noted above, when Briefcase packages an app as a native Linux system "
"package (the default package format for Linux), a support package is not "
"included with the app. Instead, the app will use the Python that is provided "
"by the distribution of Linux being targeted."
msgstr ""

#: docs/en/tutorial/tutorial-3.md:168
#, fuzzy
msgid ""
"It **installed application requirements**. Your application can specify any "
"third-party modules that are required at runtime. These will be installed "
"using `pip` into your application's installer."
msgstr "它**安裝了應用程式要求**。您的應用程式可以指定運行時所需的任何第三方模組。這"
"些將使用`pip`安裝到應用程式的安裝程式中。"

#: docs/en/tutorial/tutorial-3.md:172
#, fuzzy
msgid ""
"It **Installed your application code**. Your application will have its own "
"code and resources (e.g., images that are needed at runtime); these files "
"are copied into the installer."
msgstr "它**安裝了您的應用程式代碼**。您的應用程式將擁有自己的程式碼和資源（例如，運"
"行時所需的映像）；這些檔案被複製到安裝程式中。"

#: docs/en/tutorial/tutorial-3.md:176
#, fuzzy
msgid ""
"It **installed your resources needed by your application.** Lastly, it adds "
"any additional resources that are needed by the installer itself. This "
"includes things like icons that need to be attached to the final application "
"and splash screen images."
msgstr "它 **安裝了應用程式所需的資源。** "
"最後，它添加了安裝程式本身所需的任何其他資源。這包括需要附加到最終應用程式的"
"圖示和啟動螢幕圖像等內容。"

#: docs/en/tutorial/tutorial-3.md:181
#, fuzzy
msgid ""
"Once this completes, if you look in the project directory, you should now "
"see a directory corresponding to your platform (`macOS`, `linux`, or "
"`windows`) that contains additional files. This is the platform-specific "
"packaging configuration for your application."
msgstr ""
"完成後，如果您查看專案目錄，您現在應該會看到與您的平台（`macOS`、`linux`或`wi"
"ndows`）相對應的目錄，其中包含其他檔案。這是您的應用程式的特定於平台的打包配"
"置。"

#: docs/en/tutorial/tutorial-3.md:186
#, fuzzy
msgid "Building your application"
msgstr "建立您的應用程式"

#: docs/en/tutorial/tutorial-3.md:188
#, fuzzy
msgid ""
"You can now compile your application. This step performs any binary "
"compilation that is necessary for your application to be executable on your "
"target platform."
msgstr "現在您可以編譯您的應用程式。此步驟執行應用程式在目標平台上可執行所需的任何二"
"進位編譯。"

#: docs/en/tutorial/tutorial-3.md:205
#, fuzzy
msgid ""
"On macOS, the `build` command doesn't need to *compile* anything, but it "
"does need to sign the contents of binary so that it can be executed. This "
"signature is an *ad hoc* signature - it will only work on *your* machine; if "
"you want to distribute the application to others, you'll need to provide a "
"full signature."
msgstr ""
"在 macOS 上，`build` 命令不需要 *編譯* "
"任何內容，但它確實需要對二進位內容進行簽名，以便可以執行。此簽名是 *臨時* "
"簽名 - 它僅適用於 *您的* "
"機器；如果您想將應用程式分發給其他人，則需要提供完整的簽名。"

#: docs/en/tutorial/tutorial-3.md:239
#, fuzzy
msgid ""
"Once this step completes, the `build` folder will contain a "
"`helloworld-0.0.1` folder that contains a mirror of a Linux `/usr` file "
"system. This file system mirror will contain a `bin` folder with a "
"`helloworld` binary, plus `lib` and `share` folders needed to support the "
"binary."
msgstr ""
"此步驟完成後，`build`資料夾將包含一個`helloworld-0.0.1`資料夾，其中包含 "
"Linux`/usr`檔案系統的鏡像。該檔案系統鏡像將包含一個包含`helloworld`二進位檔案"
"的`bin`資料夾，以及支援該二進位檔案所需的`lib`和`share`資料夾。"

#: docs/en/tutorial/tutorial-3.md:256
#, fuzzy
msgid ""
"On Windows, the `build` command doesn't need to *compile* anything, but it "
"does need to write some metadata so that the application knows its name, "
"version, and so on."
msgstr "在 Windows 上，`build` 命令不需要 *編譯* "
"任何內容，但它確實需要編寫一些元數據，以便應用程式知道其名稱、版本等。"

#: docs/en/tutorial/tutorial-3.md:260
msgid "/// admonition | Triggering antivirus"
msgstr ""

#: docs/en/tutorial/tutorial-3.md:262
#, fuzzy
msgid ""
"Since this metadata is being written directly in to the pre-compiled binary "
"rolled out from the template during the `create` command, this may trigger "
"antivirus software running on your machine and prevent the metadata from "
"being written. In that case, instruct the antivirus to allow the tool (named "
"`rcedit-x64.exe`) to run and re-run the command above."
msgstr ""
"由於此元資料在`create`命令期間直接寫入從範本推出的預編譯二進位檔案中，因此這"
"可能會觸發電腦上執行的防毒軟體並阻止寫入元資料。在這種情況下，指示防毒軟體允"
"許該工具（名為`rcedit-x64.exe`）運行並重新執行上述命令。"

#: docs/en/tutorial/tutorial-3.md:273
#, fuzzy
msgid "Running your app"
msgstr "運行您的應用程式"

#: docs/en/tutorial/tutorial-3.md:275
#, fuzzy
msgid "You can now use Briefcase to run your application:"
msgstr "現在您可以使用 Briefcase 來運行您的應用程式："

#: docs/en/tutorial/tutorial-3.md:354
#, fuzzy
msgid ""
"This will start to run your native application, using the app bundle created "
"by the `build` command."
msgstr "這將開始使用`build`命令的輸出來執行您的本機應用程式。"

#: docs/en/tutorial/tutorial-3.md:357
#, fuzzy
msgid ""
"You might notice some small differences in the way your application looks "
"when it's running. For example, icons and the name displayed by the "
"operating system may be slightly different to those you saw when running "
"under developer mode. This is also because you're using the packaged "
"application, not just running Python code. From the operating system's "
"perspective, you're now running \"an app\", not \"a Python program\", and "
"this is reflected in how the application appears."
msgstr ""
"您可能會注意到應用程式運行時的外觀存在一些細微的差異。例如，作業系統顯示的圖"
"示和名稱可能與您在開發人員模式下運行時看到的圖示略有不同。這也是因為您正在使"
"用打包的應用程序，而不僅僅是運行 Python "
"程式碼。從作業系統的角度來看，您現在運行的是`應用程式`，而不是`Python "
"程式`，這反映在應用程式的顯示方式上。"

#: docs/en/tutorial/tutorial-3.md:365
msgid ""
"Before continuing, close the app. As with previous tutorial steps, you can "
"do this by pressing the close button on the application window, by selecting "
"Quit/Exit from the application's menu, or by typing **Ctrl+C** in the "
"terminal where you ran `briefcase run`."
msgstr ""

#: docs/en/tutorial/tutorial-3.md:370
#, fuzzy
msgid "Building your installer"
msgstr "建立您的安裝程式"

#: docs/en/tutorial/tutorial-3.md:372
#, fuzzy
msgid ""
"You can now package your application for distribution, using the `package` "
"command. The package command does any compilation that is required to "
"convert the scaffolded project into a final, distributable product. "
"Depending on the platform, this may involve compiling an installer, "
"performing code signing, or doing other pre-distribution tasks."
msgstr ""
"現在，您可以使用`package`命令打包您的應用程式以進行分發。 package "
"命令執行將鷹架專案轉換為最終的可分發產品所需的任何編譯。根據平台的不同，這可"
"能涉及編譯安裝程式、執行程式碼簽署或執行其他預分發任務。"

#: docs/en/tutorial/tutorial-3.md:410
#, fuzzy
msgid ""
"The `dist` folder will contain a file named `Hello World-0.0.1.dmg`. If you "
"locate this file in the Finder, and double-click on its icon, you'll mount "
"the DMG, giving you a copy of the Hello World app, and a link to your "
"Applications folder for easy installation. Drag the app file into "
"Applications, and you've installed your application. Send the DMG file to a "
"friend, and they should be able to do the same."
msgstr ""
"`dist` 資料夾將包含一個名為`Hello World-0.0.1.dmg` 的檔案。如果您在 Finder "
"中找到此文件，然後雙擊其圖標，您將安裝 DMG，為您提供 Hello World "
"應用程式的副本以及指向您的應用程式資料夾的鏈接，以便於安裝。將應用程式檔案拖"
"曳到應用程式中，您就已經安裝了應用程式。將 DMG "
"檔案發送給朋友，他們應該能夠執行相同的操作。"

#: docs/en/tutorial/tutorial-3.md:417
#, fuzzy
msgid ""
"In this example, we've used the `--adhoc-sign` option - that is, we're "
"signing our application with *ad hoc* credentials - temporary credentials "
"that will only work on your machine. We've done this to keep the tutorial "
"simple. Setting up code signing identities is a little fiddly, and they're "
"only *required* if you're intending to distribute your application to "
"others. If we were publishing a real application for others to use, we would "
"need to specify real credentials."
msgstr ""
"在此範例中，我們使用了`--adhoc-sign`選項 - 也就是說，我們使用 *ad hoc* "
"憑證簽署我們的應用程式 - "
"只能在您的電腦上使用的臨時憑證。我們這樣做是為了讓教程簡單。設定程式碼簽署身"
"分有點繁瑣，並且只有在您打算將應用程式分發給其他人時才`需要`它們。如果我們要"
"發布真實的應用程式供其他人使用，我們需要指定真實的憑證。"

#: docs/en/tutorial/tutorial-3.md:425
#, fuzzy
msgid ""
"When you're ready to publish a real application, check out the Briefcase How-"
"To guide on [Setting up a macOS code signing identity]{1}."
msgstr "當您準備好發布實際應用程式時，請查看有關`設定 macOS 代碼簽署身分 "
"[的公文包操作指南]{1}"

#: docs/en/tutorial/tutorial-3.md:433
#, fuzzy
msgid ""
"The output of the package step will be slightly different depending on your "
"Linux distribution. If you're on a Debian-derived distribution, you'll see:"
msgstr "根據您的 Linux 發行版，打包步驟的輸出將略有不同。如果您使用的是 Debian "
"派生的發行版，您將看到："

#: docs/en/tutorial/tutorial-3.md:455
#, fuzzy
msgid "The `dist` folder will contain the `.deb` file that was generated."
msgstr "`dist` 資料夾將包含產生的`.deb` 檔案。"

#: docs/en/tutorial/tutorial-3.md:457
#, fuzzy
msgid "If you're on a RHEL-based distribution, you'll see:"
msgstr "如果您使用的是基於 RHEL 的發行版，您將看到："

#: docs/en/tutorial/tutorial-3.md:484
#, fuzzy
msgid "The `dist` folder will contain the `.rpm` file that was generated."
msgstr "`dist` 資料夾將包含產生的`.rpm` 檔案。"

#: docs/en/tutorial/tutorial-3.md:486
#, fuzzy
msgid "If you're on an Arch-based distribution, you'll see:"
msgstr "如果您使用的是基於 Arch 的發行版，您將看到："

#: docs/en/tutorial/tutorial-3.md:504
#, fuzzy
msgid ""
"The `dist` folder will contain the `.pkg.tar.zst` file that was generated."
msgstr "`dist` 資料夾將包含產生的`.pkg.tar.zst` 檔案。"

#: docs/en/tutorial/tutorial-3.md:507
#, fuzzy
msgid "Other Linux distributions aren't currently supported for packaging."
msgstr "目前不支援打包其他 Linux 發行版。"

#: docs/en/tutorial/tutorial-3.md:509
#, fuzzy
msgid ""
"If you want to build a package for a Linux distribution other than the one "
"you're using, Briefcase can also help - but you'll need to install Docker."
msgstr "如果您想為您正在使用的 Linux 發行版以外的發行版建立軟體包，Briefcase "
"也可以提供協助 - 但您需要安裝 Docker。"

#: docs/en/tutorial/tutorial-3.md:513
#, fuzzy
msgid ""
"Official installers for [Docker Engine]{1} are available for a range of Unix "
"distributions. Follow the instructions for your platform; however, ensure "
"you don't install Docker in \"rootless\" mode."
msgstr ""
"[Docker Engine]{1} 的官方安裝程式可用於一系列 Unix "
"發行版。請遵循適合您平台的說明；但是，請確保不要以`無根`模式安裝 Docker。"

#: docs/en/tutorial/tutorial-3.md:517
#, fuzzy
msgid ""
"Once you've installed Docker, you should be able to start an Linux container "
"- for example:"
msgstr "安裝 Docker 後，您應該能夠啟動 Linux 容器 - 例如："

#: docs/en/tutorial/tutorial-3.md:524
#, fuzzy
msgid ""
"will show you a Unix prompt (something like `root@84444e31cff9:/#`) inside "
"an Ubuntu 22.04 Docker container. Type Ctrl-D to exit Docker and return to "
"your local shell."
msgstr ""
"將在 Ubuntu 22.04 Docker 容器內向您顯示 Unix "
"提示字元（類似`root@844444e31cff9:/#`）。鍵入 Ctrl-D 退出 Docker 並返回本機 "
"shell。"

#: docs/en/tutorial/tutorial-3.md:528
#, fuzzy
msgid ""
"Once you've got Docker installed, you can use Briefcase to build a package "
"for any Linux distribution that Briefcase supports by passing in a Docker "
"image as an argument. For example, to build a DEB package for Ubuntu 22.04 "
"(Jammy), regardless of the operating system you're on, you can run:"
msgstr ""
"安裝 Docker 後，您可以透過傳入 Docker 映像作為參數，使用 Briefcase 為 "
"Briefcase 支援的任何 Linux 發行版建置套件。例如，要為 Ubuntu 22.04 (Jammy) "
"建立 DEB 包，無論您使用什麼作業系統，都可以運行："

#: docs/en/tutorial/tutorial-3.md:538
#, fuzzy
msgid ""
"This will download the Docker image for your selected operating system, "
"create a container that is able to run Briefcase builds, and build the app "
"package inside the image. Once it's completed, the `dist` folder will "
"contain the package for the target Linux distribution."
msgstr ""
"這將為您選擇的作業系統下載 Docker 映像，建立一個能夠運行 Briefcase "
"建置的容器，並在映像內建置應用程式包。完成後，`dist` 資料夾將包含目標 Linux "
"發行版的軟體包。"

#: docs/en/tutorial/tutorial-3.md:575
#, fuzzy
msgid ""
"In this example, we're not signing our app. As a result, when you use the "
"installer, you'll get a system warning that the application comes from an "
"unknown developer. We've done this to keep the tutorial simple. Setting up "
"code signing identities is a little fiddly, and they're only *required* if "
"you're intending to distribute your application to others. If we were "
"publishing a real application for others to use, we would need to specify a "
"real signing identity; when that signed app is installed, the system will "
"notify the user that the application is from the known identity associated "
"with the certificate."
msgstr ""
"在此範例中，我們使用了`--adhoc-sign`選項 - 也就是說，我們使用 *ad hoc* "
"憑證簽署我們的應用程式 - "
"只能在您的電腦上使用的臨時憑證。我們這樣做是為了讓教程簡單。設定程式碼簽署身"
"分有點繁瑣，並且只有在您打算將應用程式分發給其他人時才`需要`它們。如果我們要"
"發布真實的應用程式供其他人使用，我們需要指定真實的憑證。"

#: docs/en/tutorial/tutorial-3.md:585
#, fuzzy
msgid ""
"When you're ready to publish a real application, check out the Briefcase How-"
"To guide on [Setting up a Windows code signing identity]{1}."
msgstr "當您準備好發布實際應用程式時，請查看有關`設定 macOS 代碼簽署身分 "
"[的公文包操作指南]{1}"

#: docs/en/tutorial/tutorial-3.md:589
#, fuzzy
msgid ""
"Once this step completes, the `dist` folder will contain a file named "
"`Hello_World-0.0.1.msi`. If you double click on this installer to run it, "
"you should go through a familiar Windows installation process. Once this "
"installation completes, there will be a \"Hello World\" entry in your start "
"menu."
msgstr ""
"此步驟完成後，`dist`資料夾將包含一個名為 `Hello_World-0.0.1.msi` "
"的檔案。如果您雙擊此安裝程式來運行它，您應該經歷熟悉的 Windows "
"安裝過程。安裝完成後，開始功能表中將出現一個 \"Hello World\" 項目。"

#: docs/en/tutorial/tutorial-3.md:599
msgid ""
"We now have our application packaged for distribution on desktop platforms. "
"But what happens when we need to update the code in our application? How do "
"we get those updates into our packaged application? Turn to [Tutorial 4]{1} "
"to find out..."
msgstr ""

#: docs/en/tutorial/tutorial-4.md:1
#, fuzzy
msgid "Tutorial 4 - Updating your application"
msgstr "教程 4 - 更新您的應用程式"

#: docs/en/tutorial/tutorial-4.md:3
#, fuzzy
msgid ""
"In the last tutorial, we packaged our application as a native application. "
"If you're dealing with a real-world app, that isn't going to be the end of "
"the story - you'll likely do some testing, discover problems, and need to "
"make some changes. Even if your application is perfect, you'll eventually "
"want to publish version 2 of your application with improvements."
msgstr ""
"在上一個教程中，我們將應用程式打包為本機應用程式。如果您正在處理現實世界的應"
"用程序，這不會是故事的結局 - "
"您可能會進行一些測試，發現問題，並需要進行一些更改。即使您的應用程式非常完美"
"，您最終也會希望發布經過改進的應用程式的第 2 版。"

#: docs/en/tutorial/tutorial-4.md:10
#, fuzzy
msgid "So - how do you update your installed app when you make code changes?"
msgstr "那麼 - 當您更改程式碼時如何更新已安裝的應用程式？"

#: docs/en/tutorial/tutorial-4.md:12
#, fuzzy
msgid "Updating application code"
msgstr "更新應用程式程式碼"

#: docs/en/tutorial/tutorial-4.md:14
#, fuzzy
msgid ""
"Our application currently prints to the console when you press the button. "
"However, GUI applications shouldn't really use the console for output. They "
"need to use dialogs to communicate with users."
msgstr "目前，當您按下按鈕時，我們的應用程式會列印到控制台。然而，GUI "
"應用程式不應該真正使用控制台進行輸出。他們需要使用對話框與使用者進行交流。"

#: docs/en/tutorial/tutorial-4.md:18
#, fuzzy
msgid ""
"Let's add a dialog box to say hello, instead of writing to the console. "
"Modify the `say_hello` callback so it looks like this:"
msgstr "讓我們新增一個對話框來打招呼，而不是寫入控制台。修改`say_hello`回調，使其看起"
"來像這樣:"

#: docs/en/tutorial/tutorial-4.md:31
msgid ""
"We need to make the method `async` so that when we display the dialog, the "
"rest of the application continues to run. Don't worry about this detail too "
"much right now - we'll give a more detailed explanation in [Tutorial 8]{1}."
msgstr ""

#: docs/en/tutorial/tutorial-4.md:36
#, fuzzy
msgid ""
"This directs Toga to open a modal dialog box when the button is pressed."
msgstr "這會指示 Toga 在按下按鈕時開啟模式對話方塊。"

#: docs/en/tutorial/tutorial-4.md:38
#, fuzzy
msgid ""
"If you run `briefcase dev`, enter a name, and press the button, you'll see "
"the new dialog box:"
msgstr "如果執行`briefcase dev`，輸入名稱，然後按按鈕，您將看到新的對話方塊："

#: docs/en/tutorial/tutorial-4.md:43
msgid "![Hello World Tutorial 4 dialog, on macOS]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-4.md:53
msgid "![Hello World Tutorial 4 dialog, on Linux]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-4.md:63
msgid "![Hello World Tutorial 4 dialog, on Windows]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-4.md:71
#, fuzzy
msgid "However, if you run `briefcase run`, the dialog box won't appear."
msgstr "但是，如果執行`briefcase run`，則不會出現該對話方塊。"

#: docs/en/tutorial/tutorial-4.md:73
msgid ""
"Why is this? Well, `briefcase dev` operates by running your code in place - "
"it tries to produce as realistic runtime environment for your code as "
"possible, but it doesn't provide or use any of the platform infrastructure "
"for wrapping your code as an application. Part of the process of packaging "
"your app involves copying your code *into* the application bundle - and at "
"the moment, your application still has the old code in it."
msgstr ""

#: docs/en/tutorial/tutorial-4.md:81
#, fuzzy
msgid ""
"So - we need to tell briefcase to update your app, copying in the new "
"version of the code. We *could* do this by deleting the old platform "
"directory and starting from scratch. However, Briefcase provides an easier "
"way - you can update the code for your existing bundled application:"
msgstr ""
"因此 - "
"我們需要告訴公文包更新您的應用程序，複製新版本的代碼。我們*可以*透過刪除舊平"
"台目錄並從頭開始來做到這一點。但是，Briefcase 提供了一種更簡單的方法 - "
"您可以更新現有捆綁應用程式的程式碼："

#: docs/en/tutorial/tutorial-4.md:142
#, fuzzy
msgid ""
"If Briefcase can't find the scaffolded template, it will automatically "
"invoke `create` to generate a fresh scaffold."
msgstr "如果Briefcase找不到鷹架模板，它會自動呼叫`create`來產生一個新的鷹架。"

#: docs/en/tutorial/tutorial-4.md:145
#, fuzzy
msgid ""
"Now that we've updated the installer code, we can then run `briefcase build` "
"to re-compile the app, `briefcase run` to run the updated app, and `"
"briefcase package` to repackage the application for distribution."
msgstr ""
"現在我們已經更新了安裝程式碼，然後我們可以運行`briefcase "
"build`來重新編譯應用程序，運行`briefcase "
"run`來運行更新後的應用程序，以及運行`briefcase "
"package`來重新打包應用程式用於分發。"

#: docs/en/tutorial/tutorial-4.md:152
#, fuzzy
msgid ""
"macOS users, remember that as noted in [Tutorial 3]{1}, for the tutorial we "
"recommend running `briefcase package` with the `--adhoc-sign` flag to avoid "
"the complexity of setting up a code signing identity and keep the tutorial "
"as simple as possible."
msgstr ""
"（macOS 用戶，請記住，如 [教學 3 所述<tutorial-3>`，對於本教程，我們建議使用"
"`--adhoc-sign`標誌運行`briefcase "
"package`，以避免設置代碼簽名身份的複雜性，並使教程盡可能簡單。）"

#: docs/en/tutorial/tutorial-4.md:159
#, fuzzy
msgid "Update and run in one step"
msgstr "一步更新並運行"

#: docs/en/tutorial/tutorial-4.md:161
#, fuzzy
msgid ""
"If you're rapidly iterating code changes, you'll likely want to make a code "
"change, update the application, and immediately re-run your application. For "
"most purposes, developer mode (`briefcase dev`) will be the easiest way to "
"do this sort of rapid iteration; however, if you're testing something about "
"how your application runs as a native binary, or hunting a bug that only "
"manifests when your application is in packaged form, you may need to use "
"repeated calls to `briefcase run`. To simplify the process of updating and "
"running the bundled app, Briefcase has a shortcut to support this usage "
"pattern - the `-u` (or `--update`) option on the `run` command."
msgstr ""
"如果您快速迭代程式碼更改，您可能需要更改程式碼、更新應用程序，然後立即重新執"
"行您的應用程式。對於大多數目的，開發人員模式（`briefcase "
"dev`）將是進行這種快速迭代的最簡單方法；但是，如果您正在測試應用程式如何作為"
"本機二進位檔案運行，或者尋找僅在應用程式處於打包形式時才會出現的錯誤，則可能"
"需要重複調用`briefcase run`。為了簡化更新和執行捆綁應用程式的過程，Briefcase "
"有一個快捷方式來支援這種使用模式 - `run` 命令上的`-u`（或`--update`）選項。"

#: docs/en/tutorial/tutorial-4.md:172
#, fuzzy
msgid ""
"Let's try making another change. You may have noticed that if you don't type "
"a name in the text input box, the dialog will say \"Hello, \". Let's modify "
"the `say_hello` function again to handle this edge case."
msgstr ""
"讓我們嘗試進行另一個更改。您可能已經注意到，如果您不在文字輸入方塊中鍵入姓名"
"，則對話方塊將顯示 \"Hello，\"。讓我們再次修改 `say_hello` "
"函數來處理這種邊緣情況。"

#: docs/en/tutorial/tutorial-4.md:176
#, fuzzy
msgid ""
"At the top of the file, between the imports and the `class HelloWorld` "
"definition, add a utility method to generate an appropriate greeting "
"depending on the value of the name that has been provided:"
msgstr "在檔案頂部的匯入和`class "
"HelloWorld`定義之間，新增實用程式方法以根據已提供的名稱值產生適當的問候語："

#: docs/en/tutorial/tutorial-4.md:188
#, fuzzy
msgid "Then, modify the `say_hello` callback to use this new utility method:"
msgstr "然後，修改`say_hello`回調以使用這個新的實用方法："

#: docs/en/tutorial/tutorial-4.md:200
#, fuzzy
msgid ""
"Run your app in development mode (with `briefcase dev`) to confirm that the "
"new logic works; then update, build and run the app with one command:"
msgstr "在開發模式下運行您的應用程式（使用`briefcase "
"dev`）以確認新邏輯有效；然後使用一個命令更新、建置和運行應用程式："

#: docs/en/tutorial/tutorial-4.md:274
#, fuzzy
msgid ""
"The package command also accepts the `-u` argument, so if you make a change "
"to your application code and want to repackage immediately, you can run `"
"briefcase package -u`."
msgstr ""
"package "
"命令也接受`-u`參數，因此如果您對應用程式程式碼進行了更改並希望立即重新打包，"
"則可以運行`briefcase package -u`。"

#: docs/en/tutorial/tutorial-4.md:280
#, fuzzy
msgid ""
"We now have our application packaged for distribution on desktop platforms, "
"and we've been able to update the code in our application."
msgstr "現在，我們已經將應用程式打包以便在桌面平台上分發，並且我們已經能夠更新應用程"
"式中的程式碼。"

#: docs/en/tutorial/tutorial-4.md:283
msgid ""
"But what about mobile? In [Tutorial 5]{1}, we'll convert our application "
"into a mobile application, and deploy it onto a device simulator, and onto a "
"phone."
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it mobile: Android"
msgstr "教學 5 - 行動裝置：Android"

#: docs/en/tutorial/tutorial-5/android.md:3
#, fuzzy
msgid ""
"Now, we're going to take our application, and deploy it as an Android "
"application."
msgstr "現在，我們將獲取我們的應用程序，並將其部署為 Android 應用程式。"

#: docs/en/tutorial/tutorial-5/android.md:6
#, fuzzy
msgid ""
"The process of deploying an application to Android is very similar to the "
"process for deploying as a desktop application. Briefcase handles installing "
"dependencies for Android, including the Android SDK, the Android emulator, "
"and a Java compiler."
msgstr ""
"將應用程式部署到 Android 的過程與部署為桌面應用程式的過程非常相似。 "
"Briefcase 負責安裝 Android 依賴項，包括 Android SDK、Android 模擬器和 Java "
"編譯器。"

#: docs/en/tutorial/tutorial-5/android.md:11
#, fuzzy
msgid "Create an Android app and compile it"
msgstr "創建一個 Android 應用程式並編譯它"

#: docs/en/tutorial/tutorial-5/android.md:13
#, fuzzy
msgid ""
"First, run the `create` command. This downloads an Android app template and "
"adds your Python code to it."
msgstr "首先，執行`create`命令。這將下載 Android 應用程式模板並向其中添加您的 Python "
"程式碼。"

#: docs/en/tutorial/tutorial-5/android.md:104
#, fuzzy
msgid ""
"When you run `briefcase create android` for the first time, Briefcase "
"downloads a Java JDK, and the Android SDK. File sizes and download times can "
"be considerable; this may take a while (10 minutes or longer, depending on "
"the speed of your Internet connection). When the download has completed, you "
"will be prompted to accept Google's Android SDK license. There's a number of "
"licenses you'll need to agree too - keep entering `y` at the prompt to "
"review and accept each of the necessary the license agreements."
msgstr ""
"當您第一次執行`briefcase create android`時，Briefcase 會下載 Java JDK 和 "
"Android SDK。文件大小和下載時間可能相當大；這可能需要一段時間（10 "
"分鐘或更長時間，具體取決於您的 Internet 連線速度）。下載完成後，"
"系統會提示您接受 Google 的 Android SDK 授權。"

#: docs/en/tutorial/tutorial-5/android.md:113
#, fuzzy
msgid ""
"Once this completes, we'll have a `build\\helloworld\\android\\gradle` "
"directory in our project, which will contain an Android project with a "
"Gradle build configuration. This project will contain your application code, "
"and a support package containing the Python interpreter."
msgstr ""
"完成後，我們的專案中將有一個 `build\\helloworld\\android\\gradle` 目錄，"
"其中包含具有 Gradle 建置配置的 Android 專案。"
"該專案將包含您的應用程式程式碼以及包含 Python 解釋器的支援套件。"

#: docs/en/tutorial/tutorial-5/android.md:118
#, fuzzy
msgid ""
"We can then use Briefcase's `build` command to compile this into an Android "
"APK app file."
msgstr "然後我們可以使用 Briefcase 的 `build` 命令將其編譯成 Android APK "
"應用程式檔案。"

#: docs/en/tutorial/tutorial-5/android.md:182
msgid "/// admonition | Gradle may look stuck"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:184
#, fuzzy
msgid ""
"During the `briefcase build android` step, Gradle (the Android platform "
"build tool) will print `CONFIGURING: 100%`, and appear to be doing nothing. "
"Don't worry, it's not stuck - it's downloading more Android SDK components. "
"Depending on your Internet connection speed, this may take another 10 "
"minutes (or longer). This lag should only happen the very first time you run "
"`build`; the tools are cached, and on your next build, the cached versions "
"will be used."
msgstr ""
"在`briefcase build android`步驟中，Gradle（Android "
"平台建置工具）將列印`CONFIGURING: 100%`，似乎什麼也沒做。別擔心，"
"它並沒有卡住 - 它正在下載更多 Android SDK 組件。根據您的網路連線速度，"
"這可能還需要 10 "
"分鐘（或更長）。這種滯後應該只在你第一次執行`build`時發生；這些工具會被緩存，"
"並且在您的下一個建置中，將使用快取的版本。"

#: docs/en/tutorial/tutorial-5/android.md:194
#, fuzzy
msgid "Run the app on a virtual device"
msgstr "在虛擬設備上運行應用程式"

#: docs/en/tutorial/tutorial-5/android.md:196
#, fuzzy
msgid ""
"We're now ready to run our application. You can use Briefcase's `run` "
"command to run the app on an Android device. Let's start by running on an "
"Android emulator."
msgstr ""
"現在我們已經準備好運行我們的應用程式了。您可以使用 Briefcase 的`run`命令在 "
"Android 裝置上執行該應用程式。讓我們從在 Android 模擬器上運行開始。"

#: docs/en/tutorial/tutorial-5/android.md:200
#, fuzzy
msgid ""
"To run your application, run `briefcase run android`. When you do this, "
"you'll be prompted with a list of devices that you could run the app on. The "
"last item will always be an option to create a new Android emulator."
msgstr ""
"要運行您的應用程序，請運行`briefcase run "
"android`。當您執行此操作時，系統會提示您提供可以執行該應用程式的裝置清單。"
"最後一項始終是建立新 Android 模擬器的選項。"

#: docs/en/tutorial/tutorial-5/android.md:246
#, fuzzy
msgid ""
"We can now choose our desired device. Select the "
"\"Create a new Android emulator\" option, and accept the default choice for "
"the device name (`beePhone`)."
msgstr "我們現在可以選擇我們想要的設備。選擇`建立新的 Android 模擬器`選項，"
"並接受裝置名稱的預設選擇 (`beePhone`)。"

#: docs/en/tutorial/tutorial-5/android.md:250
#, fuzzy
msgid ""
"Briefcase `run` will automatically boot the virtual device. When the device "
"is booting, you will see the Android logo:"
msgstr "公事包`run`將自動啟動虛擬設備。當裝置啟動時，您將看到 Android 標誌："

#: docs/en/tutorial/tutorial-5/android.md:253
msgid "![Android virtual device booting]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:257
msgid "Android virtual device booting"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:261
#, fuzzy
msgid ""
"Once the device has finished booting, Briefcase will install your app on the "
"device. You will briefly see a launcher screen:"
msgstr "裝置完成啟動後，Briefcase "
"將在裝置上安裝您的應用程式。您將短暫地看到一個啟動器畫面："

#: docs/en/tutorial/tutorial-5/android.md:264
msgid "![Android virtual device fully started, on the launcher screen]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:268
msgid "Android virtual device fully started, on the launcher screen"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:272
#, fuzzy
msgid ""
"The app will then start. You'll see a splash screen while the app starts up:"
msgstr "然後該應用程式將啟動。應用程式啟動時您將看到啟動畫面："

#: docs/en/tutorial/tutorial-5/android.md:275
msgid "![App splash screen]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:279
msgid "App splash screen"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:283
msgid "/// admonition | The emulator didn't start!"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:285
#, fuzzy
msgid ""
"The Android emulator is a complex piece of software that relies on a number "
"of hardware and operating system features - features that may not be "
"available or enabled on older machines. If you experience any difficulties "
"starting the Android emulator, consult the [Requirements and recommendations]"
"{1} section of the Android developer documentation."
msgstr ""
"Android 模擬器是一款複雜的軟體，依賴許多硬體和作業系統功能 - "
"這些功能在舊機器上可能無法使用或啟用。如果您在啟動 Android "
"模擬器時遇到任何困難，請參閱 Android 開發人員文件的 [要求與建議]{1} 部分。"

#: docs/en/tutorial/tutorial-5/android.md:295
#, fuzzy
msgid ""
"The first time the app starts, it needs to unpack itself onto the device. "
"This may take a few seconds. Once it's unpacked, you'll see the Android "
"version of our desktop app:"
msgstr "應用程式第一次啟動時，需要將自身解壓縮到裝置上。這可能需要幾秒鐘。解壓縮後，"
"您將看到我們桌面應用程式的 Android 版本："

#: docs/en/tutorial/tutorial-5/android.md:299
msgid "![Demo app fully launched]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:303
msgid "Demo app fully launched"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:307
#, fuzzy
msgid ""
"If you fail to see your app launching, you may need to check your terminal "
"where you ran `briefcase run` and look for any error messages."
msgstr "如果您無法看到應用程式啟動，您可能需要檢查執行`briefcase "
"run`的終端並查找任何錯誤訊息。"

#: docs/en/tutorial/tutorial-5/android.md:310
msgid ""
"While the app is running, you'll see a lot of messages being streamed in the "
"console. This is a stream of the application's logs from the emulator. "
"Typing Ctrl+C into the terminal will halt the streamed information in the "
"console, but it will not close the emulator. This is so you can test new "
"changes without restarting the emulator."
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:316
#, fuzzy
msgid ""
"In future, if you want to run on this device without using the menu, you can "
"provide the emulator's name to Briefcase, using `briefcase run android -d "
"\"@beePhone\"` to run on the virtual device directly."
msgstr ""
"將來，如果您想在該裝置上運行而不使用選單，您可以將模擬器的名稱提供給Briefcase"
"，使用`briefcase run android -d @beePhone`直接在虛擬裝置上執行。"

#: docs/en/tutorial/tutorial-5/android.md:321
#, fuzzy
msgid "Run the app on a physical device"
msgstr "在物理設備上運行應用程式"

#: docs/en/tutorial/tutorial-5/android.md:323
#, fuzzy
msgid ""
"If you have a physical Android phone or tablet, you can connect it to your "
"computer with a USB cable, and then use the Briefcase to target your "
"physical device."
msgstr "如果您有實體 Android 手機或平板電腦，則可以使用 USB "
"電纜將其連接到計算機，然後使用公文包定位您的實體設備。"

#: docs/en/tutorial/tutorial-5/android.md:327
#, fuzzy
msgid ""
"Android requires that you prepare your device before it can be used for "
"development. You will need to make 2 changes to the options on your device:"
msgstr "Android 要求您先準備好設備，然後才能用於開發。您需要對裝置上的選項進行 2 "
"項變更："

#: docs/en/tutorial/tutorial-5/android.md:331
#, fuzzy
msgid "Enable developer options"
msgstr "啟用開發者選項"

#: docs/en/tutorial/tutorial-5/android.md:332
#, fuzzy
msgid "Enable USB debugging"
msgstr "啟用USB調試"

#: docs/en/tutorial/tutorial-5/android.md:334
#, fuzzy
msgid ""
"Details on how to make these changes can be found "
"[in the Android developer documentation]{1}."
msgstr "有關如何進行這些更改的詳細信息，請參閱 [Android 開發人員文件]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:337
#, fuzzy
msgid ""
"Once these steps have been completed, your device should appear in the list "
"of available devices when you run `briefcase run android`."
msgstr "完成這些步驟後，當您執行`briefcase run "
"android`時，您的裝置應該會出現在可用裝置清單中。"

#: docs/en/tutorial/tutorial-5/android.md:388
#, fuzzy
msgid ""
"Here we can see a new physical device with it's serial number on the "
"deployment list - in this case, a Pixel 3a. In the future, if you want to "
"run on this device without using the menu, you can provide the phone's "
"serial number to Briefcase (in this case, `briefcase run android -d "
"94ZZY0LNE8`). This will run on the device directly, without prompting."
msgstr ""
"在這裡，我們可以在部署清單中看到一個新的實體設備及其序號 - 在本例中為 Pixel "
"3a。將來，如果您想在該裝置上運行而不使用選單，您可以向Briefcase提供手機的序號"
"（在本例中為`briefcase run android -d "
"94ZZY0LNE8`）。這將直接在設備上運行，無需提示。"

#: docs/en/tutorial/tutorial-5/android.md:395
msgid "/// admonition | My device doesn't appear!"
msgstr ""

#: docs/en/tutorial/tutorial-5/android.md:397
#, fuzzy
msgid ""
"If your device doesn't appear on this list at all, either you haven't "
"enabled USB debugging, (or the device isn't plugged in!)."
msgstr "如果您的裝置完全沒有出現在此清單中，則可能是您尚未啟用 USB "
"偵錯（或裝置未插入！）。"

#: docs/en/tutorial/tutorial-5/android.md:400
#, fuzzy
msgid ""
"If your device appears, but is listed as "
"\"Unknown device (not authorized for development)\", developer mode hasn't "
"been correctly enabled. Re-run [the steps to enable developer options]{1}, "
"and re-run `briefcase run android`."
msgstr ""
"如果您的裝置出現，但被列為`未知裝置（未授權開發）`，則表示開發者模式尚未正確"
"啟用。重新執行 [啟用開發人員選項的步驟]{1}，並重新執行`briefcase run "
"android``。"

#: docs/en/tutorial/tutorial-5/android.md:410
#: docs/en/tutorial/tutorial-5/iOS.md:156
msgid ""
"We've now got an application on our phone! Is there anywhere else we can "
"deploy a BeeWare app? Turn to [Tutorial 6]{1} to find out..."
msgstr ""

#: docs/en/tutorial/tutorial-5/iOS.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it mobile: iOS"
msgstr "教學 5 - 行動裝置：iOS"

#: docs/en/tutorial/tutorial-5/iOS.md:3
msgid ""
"To compile iOS applications we'll need Xcode, which is available for free "
"from [the macOS App Store]{1}. Once Xcode is installed, launch it from "
"Applications and accept the Xcode License Agreement. Next, Xcode will show "
"which components are built-in, and which components you may download. Select "
"the checkbox next to iOS (followed by the current version number), and then "
"click \"Download and Install\" to install it. Xcode will install the system "
"components, followed by the iOS Simulator."
msgstr ""

#: docs/en/tutorial/tutorial-5/iOS.md:13
#, fuzzy
msgid ""
"Once we've got Xcode and the iOS simulator installed, we can take our "
"application and deploy it as an iOS app."
msgstr "一旦我們安裝了 Xcode，我們就可以將我們的應用程式部署為 iOS 應用程式。"

#: docs/en/tutorial/tutorial-5/iOS.md:16
msgid ""
"The process of deploying an application to iOS is very similar to the "
"process for deploying as a desktop application. First, you run the `create` "
"command - but this time, we specify that we want to create an iOS "
"application:"
msgstr ""

#: docs/en/tutorial/tutorial-5/iOS.md:46
#, fuzzy
msgid ""
"Once this completes, we'll have a `build/helloworld/ios/xcode` directory "
"containing an Xcode project, as well as the support libraries and the "
"application code needed for the application."
msgstr ""
"完成後，我們將擁有一個`build/helloworld/ios/xcode`目錄，其中包含 Xcode "
"專案以及應用程式所需的支援庫和應用程式程式碼。"

#: docs/en/tutorial/tutorial-5/iOS.md:50
#, fuzzy
msgid ""
"You can then use Briefcase to compile your app using `briefcase build iOS`:"
msgstr "然後，您可以使用`briefcase build iOS`來使用 Briefcase 來編譯您的應用程式："

#: docs/en/tutorial/tutorial-5/iOS.md:66
#, fuzzy
msgid ""
"We're now ready to run our application, using `briefcase run iOS`. You'll be "
"prompted to select a device to compile for; if you've got simulators for "
"multiple iOS SDK versions installed, you may also be asked which iOS version "
"you want to target. The options you are shown may differ from the options "
"show in this output - at the very least, the list of devices will likely be "
"different. For our purposes, it doesn't matter which simulator you pick."
msgstr ""
"現在我們已經準備好使用`briefcase run "
"iOS`來運行我們的應用程式。系統會提示您選擇要編譯的設備；如果您安裝了多個 iOS "
"SDK 版本的模擬器，系統也可能會詢問您要定位哪個 iOS 版本。"
"您顯示的選項可能與此輸出中顯示的選項不同 - "
"至少，設備清單可能會有所不同。就我們的目的而言，您選擇哪個模擬器並不重要。"

#: docs/en/tutorial/tutorial-5/iOS.md:116
#, fuzzy
msgid ""
"This will start the iOS simulator, install your app, and start it. You "
"should see the simulator start, and eventually open your iOS application:"
msgstr "這將啟動 iOS 模擬器、安裝您的應用程式並啟動它。您應該會看到模擬器啟動，"
"並最終打開您的 iOS 應用程式："

#: docs/en/tutorial/tutorial-5/iOS.md:120
msgid "![Hello World Tutorial 5 window, on iOS]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-5/iOS.md:126
msgid ""
"While the app is running, you'll see a series of Simulator log output "
"messages in the console. Typing Ctrl+C into the terminal will halt the "
"messages in the console, but it will not close the simulator. This is so you "
"can test new changes without restarting the simulator."
msgstr ""

#: docs/en/tutorial/tutorial-5/iOS.md:131
#, fuzzy
msgid ""
"If you know ahead of time which iOS simulator you want to target, you can "
"tell Briefcase to use that simulator by providing a `-d` (or `--device`) "
"option. Using the name of the device you selected when you built your "
"application, run:"
msgstr ""
"如果您事先知道要定位哪個 iOS 模擬器，則可以透過提供`-d`（或`--device`）"
"選項來告訴 Briefcase "
"使用該模擬器。使用您在建立應用程式時選擇的設備名稱，運行："

#: docs/en/tutorial/tutorial-5/iOS.md:140
#, fuzzy
msgid ""
"If you have multiple iOS versions available, Briefcase will pick the highest "
"iOS version; if you want to pick a particular iOS version, you tell it to "
"use that specific version:"
msgstr "如果您有多個可用的 iOS 版本，公事包將選擇最高的 iOS 版本；"
"如果你想選擇一個特定的 iOS 版本，你可以告訴它使用該特定版本："

#: docs/en/tutorial/tutorial-5/iOS.md:148
#, fuzzy
msgid "Or, you can name a specific device UDID:"
msgstr "或者，您可以命名特定設備 UDID："

#: docs/en/tutorial/tutorial-5/index.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it Mobile"
msgstr "教程 5 - 移動使用"

#: docs/en/tutorial/tutorial-5/index.md:3
#, fuzzy
msgid ""
"So far, we've been running and testing our application on the desktop. "
"However, BeeWare also supports mobile platforms - and the application we've "
"written can be deployed to your mobile device, too!"
msgstr "到目前為止，我們已經在桌面上運行和測試我們的應用程式。但是，BeeWare "
"還支援行動平台 - 我們編寫的應用程式也可以部署到您的行動裝置！"

#: docs/en/tutorial/tutorial-5/index.md:7
msgid "[Android]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-5/index.md:9
#, fuzzy
msgid "Android applications can be compiled on macOS, Windows or Linux."
msgstr "Android 應用程式可以在 macOS、Windows 或 Linux 上編譯。"

#: docs/en/tutorial/tutorial-5/index.md:11
msgid "[iOS]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-5/index.md:13
#, fuzzy
msgid "iOS applications can only be compiled on macOS."
msgstr "iOS 應用程式只能在 macOS 上編譯。"

#: docs/en/tutorial/tutorial-6.md:1
#, fuzzy
msgid "Tutorial 6 - Put it on the web!"
msgstr "教程 6 - 將其放在網路上！"

#: docs/en/tutorial/tutorial-6.md:3
msgid ""
"In addition to supporting mobile platforms, the Toga widget toolkit also "
"supports the web! Using the same API that you used to deploy your desktop "
"and mobile applications, you can deploy your application as a single-page "
"web app."
msgstr "除了支援行動平台外，Toga 還支援網頁！使用與部署桌面和行動應用程式相同的 API，"
"您可以將應用程式部署為單頁 Web 應用程式。"

#: docs/en/tutorial/tutorial-6.md:8
msgid "/// admonition | Proof of Concept"
msgstr ""

#: docs/en/tutorial/tutorial-6.md:10
msgid ""
"The Toga Web backend is the least mature of all the Toga backends. It's "
"mature enough to show off a few features, but it's likely to be buggy, and "
"will be missing many of the widgets that are available on other platforms. "
"At this point in time, Web deployment should be considered a "
"\"Proof of Concept\" - enough to demonstrate what can be done, but not "
"enough to be relied on for serious development."
msgstr ""
"Toga Web 後端是所有 Toga "
"後端中最不成熟的。它已經足夠成熟，可以展示一些功能，但它可能有缺陷，並且會缺"
"少其他平台上可用的許多小部件。此時，Web 部署應被視為 `概念驗證` - "
"足以演示可以做什麼，但不足以依賴認真的開發。"

#: docs/en/tutorial/tutorial-6.md:17
msgid ""
"If you have problems with this step of the tutorial, you can skip to the "
"next page."
msgstr "如果您對本教學的這一步有疑問，可以跳到下一頁。"

#: docs/en/tutorial/tutorial-6.md:22
msgid "Deploying as a web app"
msgstr "部署為 Web 應用程式"

#: docs/en/tutorial/tutorial-6.md:24
msgid ""
"The process of deploying as a single-page web app follows the same familiar "
"pattern - you create the application, then build the application, then run "
"it. However, Briefcase can be a little bit smart; if you attempt to run an "
"application, and Briefcase determines that it hasn't been created or built "
"for the platform being targeted, it will do the create and build steps for "
"you. Since this is our first time running the app for the web, we can "
"perform all three steps with one command:"
msgstr ""
"部署為單頁 Web 應用程式的過程遵循相同的熟悉模式 - "
"建立應用程序，然後建立應用程序，然後運行它。然而，Briefcase "
"有點聰明，如果您嘗試運行應用程序，並且 Briefcase "
"確定該應用程式尚未針對目標平台創建或構建，它將為您執行創建和構建步驟。由於這"
"是我們第一次運行該應用程式的網絡，我們可以使用一個命令執行所有三個步驟："

#: docs/en/tutorial/tutorial-6.md:152
msgid "This will open a web browser, pointing at {1}:"
msgstr ""

#: docs/en/tutorial/tutorial-6.md:154
msgid "![Hello World Tutorial 6 dialog, in a browser]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-6.md:156
msgid "If you enter your name and click the button, a dialog will appear."
msgstr "如果您輸入您的姓名並按一下該按鈕，將會出現一個對話方塊。"

#: docs/en/tutorial/tutorial-6.md:158
msgid "How does this work?"
msgstr "這個怎麼用？"

#: docs/en/tutorial/tutorial-6.md:160
msgid ""
"This web app is a static website - a single HTML source page, with some CSS "
"and other resources. Briefcase has started a local web server to serve this "
"page so your browser can view the page. If you wanted to put this web page "
"into production, you could copy the contents of the `www` folder onto any "
"web server that can serve static content."
msgstr ""
"此 Web 應用程式是一個靜態網站 - 單一 HTML 來源頁面，帶有一些 CSS 和其他資源。"
" Briefcase 已啟動本機 Web "
"伺服器來提供此頁面，以便您的瀏覽器可以查看該頁面。如果您想將此網頁投入生產，"
"您可以將 `www` 資料夾的內容複製到任何可以提供靜態內容的 Web 伺服器上。"

#: docs/en/tutorial/tutorial-6.md:166
msgid ""
"But when you press the button, you're running Python code... how does that "
"work? Toga uses [PyScript]{1} to provide a Python interpreter in the "
"browser. Briefcase packages your app's code as wheels that PyScript can load "
"in the browser. When the page is loaded, the application code runs in the "
"browser, building the UI using the browser DOM. When you click a button, "
"that button runs the event handling code in the browser."
msgstr ""

#: docs/en/tutorial/tutorial-6.md:176
#, fuzzy
msgid ""
"Although we've now deployed this app on desktop, mobile and the web, the app "
"is fairly simple, and doesn't involve any third-party libraries. Can we "
"include libraries from the Python Package Index (PyPI) in our app? Turn to "
"[Tutorial 7]{1} to find out..."
msgstr ""
"雖然我們現在已經在桌面、行動和網路上部署了這個應用程序，但該應用程式相當簡單"
"，並且不涉及任何第三方程式庫。我們可以在我們的應用程式中包含 Python 套件索引 "
"(PyPI) 中的函式庫嗎？前往 :doc:`教學 7<tutorial-7>` 找出..."

#: docs/en/tutorial/tutorial-7.md:1
#, fuzzy
msgid "Tutorial 7 - Get this (third-)party started"
msgstr "教學 7 - 啟動此（第三方）"

#: docs/en/tutorial/tutorial-7.md:3
#, fuzzy
msgid ""
"So far, the app we've built has only used our own code, plus the code "
"provided by BeeWare. However, in a real-world app, you'll likely want to use "
"a third-party library, downloaded from the Python Package Index (PyPI)."
msgstr ""
"到目前為止，我們建立的應用程式只使用了我們自己的程式碼，加上 BeeWare "
"提供的程式碼。但是，在現實應用程式中，您可能需要使用從 Python Package Index "
"(PyPI) 下載的第三方程式庫。"

#: docs/en/tutorial/tutorial-7.md:8
#, fuzzy
msgid "Let's modify our app to include a third-party library."
msgstr "讓我們修改我們的應用程式以包含第三方程式庫。"

#: docs/en/tutorial/tutorial-7.md:10
msgid "Adding a package"
msgstr ""

#: docs/en/tutorial/tutorial-7.md:12
msgid ""
"Let's modify our application to say a little bit more than just "
"\"Hi, there!\"."
msgstr ""

#: docs/en/tutorial/tutorial-7.md:15
msgid ""
"To generate some more interesting text for the dialog, we're going to use a "
"library called [Faker]{1}. Faker is a Python package that generates fake "
"content, including names and text blocks. The names and words in the text "
"block are generated from an arbitrary list of words provided by Faker. We're "
"going to use Faker to construct a fake message, as if someone is responding "
"to the user."
msgstr ""

#: docs/en/tutorial/tutorial-7.md:23
#, fuzzy
msgid ""
"We start by adding `faker` to our app. Add an import to the top of the "
"`app.py` to import `faker`:"
msgstr "讓我們為我們的應用程式新增一個`httpx` API "
"呼叫。將導入新增至`app.py`頂部以導入`httpx`:"

#: docs/en/tutorial/tutorial-7.md:30
#: docs/en/tutorial/tutorial-8.md:65
#, fuzzy
msgid "Then modify the `say_hello()` callback so it looks like this:"
msgstr "要使我們的教程異步，請修改 `say_hello()` 事件處理程序，使其如下所示："

#: docs/en/tutorial/tutorial-7.md:43
#, fuzzy
msgid ""
"Let's run our updated app in Briefcase developer mode to check that our "
"change has worked."
msgstr "讓我們在公文包開發者模式下運行更新後的應用程序，以檢查我們的更改是否有效。"

#: docs/en/tutorial/tutorial-7.md:114
#: docs/en/tutorial/tutorial-7.md:186
#: docs/en/tutorial/tutorial-8.md:164
msgid ""
"You can't run an Android app in developer mode - use the instructions for "
"your chosen desktop platform."
msgstr ""

#: docs/en/tutorial/tutorial-7.md:121
#: docs/en/tutorial/tutorial-7.md:193
#: docs/en/tutorial/tutorial-8.md:171
msgid ""
"You can't run an iOS app in developer mode - use the instructions for your "
"chosen desktop platform."
msgstr ""

#: docs/en/tutorial/tutorial-7.md:126
#, fuzzy
msgid ""
"What happened? We've added `faker` to our *code*, but we haven't added it to "
"our development virtual environment. We can fix this by installing `faker` "
"with `pip`, and then re-running `briefcase dev`:"
msgstr ""
"發生了什麼事？我們已將`httpx`新增至我們的*程式碼*中，但我們尚未將其新增至我們"
"的開發虛擬環境。我們可以透過用`pip`安裝`httpx`來解決這個問題，然後重新執行`"
"briefcase dev`："

#: docs/en/tutorial/tutorial-7.md:137
#: docs/en/tutorial/tutorial-7.md:155
#: docs/en/tutorial/tutorial-7.md:173
#: docs/en/tutorial/tutorial-8.md:107
#: docs/en/tutorial/tutorial-8.md:129
#: docs/en/tutorial/tutorial-8.md:151
#, fuzzy
msgid ""
"When you enter a name and press the button, you should see a dialog that "
"looks something like:"
msgstr "當您輸入名稱並按下按鈕時，您應該會看到一個類似以下內容的對話框："

#: docs/en/tutorial/tutorial-7.md:140
msgid "![Hello World Tutorial 7 dialog, on macOS]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-7.md:158
msgid "![Hello World Tutorial 7 dialog, on Linux]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-7.md:176
msgid "![Hello World Tutorial 7 dialog, on Windows]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-7.md:198
#, fuzzy
msgid ""
"We've now got a working app, using a third party library, running in "
"development mode!"
msgstr "我們現在有了一個可以使用的應用程序，使用第三方庫，在開發模式下運行！"

#: docs/en/tutorial/tutorial-7.md:201
#, fuzzy
msgid "Running the updated app"
msgstr "運行更新的應用程式"

#: docs/en/tutorial/tutorial-7.md:203
#, fuzzy
msgid ""
"Let's get this updated application code packaged as a standalone app. Since "
"we've made code changes, we need to follow the same steps as in [Tutorial 4]"
"{1}:"
msgstr "讓我們將此更新的應用程式程式碼打包為獨立應用程式。由於我們已經更改了程式碼，"
"因此我們需要遵循 [教程 4]{1} 中的相同步驟："

#: docs/en/tutorial/tutorial-7.md:209
#: docs/en/tutorial/tutorial-7.md:251
#: docs/en/tutorial/tutorial-7.md:306
#: docs/en/tutorial/tutorial-7.md:348
#: docs/en/tutorial/tutorial-7.md:423
#, fuzzy
msgid "Update the code in the packaged app:"
msgstr "更新打包應用程式中的程式碼："

#: docs/en/tutorial/tutorial-7.md:220
#: docs/en/tutorial/tutorial-7.md:262
#: docs/en/tutorial/tutorial-7.md:317
#: docs/en/tutorial/tutorial-7.md:359
#: docs/en/tutorial/tutorial-7.md:434
#, fuzzy
msgid "Rebuild the app:"
msgstr "重建應用程式："

#: docs/en/tutorial/tutorial-7.md:229
#: docs/en/tutorial/tutorial-7.md:276
#: docs/en/tutorial/tutorial-7.md:326
#, fuzzy
msgid "And finally, run the app:"
msgstr "最後，運行應用程式："

#: docs/en/tutorial/tutorial-7.md:238
#: docs/en/tutorial/tutorial-7.md:335
#, fuzzy
msgid ""
"However, when the app runs, you'll see an error in the console, plus a crash "
"dialog:"
msgstr "但是，當應用程式運行時，您會在控制台中看到錯誤，以及崩潰對話框："

#: docs/en/tutorial/tutorial-7.md:241
msgid "![Hello World Tutorial 7 app crash, on macOS]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-7.md:285
#: docs/en/tutorial/tutorial-7.md:378
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console:"
msgstr "但是，當應用程式運行時，您會在控制台中看到錯誤："

#: docs/en/tutorial/tutorial-7.md:338
msgid "![Hello World Tutorial 7 app crash, on Windows]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-7.md:369
#: docs/en/tutorial/tutorial-7.md:444
msgid "And finally, run the app (selecting a simulator when prompted):"
msgstr ""

#: docs/en/tutorial/tutorial-7.md:454
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console"
msgstr "但是，當應用程式運行時，您會在控制台中看到錯誤："

#: docs/en/tutorial/tutorial-7.md:469
msgid ""
"Once again, the app has failed to start because `faker` has not been "
"installed - but why? Haven't we already installed `faker`?"
msgstr ""

#: docs/en/tutorial/tutorial-7.md:472
#, fuzzy
msgid ""
"We have - but only in the development environment. Your development "
"environment is entirely local to your machine - and is only enabled when you "
"explicitly activate it. Although Briefcase has a development mode, the main "
"reason you'd use Briefcase is to package up your code so you can give it to "
"someone else."
msgstr ""
"我們有 - 但僅限於開發環境。您的開發環境完全位於您的電腦本機 - "
"並且僅在您明確啟動它時才啟用。儘管Briefcase 有開發模式，但您使用Briefcase "
"的主要原因是打包您的程式碼，以便提供給其他人。"

#: docs/en/tutorial/tutorial-7.md:478
#, fuzzy
msgid ""
"The only way to guarantee that someone else will have a Python environment "
"that contains everything it needs is to build a completely isolated Python "
"environment. This means there's a completely isolated Python install, and a "
"completely isolated set of dependencies. This is what Briefcase is building "
"when you run `briefcase build` - an isolated Python environment. This also "
"explains why `faker` isn't installed - it has been installed in your "
"*development* environment, but not in the packaged app."
msgstr ""
"確保其他人擁有一個包含其所需一切的Python環境的唯一方法是建立一個完全隔離的Pyt"
"hon環境。這意味著有一個完全隔離的 Python "
"安裝和一組完全隔離的依賴項。這就是當您執行`briefcase build`時，Briefcase "
"正在建置的內容—一個獨立的 Python 環境。這也解釋了為什麼未安裝`httpx` - "
"它已安裝在您的*開發*環境中，但未安裝在打包的應用程式中。"

#: docs/en/tutorial/tutorial-7.md:487
#, fuzzy
msgid "So - we need to tell Briefcase that our app has an external dependency."
msgstr "因此 - 我們需要告訴 Briefcase 我們的應用程式具有外部相依性。"

#: docs/en/tutorial/tutorial-7.md:489
#, fuzzy
msgid "Updating dependencies"
msgstr "更新依賴項"

#: docs/en/tutorial/tutorial-7.md:491
#, fuzzy
msgid ""
"In the root directory of your app, there is a file named `pyproject.toml`. "
"This file contains all the app configuration details that you provided when "
"you originally ran `briefcase new`."
msgstr ""
"在應用程式的根目錄中，有一個名為`pyproject.toml`的檔案。該檔案包含您最初執行`"
"briefcase new`時提供的所有應用程式設定詳細資訊。"

#: docs/en/tutorial/tutorial-7.md:495
#, fuzzy
msgid ""
"`pyproject.toml` is broken up into sections; one of the sections describes "
"the settings for your app:"
msgstr "`pyproject.toml` 被分成幾個部分；其中一節描述了您的應用程式的設定：："

#: docs/en/tutorial/tutorial-7.md:508
#, fuzzy
msgid ""
"The `requires` option describes the dependencies of our application. It is a "
"list of strings, specifying libraries (and, optionally, versions) of "
"libraries that you want to be included with your app."
msgstr "`requires` "
"選項描述了我們應用程式的依賴關係。它是一個字串列表，指定您想要包含在應用程式"
"中的庫（以及可選的版本）。"

#: docs/en/tutorial/tutorial-7.md:512
#, fuzzy
msgid "Modify the `requires` setting so that it reads:"
msgstr "修改`requires`設置，使其顯示為："

#: docs/en/tutorial/tutorial-7.md:520
#, fuzzy
msgid ""
"By adding this setting, we're telling Briefcase \"when you build my app, run "
"`pip install faker` into the application bundle\". Anything that would be "
"legal input to `pip install` can be used here - so, you could specify:"
msgstr ""
"透過添加此設置，我們告訴 "
"Briefcase`當您建立我的應用程式時，在應用程式包中執行`pip install "
"httpx``。任何可以作為`pip install`合法輸入的內容都可以在這裡使用 - "
"因此，您可以指定："

#: docs/en/tutorial/tutorial-7.md:525
#, fuzzy
msgid "A specific library version (e.g., `\"faker==37.3.0\"`);"
msgstr "特定的庫版本（例如`httpx==0.19.0`）；"

#: docs/en/tutorial/tutorial-7.md:526
#, fuzzy
msgid "A range of library versions (e.g., `\"faker>=37\"`);"
msgstr "一系列庫版本（例如`httpx>=0.19`）；"

#: docs/en/tutorial/tutorial-7.md:527
#, fuzzy
msgid ""
"A path to a git repository (e.g., `\"git+https://github.com/joke2k/faker/\""
"`); or"
msgstr "git 儲存庫的路徑（例如，`\"git+https://github.com/encode/httpx\"`）；或者"

#: docs/en/tutorial/tutorial-7.md:529
#, fuzzy
msgid ""
"A local file path (However - be warned: if you give your code to someone "
"else, this path probably won't exist on their machine!)"
msgstr "本機檔案路徑（但是 - "
"請注意：如果您將程式碼提供給其他人，則該路徑可能不會存在於他們的電腦上！）"

#: docs/en/tutorial/tutorial-7.md:532
#, fuzzy
msgid ""
"Further down in `pyproject.toml`, you'll notice other sections that are "
"operating system dependent, like `[tool.briefcase.app.helloworld.macOS]` and "
"`[tool.briefcase.app.helloworld.windows]`. These sections *also* have a "
"`requires` setting. These settings allow you to define additional platform-"
"specific dependencies - so, for example, if you need a platform-specific "
"library to handle some aspect of your app, you can specify that library in "
"the platform-specific `requires` section, and that setting will only be used "
"for that platform. You will notice that the `toga` libraries are all "
"specified in the platform-specific `requires` section - this is because the "
"libraries needed to display a user interface are platform specific."
msgstr ""
"在`pyproject.toml`中，您會注意到與作業系統相關的其他部分，例如`"
"[tool.briefcase.app.helloworld.macOS]`和`"
"[tool.briefcase.app.helloworld`.windows]` "
"。這些部分*也*有一個`requires`設定。這些設定允許您定義其他特定於平台的依賴項 "
"- "
"因此，例如，如果您需要特定於平台的庫來處理應用程式的某些方面，您可以在特定於"
"平台的`requires`部分中指定該庫，並且該設定將僅用於該平台。您會注意到`toga`庫"
"都是在特定於平台的`requires`部分中指定的 - "
"這是因為顯示使用者介面所需的庫是特定於平台的。"

#: docs/en/tutorial/tutorial-7.md:544
#, fuzzy
msgid ""
"In our case, we want `faker` to be installed on all platforms, so we use the "
"app-level `requires` setting. The app-level dependencies will always be "
"installed; the platform-specific dependencies are installed *in addition* to "
"the app-level ones."
msgstr ""
"在我們的例子中，我們希望在所有平台上安裝`httpx`，因此我們使用應用程式層級`req"
"uires`設定。應用程式級相依性將始終被安裝；除了*應用程式層級的依賴項之外，還會"
"安裝特定於平台的依賴項。"

#: docs/en/tutorial/tutorial-7.md:549
#, fuzzy
msgid ""
"Now that we've told Briefcase about our additional requirements, we can try "
"packaging our app again. Ensure that you've saved your changes to "
"`pyproject.toml`, and then update your app again - this time, passing in the "
"`-r` flag. This tells Briefcase to update requirements in the packaged app:"
msgstr ""
"現在我們已經告訴 Briefcase "
"我們的附加要求，我們可以嘗試再次打包我們的應用程式。確保您已將變更儲存到`pypr"
"oject.toml`，然後再次更新您的應用程式 - 這次傳入`-r`標誌。這告訴 Briefcase "
"更新打包應用程式中的要求："

#: docs/en/tutorial/tutorial-7.md:673
#, fuzzy
msgid ""
"Once you've updated, you can run `briefcase build` and `briefcase run` - and "
"you should see your packaged app, with the new dialog behavior."
msgstr "更新後，您可以運行`briefcase build`和`briefcase run` - "
"您應該會看到打包的應用程序，具有新的對話框行為。"

#: docs/en/tutorial/tutorial-7.md:678
#, fuzzy
msgid ""
"The `-r` option for updating requirements is also honored by the `build` and "
"`run` command, so if you want to update, build, and run in one step, you "
"could use `briefcase run -u -r`."
msgstr ""
"用於更新需求的`-r`選項也受到`build`和`run`命令的支持，因此如果您想一步更新、"
"構建和運行，您可以使用`briefcase`運行-u -r`。"

#: docs/en/tutorial/tutorial-7.md:684
msgid "Third-Party Python Packages for Mobile and Web"
msgstr ""

#: docs/en/tutorial/tutorial-7.md:686
msgid ""
"Faker is just one example of a third-party Python package - a collection of "
"code that isn't part what Python provides out of the box. These third-party "
"packages are most commonly distributed using the "
"[Python Package Index (PyPI)]{1}, and installed into your local virtual "
"environment. We've been using `pip` in this tutorial, but there are other "
"options."
msgstr ""

#: docs/en/tutorial/tutorial-7.md:693
#, fuzzy
msgid ""
"On desktop platforms (macOS, Windows, Linux), essentially any package on "
"PyPI package can be installed into your virtual environment, or added to "
"your app's requirements. However, when building an app for mobile or web "
"platforms, [your options are slightly limited]{1}."
msgstr ""
"在桌面平台（macOS、Windows、Linux）上，任何可安裝的`pip`都可以加入您的需求。"
"在行動和網路平台上，[您的選擇略有限制]{1}。"

#: docs/en/tutorial/tutorial-7.md:699
msgid ""
"In short; any *pure Python* package (i.e. any package created from a project "
"written *only* in Python) can be used without difficulty. Some packages, "
"though, are created from projects that contain both Python and other "
"languages (e.g. C, C++, Rust, etc). Code written in those languages needs to "
"be compiled to platform-specific binary modules before it can be used, and "
"those pre-compiled binary modules are only available on specific platforms. "
"Mobile and web platforms have very different requirements than \"standard\" "
"desktop platforms. At this time, most Python packages don't provide pre-"
"compiled binaries for mobile and web platforms."
msgstr ""

#: docs/en/tutorial/tutorial-7.md:710
msgid ""
"On PyPI, packages are often provided in a pre-built distribution format "
"called *wheels*. To check whether a package is pure Python, look at the PyPI "
"downloads page for the project. If the wheels provided have a `-py3-none-"
"any.whl` suffix (e.g., [Faker]{1}), then they are pure Python wheels. "
"However, if the wheels have version and platform-specific extensions (e.g., "
"[Pillow]{2}, which has wheels with suffixes like "
"`-cp313-cp313-macosx_11_0_arm64.whl` and `-cp39-cp39-win_amd64.whl`), then "
"the wheel *contains a binary component*. That package cannot be installed on "
"mobile or web platforms unless a wheel compatible with those platforms has "
"been provided."
msgstr ""

#: docs/en/tutorial/tutorial-7.md:723
msgid ""
"At this time, *most* binary packages on PyPI don't provide mobile- or web-"
"compatible wheels. To fill this gap, BeeWare provides binaries for some "
"popular binary modules (including `numpy`, `pandas`, and `cryptography`). "
"These wheels are *not* distributed on PyPI, but Briefcase will install those "
"wheels if they're available."
msgstr ""

#: docs/en/tutorial/tutorial-7.md:729
#, fuzzy
msgid ""
"It's *usually* possible to compile binary packages for mobile platforms, but "
"it's not easy to set up -- well outside the scope of an introductory "
"tutorial like this one."
msgstr ""
"BeeWare "
"可以為一些流行的二進位模組（包括`numpy`、`pandas`和`cryptography`）提供二進位"
"檔案。 *通常* "
"可以為行動平台編譯軟體包，但設定起來並不容易——這遠遠超出了像本教程這樣的介紹"
"性教程的範圍。"

#: docs/en/tutorial/tutorial-7.md:735
msgid ""
"We've now got an app that uses a third-party library! In [Tutorial 8]{1} "
"we'll learn how to ensure our app remains responsive as we add more complex "
"application logic."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:1
#, fuzzy
msgid "Tutorial 8 - Making it Smooooth"
msgstr "教學 8 - 使其順～暢"

#: docs/en/tutorial/tutorial-8.md:3
msgid ""
"So far, our application has been relatively simple - displaying GUI widgets, "
"calling a simple third-party library, and displaying output in a dialog. All "
"these operations happen very quickly, and our application remains responsive."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:8
msgid ""
"However, in a real world application, we'll need to perform complex tasks or "
"calculations that may take a while to complete - and as those tasks are "
"performed, we want our application to remain responsive. Let's make a change "
"to our application that might take a little time to complete, and see the "
"changes that need to be made to accommodate that behavior."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:15
msgid "Accessing an API"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:17
msgid ""
"A common time-consuming task an app will need to perform is to make a "
"request on a web API to retrieve data, and display that data to the user. "
"Web APIs sometimes take a second or two to respond, so if we're calling an "
"API like that, we need to ensure our application doesn't become unresponsive "
"while we wait for the web API to return an answer."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:23
msgid ""
"This is a toy app, so we don't have a *real* API to work with, so we'll use "
"the [{JSON} Placeholder API]{1} as a source of data. The {JSON} Placeholder "
"API has a number of \"fake\" API endpoints you can use as test data. One of "
"those APIs is the `/posts/` endpoint, which returns fake blog posts. If you "
"open `https://jsonplaceholder.typicode.com/posts/42` in your browser, you'll "
"get a JSON payload describing a single post - some [Lorum ipsum]{2} content "
"for a blog post with ID 42."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:33
msgid ""
"The Python standard library contains all the tools you'd need to access an "
"API. However, the built-in APIs are very low level. They are good "
"implementations of the HTTP protocol - but they require the user to manage "
"lots of low-level details, like URL redirection, sessions, authentication, "
"and payload encoding. As a \"normal browser user\" you're probably used to "
"taking these details for granted, as a browser manages them for you."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:41
msgid ""
"As a result, people have developed third-party libraries that wrap the built-"
"in APIs and provide a simpler API that is a closer match for the everyday "
"browser experience. We're going to use one of those libraries to access the "
"{JSON} Placeholder API - a library called [`httpx`]{1}. Briefcase uses "
"`httpx` internally, so it's already in your local environment - you don't "
"need to install it separately to use it here."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:49
msgid ""
"Let's add a `httpx` API call to our app. Modify the `requires` setting in "
"our `pyproject.toml` to include the new requirement:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:59
msgid "Add an import to the top of the `app.py` to import `httpx`:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:83
msgid ""
"This will change the `say_hello()` callback so that when it is invoked, it "
"will:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:86
msgid "make a GET request on the JSON placeholder API to obtain post 42;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:87
msgid "decode the response as JSON;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:88
msgid "extract the body of the post; and"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:89
msgid ""
"include the body of that post as the text of the \"message\" dialog, in "
"place of the text generated by Faker."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:92
msgid ""
"Lets run our updated app in Briefcase developer mode to check that our "
"change has worked. As we've added a new requirement, we need to tell "
"developer mode to reinstall requirements, by using the `-r` argument:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:110
msgid "![Hello World Tutorial 8 dialog, on macOS]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:132
msgid "![Hello World Tutorial 8 dialog, on Linux]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:154
msgid "![Hello World Tutorial 8 dialog, on Windows]{1}"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:176
msgid ""
"Unless you've got a *really* fast internet connection, you may notice that "
"when you press the button, the GUI for your app locks up for a little bit. "
"The operating system may even manifest this with a \"beachball\" or "
"\"spinner\" cursor to indicate that the app is being unresponsive."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:182
#, fuzzy
msgid ""
"This is because the web request we have made is *synchronous*. When our "
"application makes the web request, it waits for the API to return a response "
"before continuing. While it's waiting, it *isn't* allowing the application "
"to redraw - and as a result, the application locks up."
msgstr ""
"除非您擁有 **真正** 快速的網路連接，否則您可能會注意到，當您按下按鈕時，"
"應用程式的 GUI 會鎖定一點。這是因為我們發出的 Web 請求是 **同步** 的。"
"當我們的應用程式發出 Web 請求時，它會等待 API "
"回傳回應，然後再繼續。在等待時，它 **不允許** 應用程式重繪 - "
"結果，應用程式停止回應。"

#: docs/en/tutorial/tutorial-8.md:187
msgid "GUI Event Loops"
msgstr "GUI 事件循環(Event loop)"

#: docs/en/tutorial/tutorial-8.md:189
msgid ""
"To understand why this happens, we need to dig into the details of how a GUI "
"application works. The specifics vary depending on the platform; but the "
"high level concepts are the same, no matter the platform or GUI environment "
"you're using."
msgstr ""
"為了理解為什麼會發生這種情況，我們需要深入研究 GUI "
"應用程式如何運作的細節。具體情況因平台而異；但無論您使用什麼平台或 GUI "
"環境，概念都是相同的。"

#: docs/en/tutorial/tutorial-8.md:194
msgid "A GUI app is, fundamentally, a single loop that looks something like:"
msgstr "從根本上來說，GUI 應用程式是一個看起來像這樣的循環:"

#: docs/en/tutorial/tutorial-8.md:202
#, fuzzy
msgid ""
"This loop is called the *Event Loop*. (These aren't actual method names - "
"it's an illustration of what is going on using \"pseudo-code\")."
msgstr "此循環稱為 *事件循環* 。 （這些不是實際的方法名稱 - 它是 `偽代碼` "
"中發生的情況的說明）。"

#: docs/en/tutorial/tutorial-8.md:205
msgid ""
"When you click on a button, or drag a scroll bar, or type a key, you are "
"generating an \"event\". That \"event\" is put onto a queue, and the app "
"will process the queue of events when it next has the opportunity to do so. "
"The user code that is triggered in response to the event is called an *event "
"handler*. These event handlers are invoked as part of the `process_events()` "
"call."
msgstr ""
"當您按一下按鈕、拖曳捲軸或按下按鍵時，代表你產生一個 `事件` 。該 `事件` "
"被放入佇列中，應用程式將在下次有機會處理事件佇列時處理該事件。"
"響應事件而觸發的程式碼稱為 `event handler` 。這些事件處理程序作為 "
"`process_events()` 呼叫的一部分被呼叫。"

#: docs/en/tutorial/tutorial-8.md:212
msgid ""
"Once an app has processed all the available events, it will `redraw()` the "
"GUI. This takes into account any changes that the events have caused to the "
"display of the app, as well as anything else that is going on in the "
"operating system - for example, the windows of another app may obscure or "
"reveal part of our app's window, and our app's redraw will need to reflect "
"the portion of the window that is currently visible."
msgstr ""
"一旦應用程式處理完所有可用事件，它將 `redraw()` "
"GUI。這考慮了事件對應用程式顯示造成的任何變化，"
"以及作業系統中發生的任何其他變化 - "
"例如，另一個應用程式的視窗可能會遮蓋或顯示我們應用程式視窗的一部分，我們的應"
"用程式的重繪需要反映目前可見的視窗部分。"

#: docs/en/tutorial/tutorial-8.md:219
msgid ""
"The important detail to notice: while an application is processing an event, "
"*it can't redraw*, and *it can't process other events*."
msgstr "需要注意的重要細節：當應用程式正在處理事件時， *它無法重繪* ，並且 "
"*它無法處理其他事件* 。"

#: docs/en/tutorial/tutorial-8.md:222
msgid ""
"This means any user logic contained in an event handler needs to complete "
"quickly. Any delay in completing the event handler will be observed by the "
"user as a slowdown (or stop) in GUI updates. If this delay is long enough, "
"your operating system may report this as a problem - the macOS \"beachball\" "
"and Windows \"spinner\" icons are the operating system telling you that your "
"app is taking too long in an event handler."
msgstr ""
"這意味著事件處理程序中包含的任何使用者邏輯都需要快速完成。使用者將觀察到完成"
"事件處理程序的任何延遲，因為 GUI 更新速度會減慢（或停止）。如果延遲足夠長，"
"您的作業系統可能會將此報告為問題 - macOS `beachball` 和 Windows `spinner` "
"圖示是作業系統告訴您您的應用程式在事件處理程序中花費的時間太長。"

#: docs/en/tutorial/tutorial-8.md:230
msgid ""
"Simple operations like \"update a label\", or "
"\"recompute the total of the inputs\" are easy to complete quickly. However, "
"there are a lot of operations that can't be completed quickly. If you're "
"performing a complex mathematical calculation, or indexing all the files on "
"a file system, or performing a large network request, you can't "
"\"just do it quickly\" - the operations are inherently slow."
msgstr ""
"`更新標籤` 或 `重新計算輸入總數` "
"等簡單操作很容易快速完成。然而，有許多操作無法快速完成。如果您正在執行複雜的"
"數學計算，或對檔案系統上的所有檔案進行索引，或執行網路請求，則您無法 "
"`快速完成` - 那些操作本質上很慢。"

#: docs/en/tutorial/tutorial-8.md:237
msgid "So - how do we perform long-lived operations in a GUI application?"
msgstr "那麼，我們如何在 GUI 應用程式中執行耗時的操作呢？"

#: docs/en/tutorial/tutorial-8.md:239
msgid "Asynchronous programming"
msgstr "非同步程式設計"

#: docs/en/tutorial/tutorial-8.md:241
msgid ""
"What we need is a way to tell an app in the middle of a long-lived event "
"handler that it is OK to temporarily release control back to the event loop, "
"as long as we can resume where we left off. It's up to the app to determine "
"when this release can occur; but if the app releases control to the event "
"loop regularly, we can have a long-running event handler *and* maintain a "
"responsive UI."
msgstr ""
"我們需要的是一種方法讓耗時的event "
"handler執行時告訴應用程序，只要可以從中斷的地方恢復，就可以暫時將控制權釋放回"
"事件循環。由應用程式決定何時釋放它；但如果應用程式定期釋放對事件循環的控制，"
"我們就可以擁有一個長時間運行的事件處理程序 *並* 維護一個響應式 UI。"

#: docs/en/tutorial/tutorial-8.md:248
msgid ""
"We can do this by using *asynchronous programming*. Asynchronous programming "
"is a way to describe a program that allows the interpreter to run multiple "
"functions at the same time, sharing resources between all the concurrently "
"running functions."
msgstr ""
"我們可以透過使用 `非同步程式設計` "
"來做到這一點。非同步程式設計是一種描述程式的方式，允許解釋器同時運行多個函數"
"，在所有並發運行的函數之間共用資源。"

#: docs/en/tutorial/tutorial-8.md:253
#, fuzzy
msgid ""
"Asynchronous functions (known as *coroutines*) need to be explicitly "
"declared as being asynchronous. They also need to internally declare when an "
"opportunity exists to change context to another coroutine."
msgstr "非同步函數（稱為 *協程* "
"）需要明確宣告為非同步。他們還需要在內部聲明何時存在將上下文更改為另一個協程"
"的機會。"

#: docs/en/tutorial/tutorial-8.md:257
#, fuzzy
msgid ""
"In Python, asynchronous programming is implemented using the `async` and "
"`await` keywords, and the [asyncio]{1} module in the standard library. The "
"`async` keyword allows us to declare that a function is an asynchronous "
"coroutine. The `await` keyword provides a way to declare when an opportunity "
"exists to change context to another coroutine. The [asyncio]{2} module "
"provides some other useful tools and primitives for asynchronous coding."
msgstr ""
"在Python中，非同步程式設計是使用 `async` 和 `await` 關鍵字以及 [asyncio]{1} "
"中的模組來實現的。標準庫。 `async` 關鍵字允許我們宣告函數是非同步協同例程。 "
"`await` "
"關鍵字提供了一種聲明何時存在將上下文更改為另一個協同例程的機會的方法。 "
"[asyncio]{2} 模組為非同步程式設計提供了一些其他有用的工具和語法。"

#: docs/en/tutorial/tutorial-8.md:267
#, fuzzy
msgid "Making the tutorial asynchronous"
msgstr "使教學異步"

#: docs/en/tutorial/tutorial-8.md:269
msgid ""
"To make our tutorial asynchronous, modify the `say_hello()` event handler so "
"it looks like this:"
msgstr "要使我們的教程異步，請修改 `say_hello()` 事件處理程序，使其如下所示："

#: docs/en/tutorial/tutorial-8.md:288
#, fuzzy
msgid ""
"There are only three changes to this callback from the previous version:"
msgstr "與先前的版本相比，此程式碼僅發生了 4 處變更："

#: docs/en/tutorial/tutorial-8.md:290
msgid ""
"The client that is created is an asynchronous `AsyncClient()`, rather than a "
"synchronous `Client()`. This tells `httpx` that it should operate in "
"asynchronous mode, rather than synchronous mode."
msgstr ""
"建立的客戶端是異步 `AsyncClient()` ，而不是同步 `Client()` 。這告訴 `httpx` "
"它應該以非同步模式運行，而不是同步模式。"

#: docs/en/tutorial/tutorial-8.md:293
msgid ""
"The context manager used to create the client is marked as `async`. This "
"tells Python that there is an opportunity to release control as the context "
"manager is entered and exited."
msgstr "用於建立客戶端的上下文管理器被標記為 `async` "
"。這告訴Python，當進入和退出上下文管理器時，有機會釋放控制權。"

#: docs/en/tutorial/tutorial-8.md:296
msgid ""
"The `get` call is made with an `await` keyword. This instructs the app that "
"while we are waiting for the response from the network, the app can release "
"control to the event loop. We've seen this keyword before - we also use "
"`await` when displaying the dialog box. The reason for that usage is the "
"same as it is for the HTTP request - we need to tell the app that while the "
"dialog is displayed, and we're waiting for the user to push a button, it's "
"OK to release control back to the event loop."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:305
msgid ""
"It's also important to note that the handler itself is defined as `async def`"
", rather than just `def`. This tells Python that the method is an "
"asynchronous coroutine. We made this change back in Tutorial 3 when we added "
"the dialog box. You can only use `await` statements inside a method that is "
"declared as `async def`."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:311
#, fuzzy
msgid ""
"Toga allows you to use regular methods or asynchronous coroutines as "
"handlers; Toga manages everything behind the scenes to make sure the handler "
"is invoked or awaited as required."
msgstr "Toga 允許您使用常規方法或非同步協同例程作為處理程序； Toga "
"管理幕後的一切，以確保根據需要呼叫或等待處理程序。"

#: docs/en/tutorial/tutorial-8.md:315
#, fuzzy
msgid ""
"If you save these changes and re-run the app in development mode, there "
"won't be any obvious changes to the app. However, when you click on the "
"button to trigger the dialog, you may notice a number of subtle improvements:"
msgstr ""
"如果您儲存這些變更並重新執行應用程式（在開發模式下使用 `briefcase dev` "
"，或透過更新並重新執行打包的應用程式），應用程式不會有任何明顯的變更。但是，"
"當您單擊按鈕觸發對話框時，您可能會注意到一些細微的改進："

#: docs/en/tutorial/tutorial-8.md:320
msgid ""
"The button returns to an \"unclicked\" state, rather than being stuck in a "
"\"clicked\" state."
msgstr "該按鈕返回到 `未單擊` 狀態，而不是停留在 `單擊` 狀態。"

#: docs/en/tutorial/tutorial-8.md:322
msgid "The \"beachball\"/\"spinner\" icon won't appear."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:323
msgid ""
"If you move/resize the app window while waiting for the dialog to appear, "
"the window will redraw."
msgstr "如果您在等待對話方塊出現時移動/調整應用程式視窗的大小，則該視窗將會重新繪製。"

#: docs/en/tutorial/tutorial-8.md:325
msgid "If you try to open an app menu, the menu will appear immediately."
msgstr "如果您嘗試開啟應用程式選單，該選單將立即出現。"

#: docs/en/tutorial/tutorial-8.md:327
msgid ""
"We can now run the full app. However, as we've added an extra requirement "
"(`httpx`) we also need to update our app's requirements; we can do this by "
"passing `-r` to `briefcase run`. This will update our app's requirements, "
"then re-build the app, then launch the app:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:372
msgid ""
"You should see you app running, and remaining responsive when you press the "
"button and network content is retrieved."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:377
msgid ""
"This has been a taste for what you can do with the tools provided by the "
"BeeWare project. Over the course of this tutorial, you have:"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:380
msgid "Created a new GUI app project;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:381
#, fuzzy
msgid "Run that app in development mode;"
msgstr "在開發者模式下運行應用程式"

#: docs/en/tutorial/tutorial-8.md:382
msgid "Built the app as a standalone binary for a desktop operating system;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:383
msgid "Packaged that project for distribution to others;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:384
msgid "Run the app on a mobile simulator and/or device;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:385
msgid "Run the app as a web app;"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:386
msgid "Added a third-party dependency to your app; and"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:387
msgid "Modified the app so that it remains responsive."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:389
msgid "So - where to from here?"
msgstr ""

#: docs/en/tutorial/tutorial-8.md:391
msgid ""
"If you'd like to go further, there are some additional [topic tutorials]{1} "
"that go into detail on specific aspects of application development."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:394
msgid ""
"If you'd like to know more about how to build complex user interfaces with "
"Toga, you can dive into [Toga's documentation]{1}. Toga also has its own "
"tutorial [demonstrating how to use various features of the widget toolkit]"
"{2}."
msgstr ""

#: docs/en/tutorial/tutorial-8.md:399
msgid ""
"If you'd like to know more about the capabilities of Briefcase, you can dive "
"into [Briefcase's documentation]{1}."
msgstr ""

#~ msgid "Install Python"
#~ msgstr "安裝Python"

#~ msgid "Install dependencies"
#~ msgstr "安裝依賴項"
