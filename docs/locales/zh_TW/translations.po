#
msgid ""
msgstr ""
"Project-Id-Version: BeeWare 0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:20+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: zh_TW <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.16.1\n"

#: docs/en/SUMMARY.md:1
#, fuzzy
msgid "[Tutorial 0 - Let's get set up!]{1}"
msgstr "[教學 0 - 讓我們開始設定吧！]{1}"

#: docs/en/SUMMARY.md:2
#, fuzzy
msgid "[Tutorial 1 - Your first app]{1}"
msgstr "[教學 1 - 您的第一個應用程式]{1}"

#: docs/en/SUMMARY.md:3
#, fuzzy
msgid "[Tutorial 2 - Making it interesting]{1}"
msgstr "[教學 2 - 讓它變得有趣]{1}"

#: docs/en/SUMMARY.md:4
#, fuzzy
msgid "[Tutorial 3 - Packaging for distribution]{1}"
msgstr "[教學 3 - 分發包裝]{1}"

#: docs/en/SUMMARY.md:5
#, fuzzy
msgid "[Tutorial 4 - Updating your application]{1}"
msgstr "[教程 4 - 更新您的應用程式]{1}"

#: docs/en/SUMMARY.md:6
#, fuzzy
msgid "Tutorial 5 - Taking it mobile"
msgstr "教程 5 - 移動使用"

#: docs/en/SUMMARY.md:6
#, fuzzy
msgid "[Tutorial 5 - Taking it mobile]{1}"
msgstr "[教程 5 - 移動使用]{1}"

#: docs/en/SUMMARY.md:6
#, fuzzy
msgid "[Tutorial 5 - Taking it mobile: Android]{1}"
msgstr "[教學 5 - 行動裝置：Android]{1}"

#: docs/en/SUMMARY.md:6
#, fuzzy
msgid "[Tutorial 5 - Taking it mobile: iOS]{1}"
msgstr "[教學 5 - 行動裝置：iOS]{1}"

#: docs/en/SUMMARY.md:10
#, fuzzy
msgid "[Tutorial 6 - Put it on the web!]{1}"
msgstr "[教程 6 - 將其放在網路上！]{1}"

#: docs/en/SUMMARY.md:11
#, fuzzy
msgid "[Tutorial 7 - Get this (third-)party started]{1}"
msgstr "[教學 7 - 啟動此（第三方）]{1}"

#: docs/en/SUMMARY.md:12
#, fuzzy
msgid "[Tutorial 8 - Making it Smooooth]{1}"
msgstr "[教學 8 - 使其順～暢]{1}"

#: docs/en/SUMMARY.md:13 docs/en/tutorial/topics/index.md:1
#, fuzzy
msgid "Going further"
msgstr "更進一步"

#: docs/en/SUMMARY.md:13
#, fuzzy
msgid "[Going further]{1}"
msgstr "[進一步]{1}"

#: docs/en/SUMMARY.md:13 docs/en/tutorial/topics/index.md:8
#, fuzzy
msgid "[Customizing icons]{1}"
msgstr "[Customizing icons]{1}"

#: docs/en/SUMMARY.md:13 docs/en/tutorial/topics/index.md:13
#, fuzzy
msgid "[Using the camera]{1}"
msgstr "[使用相機]{1}。"

#: docs/en/SUMMARY.md:13 docs/en/tutorial/topics/index.md:18
#, fuzzy
msgid "[Testing times]{1}"
msgstr "[Testing times]{1}"

#: docs/en/SUMMARY.md:18
#, fuzzy
msgid "How-to guides"
msgstr "操作指南"

#: docs/en/SUMMARY.md:18
#, fuzzy
msgid "[Contributing to this tutorial]{1}"
msgstr "[對本教學的貢獻]{1}。"

#: docs/en/SUMMARY.md:18
#, fuzzy
msgid "[Style guide]{1}"
msgstr "[樣式指南]{1}"

#: docs/en/how-to/contribute.md:1
#, fuzzy
msgid "Contributing to this tutorial"
msgstr "對本教程的貢獻"

#: docs/en/how-to/contribute.md:3
#, fuzzy
msgid ""
"This tutorial is written using [MkDocs and Markdown]{1}. This guide will "
"help you contribute fixes or new content to this tutorial."
msgstr "本教學使用 [MkDocs 和 Markdown]{1} 撰寫。本指南將協助您為本教程貢獻修正或新內容。"

#: docs/en/how-to/contribute.md:7
#, fuzzy
msgid ""
"Translations of this tutorial are managed using [Weblate]{1}. If you'd like "
"to contribute to the translation effort, join the `#translations` channel on"
" [Discord]{2} and introduce yourself!"
msgstr ""
"本教學的翻譯使用 [Weblate]{1} 管理。如果您想參與翻譯工作，請加入 [Discord]{2} "
"上的「#translations」頻道並自我介紹！"

#: docs/en/how-to/contribute.md:12
#, fuzzy
msgid "Set up your development environment"
msgstr "設定您的開發環境"

#: docs/en/how-to/contribute.md:14
#, fuzzy
msgid ""
"To build the BeeWare tutorial you **must** have a Python 3.12 interpreter "
"installed and available on your path (i.e., `python3` must start a Python "
"3.12 interpreter)."
msgstr ""
"要建立 BeeWare 教學，您***必須在路徑上安裝 Python 3.12 解譯器 (也就是說，`python3` 必須啟動 Python 3.12"
" 解譯器)。"

#: docs/en/how-to/contribute.md:18 docs/en/how-to/contribute.md:51
#: docs/en/how-to/contribute.md:92 docs/en/how-to/contribute.md:135
#: docs/en/how-to/contribute.md:169 docs/en/how-to/contribute.md:201
#: docs/en/how-to/contribute.md:264 docs/en/how-to/contribute.md:318
#: docs/en/how-to/contribute.md:350 docs/en/how-to/contribute.md:385
#: docs/en/how-to/contribute.md:437 docs/en/how-to/contribute.md:469
#: docs/en/how-to/contribute.md:502 docs/en/how-to/contribute.md:566
#: docs/en/tutorial/topics/camera-access.md:159
#: docs/en/tutorial/topics/custom-icons.md:34
#: docs/en/tutorial/topics/custom-icons.md:215
#: docs/en/tutorial/topics/custom-icons.md:412
#: docs/en/tutorial/topics/testing.md:32
#: docs/en/tutorial/topics/testing.md:145
#: docs/en/tutorial/topics/testing.md:220
#: docs/en/tutorial/topics/testing.md:343
#: docs/en/tutorial/topics/testing.md:416 docs/en/tutorial/tutorial-0.md:10
#: docs/en/tutorial/tutorial-0.md:87 docs/en/tutorial/tutorial-0.md:156
#: docs/en/tutorial/tutorial-1.md:14 docs/en/tutorial/tutorial-1.md:62
#: docs/en/tutorial/tutorial-1.md:156 docs/en/tutorial/tutorial-1.md:204
#: docs/en/tutorial/tutorial-2.md:293 docs/en/tutorial/tutorial-2.md:334
#: docs/en/tutorial/tutorial-3.md:21 docs/en/tutorial/tutorial-3.md:192
#: docs/en/tutorial/tutorial-3.md:277 docs/en/tutorial/tutorial-3.md:379
#: docs/en/tutorial/tutorial-4.md:41 docs/en/tutorial/tutorial-4.md:87
#: docs/en/tutorial/tutorial-4.md:204
#: docs/en/tutorial/tutorial-5/android.md:16
#: docs/en/tutorial/tutorial-5/android.md:121
#: docs/en/tutorial/tutorial-5/android.md:204
#: docs/en/tutorial/tutorial-5/android.md:340
#: docs/en/tutorial/tutorial-6.md:32 docs/en/tutorial/tutorial-7.md:46
#: docs/en/tutorial/tutorial-7.md:130 docs/en/tutorial/tutorial-7.md:207
#: docs/en/tutorial/tutorial-7.md:555 docs/en/tutorial/tutorial-8.md:96
#: docs/en/tutorial/tutorial-8.md:332
msgid "/// tab | macOS"
msgstr "/// tab | macOS"

#: docs/en/how-to/contribute.md:25 docs/en/how-to/contribute.md:34
#: docs/en/how-to/contribute.md:43 docs/en/how-to/contribute.md:58
#: docs/en/how-to/contribute.md:67 docs/en/how-to/contribute.md:76
#: docs/en/how-to/contribute.md:102 docs/en/how-to/contribute.md:114
#: docs/en/how-to/contribute.md:126 docs/en/how-to/contribute.md:142
#: docs/en/how-to/contribute.md:151 docs/en/how-to/contribute.md:160
#: docs/en/how-to/contribute.md:176 docs/en/how-to/contribute.md:185
#: docs/en/how-to/contribute.md:194 docs/en/how-to/contribute.md:219
#: docs/en/how-to/contribute.md:239 docs/en/how-to/contribute.md:259
#: docs/en/how-to/contribute.md:278 docs/en/how-to/contribute.md:294
#: docs/en/how-to/contribute.md:308 docs/en/how-to/contribute.md:324
#: docs/en/how-to/contribute.md:332 docs/en/how-to/contribute.md:340
#: docs/en/how-to/contribute.md:356 docs/en/how-to/contribute.md:364
#: docs/en/how-to/contribute.md:372 docs/en/how-to/contribute.md:391
#: docs/en/how-to/contribute.md:399 docs/en/how-to/contribute.md:407
#: docs/en/how-to/contribute.md:443 docs/en/how-to/contribute.md:451
#: docs/en/how-to/contribute.md:459 docs/en/how-to/contribute.md:475
#: docs/en/how-to/contribute.md:483 docs/en/how-to/contribute.md:491
#: docs/en/how-to/contribute.md:508 docs/en/how-to/contribute.md:516
#: docs/en/how-to/contribute.md:524 docs/en/how-to/contribute.md:572
#: docs/en/how-to/contribute.md:580 docs/en/how-to/contribute.md:588
#: docs/en/index.md:24 docs/en/index.md:40 docs/en/index.md:56
#: docs/en/tutorial/topics/camera-access.md:24
#: docs/en/tutorial/topics/camera-access.md:167
#: docs/en/tutorial/topics/camera-access.md:177
#: docs/en/tutorial/topics/custom-icons.md:51
#: docs/en/tutorial/topics/custom-icons.md:75
#: docs/en/tutorial/topics/custom-icons.md:94
#: docs/en/tutorial/topics/custom-icons.md:132
#: docs/en/tutorial/topics/custom-icons.md:166
#: docs/en/tutorial/topics/custom-icons.md:201
#: docs/en/tutorial/topics/custom-icons.md:239
#: docs/en/tutorial/topics/custom-icons.md:271
#: docs/en/tutorial/topics/custom-icons.md:298
#: docs/en/tutorial/topics/custom-icons.md:344
#: docs/en/tutorial/topics/custom-icons.md:346
#: docs/en/tutorial/topics/custom-icons.md:382
#: docs/en/tutorial/topics/custom-icons.md:391
#: docs/en/tutorial/topics/custom-icons.md:427
#: docs/en/tutorial/topics/custom-icons.md:444
#: docs/en/tutorial/topics/custom-icons.md:461
#: docs/en/tutorial/topics/custom-icons.md:477
#: docs/en/tutorial/topics/custom-icons.md:493
#: docs/en/tutorial/topics/testing.md:55 docs/en/tutorial/topics/testing.md:83
#: docs/en/tutorial/topics/testing.md:111
#: docs/en/tutorial/topics/testing.md:162
#: docs/en/tutorial/topics/testing.md:181
#: docs/en/tutorial/topics/testing.md:200
#: docs/en/tutorial/topics/testing.md:252
#: docs/en/tutorial/topics/testing.md:288
#: docs/en/tutorial/topics/testing.md:322
#: docs/en/tutorial/topics/testing.md:361
#: docs/en/tutorial/topics/testing.md:381
#: docs/en/tutorial/topics/testing.md:401
#: docs/en/tutorial/topics/testing.md:458
#: docs/en/tutorial/topics/testing.md:492
#: docs/en/tutorial/topics/testing.md:531 docs/en/tutorial/tutorial-0.md:42
#: docs/en/tutorial/tutorial-0.md:62 docs/en/tutorial/tutorial-0.md:80
#: docs/en/tutorial/tutorial-0.md:97 docs/en/tutorial/tutorial-0.md:130
#: docs/en/tutorial/tutorial-0.md:143 docs/en/tutorial/tutorial-0.md:165
#: docs/en/tutorial/tutorial-0.md:176 docs/en/tutorial/tutorial-0.md:209
#: docs/en/tutorial/tutorial-0.md:211 docs/en/tutorial/tutorial-0.md:229
#: docs/en/tutorial/tutorial-1.md:20 docs/en/tutorial/tutorial-1.md:34
#: docs/en/tutorial/tutorial-1.md:36 docs/en/tutorial/tutorial-1.md:52
#: docs/en/tutorial/tutorial-1.md:54 docs/en/tutorial/tutorial-1.md:68
#: docs/en/tutorial/tutorial-1.md:76 docs/en/tutorial/tutorial-1.md:84
#: docs/en/tutorial/tutorial-1.md:169 docs/en/tutorial/tutorial-1.md:184
#: docs/en/tutorial/tutorial-1.md:199 docs/en/tutorial/tutorial-1.md:210
#: docs/en/tutorial/tutorial-1.md:212 docs/en/tutorial/tutorial-1.md:220
#: docs/en/tutorial/tutorial-1.md:222 docs/en/tutorial/tutorial-1.md:230
#: docs/en/tutorial/tutorial-1.md:248 docs/en/tutorial/tutorial-1.md:250
#: docs/en/tutorial/tutorial-2.md:113 docs/en/tutorial/tutorial-2.md:148
#: docs/en/tutorial/tutorial-2.md:211 docs/en/tutorial/tutorial-2.md:302
#: docs/en/tutorial/tutorial-2.md:313 docs/en/tutorial/tutorial-2.md:324
#: docs/en/tutorial/tutorial-2.md:340 docs/en/tutorial/tutorial-2.md:342
#: docs/en/tutorial/tutorial-2.md:350 docs/en/tutorial/tutorial-2.md:352
#: docs/en/tutorial/tutorial-2.md:360 docs/en/tutorial/tutorial-2.md:362
#: docs/en/tutorial/tutorial-3.md:48 docs/en/tutorial/tutorial-3.md:94
#: docs/en/tutorial/tutorial-3.md:96 docs/en/tutorial/tutorial-3.md:122
#: docs/en/tutorial/tutorial-3.md:211 docs/en/tutorial/tutorial-3.md:245
#: docs/en/tutorial/tutorial-3.md:269 docs/en/tutorial/tutorial-3.md:271
#: docs/en/tutorial/tutorial-3.md:300 docs/en/tutorial/tutorial-3.md:328
#: docs/en/tutorial/tutorial-3.md:352 docs/en/tutorial/tutorial-3.md:429
#: docs/en/tutorial/tutorial-3.md:543 docs/en/tutorial/tutorial-3.md:595
#: docs/en/tutorial/tutorial-4.md:47 docs/en/tutorial/tutorial-4.md:49
#: docs/en/tutorial/tutorial-4.md:57 docs/en/tutorial/tutorial-4.md:59
#: docs/en/tutorial/tutorial-4.md:67 docs/en/tutorial/tutorial-4.md:69
#: docs/en/tutorial/tutorial-4.md:101 docs/en/tutorial/tutorial-4.md:124
#: docs/en/tutorial/tutorial-4.md:140 docs/en/tutorial/tutorial-4.md:157
#: docs/en/tutorial/tutorial-4.md:225 docs/en/tutorial/tutorial-4.md:254
#: docs/en/tutorial/tutorial-4.md:272
#: docs/en/tutorial/tutorial-5/android.md:43
#: docs/en/tutorial/tutorial-5/android.md:72
#: docs/en/tutorial/tutorial-5/android.md:101
#: docs/en/tutorial/tutorial-5/android.md:139
#: docs/en/tutorial/tutorial-5/android.md:159
#: docs/en/tutorial/tutorial-5/android.md:179
#: docs/en/tutorial/tutorial-5/android.md:192
#: docs/en/tutorial/tutorial-5/android.md:216
#: docs/en/tutorial/tutorial-5/android.md:230
#: docs/en/tutorial/tutorial-5/android.md:244
#: docs/en/tutorial/tutorial-5/android.md:259
#: docs/en/tutorial/tutorial-5/android.md:270
#: docs/en/tutorial/tutorial-5/android.md:281
#: docs/en/tutorial/tutorial-5/android.md:293
#: docs/en/tutorial/tutorial-5/android.md:305
#: docs/en/tutorial/tutorial-5/android.md:354
#: docs/en/tutorial/tutorial-5/android.md:370
#: docs/en/tutorial/tutorial-5/android.md:386
#: docs/en/tutorial/tutorial-5/android.md:406
#: docs/en/tutorial/tutorial-5/iOS.md:124 docs/en/tutorial/tutorial-6.md:20
#: docs/en/tutorial/tutorial-6.md:70 docs/en/tutorial/tutorial-6.md:110
#: docs/en/tutorial/tutorial-6.md:150 docs/en/tutorial/tutorial-7.md:66
#: docs/en/tutorial/tutorial-7.md:88 docs/en/tutorial/tutorial-7.md:110
#: docs/en/tutorial/tutorial-7.md:117 docs/en/tutorial/tutorial-7.md:124
#: docs/en/tutorial/tutorial-7.md:144 docs/en/tutorial/tutorial-7.md:146
#: docs/en/tutorial/tutorial-7.md:162 docs/en/tutorial/tutorial-7.md:164
#: docs/en/tutorial/tutorial-7.md:180 docs/en/tutorial/tutorial-7.md:182
#: docs/en/tutorial/tutorial-7.md:189 docs/en/tutorial/tutorial-7.md:196
#: docs/en/tutorial/tutorial-7.md:245 docs/en/tutorial/tutorial-7.md:247
#: docs/en/tutorial/tutorial-7.md:302 docs/en/tutorial/tutorial-7.md:342
#: docs/en/tutorial/tutorial-7.md:344 docs/en/tutorial/tutorial-7.md:419
#: docs/en/tutorial/tutorial-7.md:467 docs/en/tutorial/tutorial-7.md:576
#: docs/en/tutorial/tutorial-7.md:605 docs/en/tutorial/tutorial-7.md:628
#: docs/en/tutorial/tutorial-7.md:647 docs/en/tutorial/tutorial-7.md:671
#: docs/en/tutorial/tutorial-7.md:682 docs/en/tutorial/tutorial-8.md:114
#: docs/en/tutorial/tutorial-8.md:116 docs/en/tutorial/tutorial-8.md:136
#: docs/en/tutorial/tutorial-8.md:138 docs/en/tutorial/tutorial-8.md:158
#: docs/en/tutorial/tutorial-8.md:160 docs/en/tutorial/tutorial-8.md:167
#: docs/en/tutorial/tutorial-8.md:174 docs/en/tutorial/tutorial-8.md:338
#: docs/en/tutorial/tutorial-8.md:346 docs/en/tutorial/tutorial-8.md:354
#: docs/en/tutorial/tutorial-8.md:362 docs/en/tutorial/tutorial-8.md:370
msgid "///"
msgstr "///"

#: docs/en/how-to/contribute.md:27 docs/en/how-to/contribute.md:60
#: docs/en/how-to/contribute.md:104 docs/en/how-to/contribute.md:144
#: docs/en/how-to/contribute.md:178 docs/en/how-to/contribute.md:221
#: docs/en/how-to/contribute.md:280 docs/en/how-to/contribute.md:326
#: docs/en/how-to/contribute.md:358 docs/en/how-to/contribute.md:393
#: docs/en/how-to/contribute.md:445 docs/en/how-to/contribute.md:477
#: docs/en/how-to/contribute.md:510 docs/en/how-to/contribute.md:574
#: docs/en/tutorial/topics/custom-icons.md:53
#: docs/en/tutorial/topics/custom-icons.md:241
#: docs/en/tutorial/topics/custom-icons.md:429
#: docs/en/tutorial/topics/testing.md:57
#: docs/en/tutorial/topics/testing.md:164
#: docs/en/tutorial/topics/testing.md:254
#: docs/en/tutorial/topics/testing.md:363
#: docs/en/tutorial/topics/testing.md:460 docs/en/tutorial/tutorial-0.md:44
#: docs/en/tutorial/tutorial-0.md:99 docs/en/tutorial/tutorial-0.md:167
#: docs/en/tutorial/tutorial-1.md:22 docs/en/tutorial/tutorial-1.md:70
#: docs/en/tutorial/tutorial-1.md:171 docs/en/tutorial/tutorial-1.md:214
#: docs/en/tutorial/tutorial-2.md:304 docs/en/tutorial/tutorial-2.md:344
#: docs/en/tutorial/tutorial-3.md:50 docs/en/tutorial/tutorial-3.md:213
#: docs/en/tutorial/tutorial-3.md:302 docs/en/tutorial/tutorial-3.md:431
#: docs/en/tutorial/tutorial-4.md:51 docs/en/tutorial/tutorial-4.md:103
#: docs/en/tutorial/tutorial-4.md:227
#: docs/en/tutorial/tutorial-5/android.md:45
#: docs/en/tutorial/tutorial-5/android.md:141
#: docs/en/tutorial/tutorial-5/android.md:218
#: docs/en/tutorial/tutorial-5/android.md:356
#: docs/en/tutorial/tutorial-6.md:72 docs/en/tutorial/tutorial-7.md:68
#: docs/en/tutorial/tutorial-7.md:148 docs/en/tutorial/tutorial-7.md:249
#: docs/en/tutorial/tutorial-7.md:578 docs/en/tutorial/tutorial-8.md:118
#: docs/en/tutorial/tutorial-8.md:340
msgid "/// tab | Linux"
msgstr "/// tab | Linux"

#: docs/en/how-to/contribute.md:36 docs/en/how-to/contribute.md:69
#: docs/en/how-to/contribute.md:116 docs/en/how-to/contribute.md:153
#: docs/en/how-to/contribute.md:187 docs/en/how-to/contribute.md:241
#: docs/en/how-to/contribute.md:296 docs/en/how-to/contribute.md:334
#: docs/en/how-to/contribute.md:366 docs/en/how-to/contribute.md:401
#: docs/en/how-to/contribute.md:453 docs/en/how-to/contribute.md:485
#: docs/en/how-to/contribute.md:518 docs/en/how-to/contribute.md:582
#: docs/en/tutorial/topics/custom-icons.md:77
#: docs/en/tutorial/topics/custom-icons.md:273
#: docs/en/tutorial/topics/custom-icons.md:446
#: docs/en/tutorial/topics/testing.md:85
#: docs/en/tutorial/topics/testing.md:183
#: docs/en/tutorial/topics/testing.md:290
#: docs/en/tutorial/topics/testing.md:383
#: docs/en/tutorial/topics/testing.md:494 docs/en/tutorial/tutorial-0.md:64
#: docs/en/tutorial/tutorial-0.md:132 docs/en/tutorial/tutorial-0.md:178
#: docs/en/tutorial/tutorial-1.md:38 docs/en/tutorial/tutorial-1.md:78
#: docs/en/tutorial/tutorial-1.md:186 docs/en/tutorial/tutorial-1.md:224
#: docs/en/tutorial/tutorial-2.md:315 docs/en/tutorial/tutorial-2.md:354
#: docs/en/tutorial/tutorial-3.md:98 docs/en/tutorial/tutorial-3.md:247
#: docs/en/tutorial/tutorial-3.md:330 docs/en/tutorial/tutorial-3.md:545
#: docs/en/tutorial/tutorial-4.md:61 docs/en/tutorial/tutorial-4.md:126
#: docs/en/tutorial/tutorial-4.md:256
#: docs/en/tutorial/tutorial-5/android.md:74
#: docs/en/tutorial/tutorial-5/android.md:161
#: docs/en/tutorial/tutorial-5/android.md:232
#: docs/en/tutorial/tutorial-5/android.md:372
#: docs/en/tutorial/tutorial-6.md:112 docs/en/tutorial/tutorial-7.md:90
#: docs/en/tutorial/tutorial-7.md:166 docs/en/tutorial/tutorial-7.md:304
#: docs/en/tutorial/tutorial-7.md:607 docs/en/tutorial/tutorial-8.md:140
#: docs/en/tutorial/tutorial-8.md:348
msgid "/// tab | Windows"
msgstr "/// tab | Windows"

#: docs/en/how-to/contribute.md:45
#, fuzzy
msgid "Create a virtual environment"
msgstr "設定虛擬環境"

#: docs/en/how-to/contribute.md:47
#, fuzzy
msgid ""
"The recommended way of setting up your development environment for BeeWare "
"is to install a virtual environment, install the required dependencies and "
"start coding. To set up a virtual environment, run:"
msgstr "為BeeWare建立開發環境的建議方法是安裝一個虛擬環境，安裝所需的相依性並開始編碼。要建立虛擬環境，請執行"

#: docs/en/how-to/contribute.md:78
#, fuzzy
msgid "Your prompt should now have a `(.venv)` prefix in front of it."
msgstr "現在，您的提示前應該有`(.venv)`前綴。"

#: docs/en/how-to/contribute.md:80
#, fuzzy
msgid "Clone the BeeWare Tutorial repository"
msgstr "克隆 BeeWare 教學資源庫"

#: docs/en/how-to/contribute.md:82
#, fuzzy
msgid "For updates to BeeWare documentation:"
msgstr "有關 BeeWare 文件的更新："

#: docs/en/how-to/contribute.md:84
#, fuzzy
msgid ""
"Next, go to [the BeeWare Tutorial page on GitHub]{1}, fork the repository "
"into your own account, and then clone a copy of that repository onto your "
"computer by clicking on \"Clone or Download\". If you have the GitHub "
"desktop application installed on your computer, you can select \"Open in "
"Desktop\"; otherwise, copy the URL provided, and use it to clone using the "
"command line:"
msgstr ""
"接下來，前往 [GitHub 上的 BeeWare 教學頁面]{1}，將軟體倉庫 fork 到您自己的帳號，然後點選 \"Clone or "
"Download\"（克隆或下載），將軟體倉庫複製到您的電腦上。如果您的電腦上安裝了 GitHub "
"桌面應用程式，您可以選擇「在桌面打開」；否則，複製所提供的 URL，然後用命令列來克隆："

#: docs/en/how-to/contribute.md:94 docs/en/how-to/contribute.md:106
#: docs/en/how-to/contribute.md:118
#, fuzzy
msgid "Fork the BeeWare Tutorial repository, and then:"
msgstr "分叉 BeeWare Tutorial 儲存庫，然後："

#: docs/en/how-to/contribute.md:100 docs/en/how-to/contribute.md:112
#: docs/en/how-to/contribute.md:124
#, fuzzy
msgid "(substituting your GitHub username)"
msgstr "(用您的 GitHub 用戶名代替）"

#: docs/en/how-to/contribute.md:128
#, fuzzy
msgid "Install BeeWare tutorial docs dependencies"
msgstr "安裝 BeeWare 教學文件的相依性"

#: docs/en/how-to/contribute.md:130
#, fuzzy
msgid ""
"Now that you have the source code, you can install BeeWare docs requirements"
" into your development environment. Since we're installing from source, we "
"can't rely on pip to resolve the dependencies to source packages, so we have"
" to manually install each package:"
msgstr ""
"現在您已經有了原始碼，您可以將 BeeWare docs 的需求安裝到您的開發環境中。由於我們是從原始碼安裝，所以不能依靠 pip "
"來解析原始碼套件的依賴關係，因此我們必須手動安裝每個套件："

#: docs/en/how-to/contribute.md:162
#, fuzzy
msgid "Install pre-commit"
msgstr "安裝預先提交"

#: docs/en/how-to/contribute.md:164
#, fuzzy
msgid ""
"BeeWare uses a tool called [Pre-Commit]{1} to identify simple issues and "
"standardize code formatting. It does this by installing a git hook that "
"automatically runs a series of code linters prior to finalizing any git "
"commit. To enable pre-commit, run:"
msgstr ""
"BeeWare 使用一個叫做 [Pre-Commit]{1} 的工具來識別簡單的問題，並標準化代碼格式。它通過安裝一個 git 鉤子，在完成任何 git"
" 提交之前自動運行一系列代碼篩選器。要啟用預提交，請執行"

#: docs/en/how-to/contribute.md:196
#, fuzzy
msgid ""
"When you commit any change, pre-commit will run automatically. If there are "
"any issues found with the commit, this will cause your commit to fail. Where"
" possible, pre-commit will make the changes needed to correct the problems "
"it has found:"
msgstr ""
"當您提交任何變更時，pre-commit 會自動執行。如果發現提交有任何問題，這將導致您的提交失敗。在可能的情況下，pre-commit "
"會進行所需的變更，以修正它所發現的問題："

#: docs/en/how-to/contribute.md:261
#, fuzzy
msgid ""
"You can then re-add any files that were modified as a result of the pre-"
"commit checks, and re-commit the change."
msgstr "然後，您可以重新新增任何因預先提交檢查而被修改的檔案，並重新提交變更。"

#: docs/en/how-to/contribute.md:310
#, fuzzy
msgid "Now you are ready to start hacking on BeeWare docs!"
msgstr "現在您可以開始入侵 BeeWare 文件了！"

#: docs/en/how-to/contribute.md:312
#, fuzzy
msgid "Building the BeeWare Tutorial"
msgstr "建立 BeeWare 教程"

#: docs/en/how-to/contribute.md:314
#, fuzzy
msgid "Build the Tutorial locally"
msgstr "在本機建立教學"

#: docs/en/how-to/contribute.md:316
#, fuzzy
msgid "Once your development environment is set up, run:"
msgstr "開發環境設定完成後，執行："

#: docs/en/how-to/contribute.md:342
#, fuzzy
msgid ""
"The output of the file should be in the `_build/html` folder. If there are "
"any markup problems, they'll raise an error."
msgstr "檔案的輸出應該在 `_build/html` 資料夾中。如果有任何標記問題，會產生錯誤。"

#: docs/en/how-to/contribute.md:345
#, fuzzy
msgid "Live Tutorial preview"
msgstr "即時教學預覽"

#: docs/en/how-to/contribute.md:347
#, fuzzy
msgid ""
"To support rapid editing of documentation, BeeWare also has a \"live "
"preview\" mode:"
msgstr "為了支援文件的快速編輯，BeeWare 還擁有「即時預覽」模式："

#: docs/en/how-to/contribute.md:374
#, fuzzy
msgid ""
"This will build the documentation, start a web server to serve the build "
"documentation, and watch the file system for any changes to the "
"documentation source. If a change is detected, the documentation will be "
"rebuilt, and any browser viewing the modified page will be automatically "
"refreshed."
msgstr ""
"這將會建立文件、啟動 Web "
"伺服器以提供建立的文件，並觀察檔案系統是否有任何文件來源的變更。如果偵測到變更，就會重新建立文件，任何瀏覽器在檢視修改過的頁面時，都會自動重新整理。"

#: docs/en/how-to/contribute.md:380
#, fuzzy
msgid "Tutorial linting"
msgstr "教學套裝"

#: docs/en/how-to/contribute.md:382
#, fuzzy
msgid ""
"The build process will identify most Markdown problems, but BeeWare performs"
" some additional \"lint\" checks. To run the lint checks:"
msgstr "編譯過程會發現大多數的 Markdown 問題，但 BeeWare 還會執行一些額外的 \"lint\" 檢查。執行檢查"

#: docs/en/how-to/contribute.md:409
#, fuzzy
msgid "This will validate the documentation does not contain:"
msgstr "這將驗證文件不包含："

#: docs/en/how-to/contribute.md:411
#, fuzzy
msgid "dead hyperlinks"
msgstr "死超連結"

#: docs/en/how-to/contribute.md:412
#, fuzzy
msgid "misspelled words"
msgstr "拼字錯誤"

#: docs/en/how-to/contribute.md:414
#, fuzzy
msgid ""
"If a valid spelling of a word is identified as misspelled, then add the word"
" to the list in `docs/spelling_wordlist`. This will add the word to the "
"spellchecker's dictionary. When adding to this list, remember:"
msgstr ""
"如果一個單字的有效拼法被識別為拼錯，則將該單字加入 `docs/spelling_wordlist` "
"中的清單。這將會把該單字加入拼字檢查器的字典中。加入此清單時，請記住："

#: docs/en/how-to/contribute.md:418
#, fuzzy
msgid ""
"We prefer US spelling, with some liberties for programming-specific "
"colloquialisms (e.g., \"apps\") and verbing of nouns (e.g., \"scrollable\")"
msgstr "我們偏好美式拼法，但對於程式特定的口語（例如「apps」）和名詞動詞（例如「scrollable」）則有一些自由度。"

#: docs/en/how-to/contribute.md:420
#, fuzzy
msgid ""
"Any reference to a product name should use the product's preferred "
"capitalization. (e.g., \"macOS\", \"GTK\", \"pytest\", \"Pygame\", "
"\"PyScript\")."
msgstr "任何對產品名稱的引用都應該使用該產品名稱的首字母大寫。(例如，\"macOS\"、\"GTK\"、\"pytest\"、\"Pygame\"、\"PyScript\"）。"

#: docs/en/how-to/contribute.md:423
#, fuzzy
msgid ""
"If a term is being used \"as code\", then it should be quoted as inline code"
" rather than being added to the dictionary."
msgstr "如果某個詞彙是 「作為代碼 」使用的，那麼它應該被引用為內嵌代碼，而不是被添加到字典中。"

#: docs/en/how-to/contribute.md:426
#, fuzzy
msgid "Translations"
msgstr "翻譯"

#: docs/en/how-to/contribute.md:428
#, fuzzy
msgid ""
"The BeeWare tutorial is available in multiple languages, which you can build"
" individually or all at the same time."
msgstr "BeeWare 教程提供多種語言版本，您可以單獨或同時建立所有語言版本。"

#: docs/en/how-to/contribute.md:431
#, fuzzy
msgid "Updating translations"
msgstr "更新翻譯"

#: docs/en/how-to/contribute.md:433
#, fuzzy
msgid ""
"If you have made changes to the English content, the first step to building "
"the translations is to update the translation files. To update the "
"translations:"
msgstr "如果您對英文內容做了變更，建立翻譯的第一步就是更新翻譯檔案。更新翻譯檔案："

#: docs/en/how-to/contribute.md:461
#, fuzzy
msgid "This will update the"
msgstr "這將更新"

#: docs/en/how-to/contribute.md:463
#, fuzzy
msgid "Building translations"
msgstr "建築翻譯"

#: docs/en/how-to/contribute.md:465
#, fuzzy
msgid ""
"To build a single translation, you run the `docs` command with the language "
"code for the translation you wish to build. For example, to build French:"
msgstr "若要建立單一翻譯，請執行 `docs` 指令，並輸入您要建立的翻譯的語言代碼。例如，要建立法文："

#: docs/en/how-to/contribute.md:493
#, fuzzy
msgid ""
"The French translation should be built in the `_build/html` folder. If there"
" are any markup problems, they'll raise an error."
msgstr "法語翻譯應該建立在 `_build/html` 資料夾中。如果有任何標記問題，會產生錯誤。"

#: docs/en/how-to/contribute.md:496
#, fuzzy
msgid ""
"An error is also raised if you enter a language code for an unavailable "
"language. If this happens, verify that you are using the proper language "
"code."
msgstr "如果您輸入無法使用的語言代碼，也會產生錯誤。如果發生這種情況，請確認您使用的是正確的語言代碼。"

#: docs/en/how-to/contribute.md:500
#, fuzzy
msgid "To build all the translations at the same time:"
msgstr "同時建立所有翻譯："

#: docs/en/how-to/contribute.md:526
#, fuzzy
msgid ""
"This will build all available translations in the `_build/html` directory, "
"inside a language-specific subdirectory. For example, the French translation"
" would be available in `_build/html/fr`."
msgstr "這會在 `_build/html`目錄中，特定語言的子目錄內建立所有可用的翻譯。例如，法文翻譯會放在 `_build/html/fr`。"

#: docs/en/how-to/contribute.md:530
#, fuzzy
msgid "What to work on?"
msgstr "要做什麼工作？"

#: docs/en/how-to/contribute.md:532
#, fuzzy
msgid ""
"If you're looking for specific areas to improve, there are [tickets tagged "
"\"documentation\"]{1} in BeeWare's issue tracker."
msgstr "如果您正在尋找需要改進的特定領域，在 BeeWare 的問題追蹤中有[標記為 「文件 」的票據]{1}。"

#: docs/en/how-to/contribute.md:536
#, fuzzy
msgid ""
"However, you don't need to be constrained by these tickets. If you can "
"identify an error in the tutorial, or an improvement that can be made, start"
" writing! Anything that improves the experience of the end user is a welcome"
" change."
msgstr ""
"不過，您不需要受限於這些門票。如果您可以找出教學中的錯誤，或是可以改善的地方，就開始寫吧！任何能改善最終使用者體驗的東西都是值得歡迎的改變。"

#: docs/en/how-to/contribute.md:541
#, fuzzy
msgid "Submitting a pull request"
msgstr "提交拉取請求"

#: docs/en/how-to/contribute.md:543
#, fuzzy
msgid ""
"Before you submit a pull request, there's a few bits of housekeeping to do."
msgstr "在您提交拉取請求之前，有一些內務管理工作要做。"

#: docs/en/how-to/contribute.md:546
#, fuzzy
msgid "Submit from a feature branch, not your `main` branch"
msgstr "從功能分支而非您的主要分支提交"

#: docs/en/how-to/contribute.md:548
#, fuzzy
msgid ""
"Before you start working on your change, make sure you've created a branch. "
"By default, when you clone your repository fork, you'll be checked out on "
"your `main` branch. This is a direct copy of BeeWare's `main` branch. To "
"contribute to BeeWare itself, not the docs, please review the repo README."
msgstr ""
"在您開始進行變更之前，請確定您已建立分支。默認情況下，當您克隆您的版本庫 fork 時，您會在您的 `main` "
"分支上簽出。這是BeeWare`main`分支的直接複製。要對BeeWare本身而非文件做出貢獻，請查看版本庫的README。"

#: docs/en/how-to/contribute.md:554
#, fuzzy
msgid ""
"While you *can* submit a pull request from your `main` branch, it's "
"preferable if you *don't* do this. If you submit a pull request that is "
"*almost* right, the core team member who reviews your pull request may be "
"able to make the necessary changes, rather than giving feedback asking for a"
" minor change. However, if you submit your pull request from your `main` "
"branch, reviewers are prevented from making modifications."
msgstr ""
"雖然您*可以*從您的`main`分支提交拉取請求，但最好不要*這樣做。如果您提交的拉取請求*幾乎*正確，審閱您的拉取請求的核心團隊成員可能就能做出必要的變更，而不是給予回饋要求做小的變更。但是，如果您從您的「主」分支提交您的拉取請求，審閱者就無法進行修改。"

#: docs/en/how-to/contribute.md:561
#, fuzzy
msgid ""
"Instead, you should make your changes on a *feature branch*. A feature "
"branch has a simple name to identify the change that you've made."
msgstr "相反，您應該在 * 功能分支*上進行變更。功能分支有一個簡單的名稱來識別您所做的變更。"

#: docs/en/how-to/contribute.md:564
#, fuzzy
msgid "To create a feature branch, run:"
msgstr "若要建立功能分支，請執行"

#: docs/en/how-to/contribute.md:590
#, fuzzy
msgid ""
"Commit your changes to this branch, then push to GitHub and create a pull "
"request."
msgstr "將您的變更提交到此分支，然後推送到 GitHub 並建立拉取請求。"

#: docs/en/how-to/style-guide.md:1
#, fuzzy
msgid "-8<- \"style_guide.md\""
msgstr "-8<- \"style_guide.md\""

#: docs/en/index.md:1
msgid "Welcome to the BeeWare Tutorial!"
msgstr "歡迎來到 BeeWare 教學！"

#: docs/en/index.md:3
msgid "**Write Python. Run Anywhere.**"
msgstr "**在任何地方執行你寫的Python。**"

#: docs/en/index.md:5
msgid ""
"Welcome to BeeWare! In this tutorial, we're going to build a graphical user "
"interface using Python, and deploy it as a desktop application, as a mobile "
"application, and as a single page web app. We'll also look at how you can "
"use BeeWare tools to perform some of the common tasks that you'll need to do"
" as an app developer, such as testing your app."
msgstr ""
"歡迎來到 BeeWare！在本教學中，我們將使用 Python 建立一個 GUI，並將其部署為桌面應用程式、行動應用程式和網頁。我們還將了解如何使用 "
"BeeWare 工具來執行作為應用程式開發人員所需執行的一些常見任務，例如測試應用程式。"

#: docs/en/index.md:11
#, fuzzy
msgid "{% if config.extra.translation_type == \"original\" %}"
msgstr "{% if config.extra.translation_type == \"original\" %}"

#: docs/en/index.md:13
#, fuzzy
msgid "/// admonition | Translations are available"
msgstr "/// admonition |提供翻譯"

#: docs/en/index.md:15
msgid ""
"If you're not comfortable with English, translations of this tutorial are "
"available in [Deutsch]{1}, [Español]{2}, [Français]{3}, [Italiano]{4}, "
"[Português]{5}, [中文(简体)]{6}, and [中文(繁體)]{7}."
msgstr ""
"如果您不熟悉中文，可以使用本教學的翻譯版本 [English]{1} [Deutsch]{2}, [Español]{3}, "
"[Français]{4}, [Italiano]{5}, [Português]{6}, [简体中文]{7} 。"

#: docs/en/index.md:26 docs/en/index.md:42 docs/en/index.md:58
#, fuzzy
msgid "{% endif %}"
msgstr "{% endif %}"

#: docs/en/index.md:28
#, fuzzy
msgid "{% if config.extra.translation_type == \"machine\" %}"
msgstr "{% if config.extra.translation_type == \"machine\" %}"

#: docs/en/index.md:30
#, fuzzy
msgid "/// admonition | This is a machine translation!"
msgstr "/// admonition |這是機器翻譯！"

#: docs/en/index.md:32
msgid ""
"This version of the tutorial has been generated by machine translation. We "
"know this isn't ideal, but we felt that a bad translation was better than no"
" translation at all."
msgstr "此版本的教學是透過機器翻譯產生的。我們知道這並不理想，但我們認為糟糕的翻譯總比沒有翻譯好。"

#: docs/en/index.md:36 docs/en/index.md:52
msgid ""
"If you'd like the help improve the translation, get in touch! We have a "
"`#translations` channel in [Discord]{1}. Introduce yourself there and we "
"will add you to the translation team."
msgstr ""
"如果您想要協助改進翻譯，請聯絡我們！我們在 [Discord]{1} 中有一個 `#translations` "
"頻道。在那裡進行自我介紹，我們會將您加入翻譯團隊。"

#: docs/en/index.md:44
#, fuzzy
msgid "{% if config.extra.translation_type == \"human\" %}"
msgstr "{% if config.extra.translation_type == \"human\" %}"

#: docs/en/index.md:46
#, fuzzy
msgid "/// admonition | This is a translation!"
msgstr "/// admonition |這是翻譯！"

#: docs/en/index.md:48
msgid ""
"This document is a translation of the English version. The translation has "
"been reviewed by humans, but newer sections may be generated by machine "
"translation, or not translated at all."
msgstr "本文檔是英文版本的翻譯。翻譯已經過人工審核，但較新的部分可能是由機器翻譯產生的，或者根本不翻譯。"

#: docs/en/index.md:61
msgid "What is BeeWare?"
msgstr "什麼是 BeeWare？"

#: docs/en/index.md:63
msgid ""
"BeeWare is not a single product, or tool, or library - it's a collection of "
"tools and libraries, each of which works together to help you write cross "
"platform Python applications with a native GUI. It includes:"
msgstr ""
"BeeWare 不是一個單一的產品、工具或函式庫 - 它是工具和函式庫的集合，每個工具和函式庫協同工作，幫助您編寫跨平台的原生 Python GUI "
"應用程式。這包括："

#: docs/en/index.md:67
#, fuzzy
msgid "[Toga]{1}, a cross-platform widget toolkit;"
msgstr "[Toga]{1}, 一個跨平台的 widget 工具包；"

#: docs/en/index.md:68
#, fuzzy
msgid ""
"[Briefcase]{1}, a tool for packaging Python projects as distributable "
"artefacts that can be shipped to end users;"
msgstr "[Briefcase]{1} ，一種將 Python 專案打包為可分發形式(apk、exe等)並可傳送給最終使用者的工具;"

#: docs/en/index.md:71
#, fuzzy
msgid ""
"Libraries (such as [Rubicon ObjC]{1}) for accessing platform-native "
"libraries;"
msgstr "用於存取各個平臺的原生庫的庫（例如 [Rubicon ObjC]{1} ）;"

#: docs/en/index.md:73
msgid ""
"Pre-compiled builds of Python that can be used on platforms where official "
"Python installers aren't available."
msgstr "預編譯版本的 Python 可在無官方 Python 安裝程式的平台上使用。"

#: docs/en/index.md:76
msgid ""
"In this tutorial, we'll be using all these tools, but as a user, you'll only"
" need to interact with the first two (Toga and Briefcase). However, each of "
"the tools can also be used individually - for example, you can use Briefcase"
" to deploy an app without using Toga as a GUI toolkit."
msgstr ""
"在本教程中，我們將使用所有這些工具，但作為用戶，您只需要與前兩個工具（Toga 和 Briefcase）進行互動。每個工具也可以單獨使用 - "
"舉例來說，您可以使用 Briefcase 來部署應用程序，而不使用 Toga 作為 GUI 工具包。"

#: docs/en/index.md:81
msgid ""
"The BeeWare suite is available on macOS, Windows, Linux (using GTK); on "
"mobile platforms such as Android and iOS; and for the Web."
msgstr ""
"BeeWare 套件可在 macOS、Windows、Linux（使用 GTK）上使用，也在Android和iOS等行動平台上，甚至是網頁。"

#: docs/en/index.md:84
#, fuzzy
msgid "Let's go!"
msgstr "讓我們開始吧！"

#: docs/en/index.md:86
#, fuzzy
msgid ""
"Ready to try BeeWare for yourself? [Let's build a cross-platform application"
" in Python!]{1}"
msgstr "準備好親身體驗BeeWare了嗎？[讓我們用Python來建立一個跨平台的應用程式吧！]{1}."

#: docs/en/tutorial/topics/camera-access.md:1
#, fuzzy
msgid "Using the camera"
msgstr "使用相機"

#: docs/en/tutorial/topics/camera-access.md:3
#, fuzzy
msgid ""
"Almost every modern computing device has a camera of some sort. In this "
"tutorial, we'll write new application that is able to request access to this"
" camera, take a photograph, and then display that photograph in the new "
"application that uses your device's camera."
msgstr ""
"幾乎每部現代電腦裝置都有某種相機。在本教程中，我們將編寫新的應用程式，能夠要求存取此相機、拍攝照片，然後在使用裝置相機的新應用程式中顯示該照片。"

#: docs/en/tutorial/topics/camera-access.md:8
#, fuzzy
msgid "/// admonition | This tutorial won't work on all platforms!"
msgstr "/// admonition |本教學不會在所有平台上運作！"

#: docs/en/tutorial/topics/camera-access.md:10
#, fuzzy
msgid ""
"Unfortunately, at present, this tutorial will only work on macOS and "
"Android."
msgstr "不幸的是，目前本教學只適用於 macOS 和 Android。"

#: docs/en/tutorial/topics/camera-access.md:13
#, fuzzy
msgid ""
"Although iPhones all have cameras, the iOS *Simulator* doesn't have a "
"working camera. Windows and Linux devices also have cameras, but Toga "
"doesn't currently have the ability to access the camera on these platforms."
msgstr ""
"雖然 iPhone 都有相機，但 iOS *Simulator* 並沒有可用的相機。Windows 和 Linux 裝置也有攝影機，但 Toga "
"目前無法在這些平台上存取攝影機。"

#: docs/en/tutorial/topics/camera-access.md:18
#, fuzzy
msgid ""
"The code presented here will *run* on Windows or Linux; but it will raise an"
" error when you try to take a photograph."
msgstr "這裡提出的程式碼可以在 Windows 或 Linux 上 * 執行；但當您嘗試拍照時，它會產生錯誤。"

#: docs/en/tutorial/topics/camera-access.md:21
#, fuzzy
msgid ""
"The code will work if it is run on an actual iOS device, but will fail to "
"take a photograph if deployed to the iOS simulator."
msgstr "如果在實際的 iOS 裝置上執行，程式碼將會正常運作，但如果部署到 iOS 模擬器上，則會無法拍照。"

#: docs/en/tutorial/topics/camera-access.md:26
#, fuzzy
msgid "Start a new project"
msgstr "開始新專案"

#: docs/en/tutorial/topics/camera-access.md:28
#, fuzzy
msgid ""
"For this tutorial, we're not going to build onto the application from the "
"core tutorial - we're going to start a fresh project. You can use the same "
"virtual environment you used in the first project; but we need to re-run the"
" `briefcase new` wizard."
msgstr ""
"在本教程中，我們不打算在核心教程中的應用程式上進行建置 - 我們要開始一個全新的專案。您可以使用與第一個專案相同的虛擬環境；但我們需要重新執行 "
"`briefcase new` 精靈。"

#: docs/en/tutorial/topics/camera-access.md:33
#, fuzzy
msgid ""
"Change back to the directory that contains the `helloworld` project folder, "
"and start a new project named \"Hello Camera\":"
msgstr "變回包含專案資料夾 `helloworld` 的目錄，並開始一個名為「Hello Camera」的新專案："

#: docs/en/tutorial/topics/camera-access.md:50
#, fuzzy
msgid "Add code to take a photo"
msgstr "新增代碼以拍攝照片"

#: docs/en/tutorial/topics/camera-access.md:52
#, fuzzy
msgid ""
"The wizard has generated a new empty Toga project. We can now add the code "
"to take and display a photograph. Edit the `app.py` for the new application "
"so that it has the following content:"
msgstr "精靈已產生一個新的空 Toga 專案。現在我們可以加入拍攝和顯示照片的程式碼。編輯新應用程式的 `app.py`，使其具有以下內容："

#: docs/en/tutorial/topics/camera-access.md:107
#, fuzzy
msgid ""
"This code has two changes over the default app that is generated by "
"Briefcase. These additions are highlighted above:"
msgstr "與 Briefcase 所產生的預設應用程式相比，此程式碼有兩項變更。這些新增內容將在上文強調："

#: docs/en/tutorial/topics/camera-access.md:110
#, fuzzy
msgid ""
"The first highlighted code block (in the `startup()` method) adds the two "
"widgets needed to control the camera: an `ImageView` to display a photo; and"
" a `Button` to trigger the camera."
msgstr ""
"第一個突出顯示的程式碼區塊（在 `startup()` 方法中）新增了控制攝影機所需的兩個 widget：顯示相片的 "
"`ImageView`，以及觸發攝影機的 `Button`。"

#: docs/en/tutorial/topics/camera-access.md:113
#, fuzzy
msgid ""
"The second highlighted code block (the `take_photo()` method) defines the "
"event handler when the button is pressed. This handler first confirms if the"
" application has permission to take a photo; if permission doesn't exist, it"
" is requested. Then, a photo is taken. The request for permission and the "
"request to take a photo are both asynchronous requests, so they require the "
"use of `await`; while the app is waiting for the user to confirm permissions"
" or take the photo, the app's event loop can continue in the background."
msgstr ""
"第二個反白顯示的程式碼區塊（`take_photo()` "
"方法）定義了按鈕被按下時的事件處理程式。此處理器會首先確認應用程式是否有拍照的權限；如果沒有權限，則會請求權限。然後拍攝照片。請求權限和拍攝照片的請求都是異步請求，因此需要使用"
" `await`；當應用程式在等待使用者確認權限或拍攝照片時，應用程式的事件循環可以在背景中繼續。"

#: docs/en/tutorial/topics/camera-access.md:122
#, fuzzy
msgid ""
"If the camera successfully takes a photo, it will return an `Image` object "
"that can be assigned as the content of the `ImageView`. If the photo request"
" was canceled by the user, the `self.camera.take_photo()` call will return "
"`None`, and the result can be ignored. If the user doesn't grant permission "
"to use the camera, or the camera isn't implemented on the current platform, "
"an error will be raised, and a dialog will be shown to the user."
msgstr ""
"如果相機成功拍攝了照片，它會返回一個 `Image` 物件，這個物件可以指定為 `ImageView` "
"的內容。如果拍照請求被使用者取消，`self.camera.take_photo()` 呼叫將返回 "
"`None`，結果可以被忽略。如果使用者沒有允許使用照相機，或是照相機沒有在目前的平台上實作，將會產生錯誤，並顯示對話框給使用者。"

#: docs/en/tutorial/topics/camera-access.md:130
#, fuzzy
msgid "Adding device permissions"
msgstr "新增裝置權限"

#: docs/en/tutorial/topics/camera-access.md:132
#, fuzzy
msgid ""
"Part of this code we've just added asks for permission to use the camera. "
"This is a common feature of modern app platforms - you can't access hardware"
" features without explicitly asking the user's permission first."
msgstr ""
"我們剛剛加入的這段程式碼，有一部分是要求取得使用攝影機的權限。這是現代應用程式平台的常見功能 - 不先明確詢問用戶的許可，就無法存取硬體功能。"

#: docs/en/tutorial/topics/camera-access.md:137
#, fuzzy
msgid ""
"However, this request comes in two parts. The first is in the code we've "
"just seen; but before the app can ask for permissions, it needs to declare "
"the permissions it is going to ask for."
msgstr "不過，這個要求分為兩部分。第一部分在我們剛剛看到的程式碼中；但在應用程式要求權限之前，它需要先宣告它要要求的權限。"

#: docs/en/tutorial/topics/camera-access.md:141
#, fuzzy
msgid ""
"The permissions required by each platform are slightly different, but "
"Briefcase has a cross-platform representation for many common hardware "
"permissions. In the `[tool.briefcase.app.hellocamera]` configuration section"
" of your app's `pyproject.toml` file, add the following (just above the "
"`sources` declaration):"
msgstr ""
"每個平台所需的權限略有不同，但 Briefcase 對許多常見的硬體權限都有跨平台的表示。在您應用程式的 `pyproject.toml` 檔案的 "
"`[tool.briefcase.app.hellocamera]`配置區段中，新增下列內容 (就在 `sources` 宣告的上方)："

#: docs/en/tutorial/topics/camera-access.md:151
#, fuzzy
msgid ""
"This declares that your app needs to access the camera, and provides a short"
" description why the camera is required. This description is needed on some "
"platforms (most notably macOS and iOS) and will be displayed to the user as "
"a additional information when the permission dialog is presented."
msgstr ""
"這宣告您的應用程式需要存取攝影機，並提供簡短的說明，說明為何需要使用攝影機。在某些平台 (最顯著的是 macOS 和 iOS) "
"上需要此說明，並會在顯示權限對話框時，以附加資訊的形式顯示給使用者。"

#: docs/en/tutorial/topics/camera-access.md:157
#, fuzzy
msgid "We can now generate and run the app:"
msgstr "現在我們可以產生並執行應用程式："

#: docs/en/tutorial/topics/camera-access.md:169
#: docs/en/tutorial/topics/custom-icons.md:96
#: docs/en/tutorial/topics/custom-icons.md:300
#: docs/en/tutorial/topics/custom-icons.md:463
#: docs/en/tutorial/tutorial-7.md:112 docs/en/tutorial/tutorial-7.md:184
#: docs/en/tutorial/tutorial-7.md:346 docs/en/tutorial/tutorial-7.md:630
#: docs/en/tutorial/tutorial-8.md:162 docs/en/tutorial/tutorial-8.md:356
msgid "/// tab | Android"
msgstr "/// tab | Android"

#: docs/en/tutorial/topics/camera-access.md:179
#, fuzzy
msgid ""
"When the app runs, you'll be presented with a button. Press the button, and "
"the platform's default camera dialog will be displayed. Take a photo; the "
"camera dialog will disappear, and the photo will be displayed on in the app,"
" just above the button. You could then take another photo; this will replace"
" the first photo."
msgstr ""
"當應用程式執行時，您會看到一個按鈕。按下按鈕，平台的預設相機對話框將會顯示。拍張照片；相機對話框會消失，照片會顯示在應用程式中，就在按鈕上方。然後您可以再拍一張照片；這張照片會取代第一張照片。"

#: docs/en/tutorial/topics/camera-access.md:185
#, fuzzy
msgid "Adding more permissions"
msgstr "新增更多權限"

#: docs/en/tutorial/topics/camera-access.md:187
#, fuzzy
msgid ""
"Permissions are declared in the files that are generated during the original"
" call to `briefcase create`. Unfortunately, Briefcase can't update these "
"files once they've been initially generated; so if you want to add a new "
"permission to your app, or modify existing permissions, you'll need to re-"
"create the app. You can do this by re-running `briefcase create`; this will "
"warn you that the existing app will be overwritten, and then regenerate the "
"application with the new permissions."
msgstr ""
"權限是在原始呼叫 `briefcase create` 時產生的檔案中宣告的。不幸的是，Briefcase "
"無法在初始產生這些檔案後更新它們；所以如果您想要在應用程式中加入新的權限，或是修改現有的權限，您需要重新建立應用程式。您可以重新執行 "
"`briefcase create` 來做到這一點；這會警告您現有的應用程式將會被覆寫，然後用新的權限重新產生應用程式。"

#: docs/en/tutorial/topics/custom-icons.md:1
#, fuzzy
msgid "Customizing icons"
msgstr "自訂圖示"

#: docs/en/tutorial/topics/custom-icons.md:3
#, fuzzy
msgid ""
"The app we developed in the main tutorial uses a default \"gray bee\" icon "
"when it is packaged. Let's personalize this application by configuring it to"
" use our own icon."
msgstr "到目前為止，我們的應用程式使用了預設的 `灰色蜜蜂` 圖示。我們如何更新應用程式以使用我們自己的圖標？"

#: docs/en/tutorial/topics/custom-icons.md:7
msgid "Adding an icon"
msgstr "新增圖示"

#: docs/en/tutorial/topics/custom-icons.md:9
#, fuzzy
msgid ""
"Every platform uses a different format for application icons - and some "
"platforms need *multiple* icons in different sizes and shapes. To account "
"for this, Briefcase provides a shorthand way to configure an icon once, and "
"then have that definition expand in to all the different icons needed for "
"each individual platform."
msgstr ""
"每個平台都使用不同的應用程式圖示格式，有些平台需要不同大小和形狀的多個圖示。為了解決這個問題，Briefcase "
"提供了一種速記的方式來一次設定圖示，然後將該定義展開為每個平台所需的所有不同圖示。"

#: docs/en/tutorial/topics/custom-icons.md:15
#, fuzzy
msgid ""
"Edit your `pyproject.toml`, adding a new `icon` configuration item in the "
"`[tool.briefcase.app.helloworld]` configuration section, just above the "
"`sources` definition:"
msgstr ""
"編輯您的「pyproject.toml」，在「[tool.briefcase.app.helloworld]」配置區段中加入新的「icon」配置項目，就在「sources」定義的上方："

#: docs/en/tutorial/topics/custom-icons.md:23
#, fuzzy
msgid ""
"This icon definition doesn't specify any file extension. The value will be "
"used as a prefix; each platform will add additional items to this prefix to "
"build the files needed for each platform. Some platforms require *multiple* "
"icon files; this prefix will be combined with file size and variant "
"modifiers to generate the list of icon files that are used."
msgstr ""
"這個圖示定義沒有指定任何檔案副檔名。該值將作為前綴；每個平台會在此前綴中加入額外項目，以建立每個平台所需的檔案。某些平台需要*多個*圖示檔案；此前綴將結合檔案大小和變異修改器，以產生使用的圖示檔案清單。"

#: docs/en/tutorial/topics/custom-icons.md:30
#, fuzzy
msgid ""
"We can now run `briefcase update` again - but this time, we pass in the "
"`--update-resources` flag, telling Briefcase that we want to install new "
"application resources (i.e., the icons):"
msgstr ""
"現在我們可以再次執行 `briefcase update` - 但這一次，我們傳入 `--update-resources` 標誌，告訴 "
"Briefcase 我們要安裝新的應用程式資源 (也就是圖示)："

#: docs/en/tutorial/topics/custom-icons.md:134
#: docs/en/tutorial/topics/custom-icons.md:348
#: docs/en/tutorial/topics/custom-icons.md:479
#: docs/en/tutorial/tutorial-7.md:119 docs/en/tutorial/tutorial-7.md:191
#: docs/en/tutorial/tutorial-7.md:421 docs/en/tutorial/tutorial-7.md:649
#: docs/en/tutorial/tutorial-8.md:169 docs/en/tutorial/tutorial-8.md:364
msgid "/// tab | iOS"
msgstr "/// tab | iOS"

#: docs/en/tutorial/topics/custom-icons.md:168
#, fuzzy
msgid ""
"This reports the specific icon file (or files) that Briefcase is expecting. "
"However, as we haven't provided the actual icon files, the install fails, "
"and Briefcase falls back to a default value (the same \"gray bee\" icon)."
msgstr ""
"這會報告 Briefcase 期望的特定圖示檔案 (或檔案)。但是，由於我們沒有提供實際的圖示檔案，安裝失敗，Briefcase 會回到預設值 "
"(相同的「灰色蜜蜂」圖示)。"

#: docs/en/tutorial/topics/custom-icons.md:173
#, fuzzy
msgid ""
"Let's provide some actual icons. Download [this icons.zip bundle]{1}, and "
"unzip it into the root of your project directory. After unzipping, your "
"project directory should look something like:"
msgstr ""
"讓我們提供一些實際的圖示。下載 [this icons.zip bundle]{1}，並解壓縮到專案目錄的根目錄。解壓縮後，您的專案目錄應該是這樣的"

#: docs/en/tutorial/topics/custom-icons.md:194
#, fuzzy
msgid ""
"There's a *lot* of icons in this folder, but most of them should look the "
"same: a green snake on a light blue background:"
msgstr "這個資料夾裡有很多圖示，但大多數看起來都一樣：淺藍色背景上有一條綠色的蛇："

#: docs/en/tutorial/topics/custom-icons.md:197
#, fuzzy
msgid "![Icon of green snake with a light blue background]{1}"
msgstr "![淺藍色背景的綠蛇圖示]{1}。"

#: docs/en/tutorial/topics/custom-icons.md:199
#: docs/en/tutorial/tutorial-1.md:208 docs/en/tutorial/tutorial-1.md:218
#: docs/en/tutorial/tutorial-1.md:228 docs/en/tutorial/tutorial-2.md:338
#: docs/en/tutorial/tutorial-2.md:348 docs/en/tutorial/tutorial-2.md:358
#: docs/en/tutorial/tutorial-4.md:45 docs/en/tutorial/tutorial-4.md:55
#: docs/en/tutorial/tutorial-4.md:65
#: docs/en/tutorial/tutorial-5/android.md:255
#: docs/en/tutorial/tutorial-5/android.md:266
#: docs/en/tutorial/tutorial-5/android.md:277
#: docs/en/tutorial/tutorial-5/android.md:301
#: docs/en/tutorial/tutorial-5/iOS.md:122 docs/en/tutorial/tutorial-7.md:142
#: docs/en/tutorial/tutorial-7.md:160 docs/en/tutorial/tutorial-7.md:178
#: docs/en/tutorial/tutorial-7.md:243 docs/en/tutorial/tutorial-7.md:340
#: docs/en/tutorial/tutorial-8.md:112 docs/en/tutorial/tutorial-8.md:134
#: docs/en/tutorial/tutorial-8.md:156
msgid "/// caption"
msgstr "/// caption"

#: docs/en/tutorial/topics/custom-icons.md:203
#, fuzzy
msgid ""
"The only exception will be the icons with `-adaptive-` in their name; these "
"will have a transparent background. This represents all the different icon "
"sizes and shapes you need to support an app on every platform that Briefcase"
" supports."
msgstr ""
"唯一的例外是名稱中含有 `-adaptive-` 的圖示；這些圖示將會有透明背景。這代表在 Briefcase "
"支援的每個平台上支援應用程式所需的所有不同圖示尺寸和形狀。"

#: docs/en/tutorial/topics/custom-icons.md:208
#, fuzzy
msgid ""
"Now that we have icons, we can update the application again. However, "
"`briefcase update` will only copy the updated resources into the build "
"directory; we also want to rebuild the app to make sure the new icon is "
"included, then start the app. We can shortcut this process by passing "
"`--update-resources` to our call to `run` - this will update the app, update"
" the app's resources, and then start the app:"
msgstr ""
"現在有了圖示，我們可以再次更新應用程式。然而，`briefcase update` "
"只會將更新的資源複製到建立目錄中；我們還要重建應用程式，以確保包含新的圖示，然後啟動應用程式。我們可以在呼叫 `run` 時傳入 `--update-"
"resources` 來縮短這個過程 - 這會更新應用程式、更新應用程式的資源，然後啟動應用程式："

#: docs/en/tutorial/topics/custom-icons.md:338
#: docs/en/tutorial/topics/custom-icons.md:384
#: docs/en/tutorial/tutorial-2.md:142 docs/en/tutorial/tutorial-2.md:201
#: docs/en/tutorial/tutorial-4.md:150 docs/en/tutorial/tutorial-7.md:676
#, fuzzy
msgid "/// note | Note"
msgstr "/// note |注意事項"

#: docs/en/tutorial/topics/custom-icons.md:340
#, fuzzy
msgid ""
"If you're using a recent version of Android, you may notice that the app "
"icon has been changed to a green snake, but the background of the icon is "
"*white*, rather than light blue. We'll fix this in the next step."
msgstr ""
"如果您使用的是最新版本的 Android，您可能會注意到應用程式圖示已改成綠色的蛇形，但圖示的背景是*白色*，而非淺藍色。我們會在下一步修正這個問題。"

#: docs/en/tutorial/topics/custom-icons.md:386
#, fuzzy
msgid ""
"If you get a stack trace referencing `faker` or `httpx` when you run the "
"app, it's possible you missed running your app during step 7 or 8 of the "
"tutorial. Re-run the app, adding the `-r` argument to update the app "
"requirements."
msgstr ""
"如果您在執行應用程式時收到引用 `faker` 或 `httpx` 的堆疊痕跡，可能是您在教程的第 7 或第 8 "
"步遺漏了執行應用程式。重新執行應用程式，加入 `-r` 參數以更新應用程式需求。"

#: docs/en/tutorial/topics/custom-icons.md:393
#, fuzzy
msgid ""
"When you run the app on iOS or Android, in addition to the icon change, you "
"should also notice that the splash screen incorporates the new icon. "
"However, the light blue background of the icon looks a little out of place "
"against the white background of the splash screen. We can fix this by "
"customizing the background color of the splash screen. Add the following "
"definition to your `pyproject.toml`, just after the `icon` definition:"
msgstr ""
"當您在 iOS 或 Android "
"上執行應用程式時，除了圖示變更之外，您應該也會注意到閃屏加入了新圖示。但是，圖示的淺藍色背景與閃屏的白色背景看起來有點格格不入。我們可以自訂閃屏的背景顏色來解決這個問題。將以下定義加入您的"
" `pyproject.toml`，就在 icon` 定義之後："

#: docs/en/tutorial/topics/custom-icons.md:405
#, fuzzy
msgid ""
"Unfortunately, Briefcase isn't able to apply this change to an already "
"generated project, as it requires making modifications to one of the files "
"that was generated during the original call to `briefcase create`. To apply "
"this change, we have to re-create the app by re-running `briefcase create`. "
"When we do this, we'll be prompted to confirm that we want to overwrite the "
"existing project:"
msgstr ""
"不幸的是，Briefcase 無法將此變更套用至已產生的專案，因為這需要修改在原始呼叫 `briefcase create` "
"時產生的其中一個檔案。要套用這個變更，我們必須重新執行 `briefcase create` "
"來重新建立應用程式。當我們這樣做時，系統會提示我們確認是否要覆蓋現有的專案："

#: docs/en/tutorial/topics/custom-icons.md:496
#, fuzzy
msgid ""
"You can then re-build and re-run the app using `briefcase run`. You won't "
"notice any changes to the desktop app; but the Android or iOS apps should "
"now have a light blue splash screen background."
msgstr ""
"然後您可以使用 `briefcase run` 重新建立並執行應用程式。您不會注意到桌面應用程式有任何改變；但 Android 或 iOS "
"應用程式現在應該會有淺藍色的閃屏背景。"

#: docs/en/tutorial/topics/custom-icons.md:500
#, fuzzy
msgid ""
"You'll need to re-create the app like this whenever you make a change to "
"your `pyproject.toml` that doesn't relate to source code or dependencies. "
"Any change to descriptions, version numbers, colors, or permissions will "
"require a re-create step. Because of this, while you are developing your "
"project, you shouldn't make any manual changes to the contents of the "
"`build` folder, and you shouldn't add the `build` folder to your version "
"control system. The `build` folder should be considered entirely ephemeral -"
" an output of the build system that can be recreated as needed to reflect "
"the current configuration of your project."
msgstr ""
"每當您對 `pyproject.toml` "
"做出與原始碼或相依性無關的變更時，都需要像這樣重新建立應用程式。任何對描述、版本號碼、顏色或權限的變更都需要重新建立的步驟。正因如此，當您在開發專案時，不應該手動變更"
" `build` 資料夾中的內容，也不應該將 `build` 資料夾加到您的版本控制系統中。`build` 資料夾應該被視為完全短暫的 - "
"是建立系統的輸出，可以在需要時重新建立，以反映專案的目前配置。"

#: docs/en/tutorial/topics/index.md:3
#, fuzzy
msgid ""
"Want to go deeper on specific topics? Here are some additional tutorials "
"that explore common aspects of application development. Each tutorial is "
"standalone, and can be completed in any order; but they all assume you've "
"completed the core tutorial."
msgstr ""
"想要深入瞭解特定主題嗎？以下是一些探索應用程式開發常見問題的額外教學。每個教學都是獨立的，可以以任何順序完成；但是它們都假定您已經完成了核心教學。"

#: docs/en/tutorial/topics/index.md:10
#, fuzzy
msgid ""
"Customize your application's appearance by replacing the default \"gray "
"bee\" icon."
msgstr "取代預設的「灰色蜜蜂」圖示，自訂應用程式的外觀。"

#: docs/en/tutorial/topics/index.md:15
#, fuzzy
msgid ""
"Use the camera on your mobile or desktop device to take and view a picture "
"from within your application."
msgstr "使用行動或桌上型裝置上的相機，在應用程式內拍攝及檢視照片。"

#: docs/en/tutorial/topics/index.md:20
#, fuzzy
msgid ""
"How do you ensure that your application works, and stays working? By adding "
"a test suite to your project!"
msgstr "如何確保您的應用程式能正常運作並保持運作？在專案中加入測試套件！"

#: docs/en/tutorial/topics/testing.md:1
#, fuzzy
msgid "Testing times"
msgstr "測試時間"

#: docs/en/tutorial/topics/testing.md:3
msgid ""
"Most software development doesn't involve writing new code - it's modifying "
"existing code. Ensuring that existing code continues to work in the way we "
"expect is a key part of the software development process. One way to do "
"ensure the behavior of our app is with a *test suite*."
msgstr ""
"大多數軟體開發並不涉及編寫新程式碼，而是修改現有程式碼。確保現有程式碼繼續按照我們期望的方式運作是軟體開發過程的關鍵部分。確保我們的應用程式行為的一種方法是使用"
" *測試套件* 。"

#: docs/en/tutorial/topics/testing.md:8
msgid "Running the test suite"
msgstr "運行測試套件"

#: docs/en/tutorial/topics/testing.md:10
#, fuzzy
msgid ""
"It turns out the project from the core tutorial already has a test suite! "
"When we originally generated our project, two top-level directories were "
"generated: `src` and `tests`. The `src` folder contains the code for our "
"app; the `tests` folder contains our test suite. Inside the `tests` folder "
"is a file named `test_app.py` with the following content:"
msgstr ""
"事實上，我們的專案已經有測試套件了！當我們最初產生專案時，產生了兩個資料夾： `src` 和 `tests` 。 `src` "
"資料夾包含我們應用程式的程式碼； `tests` 資料夾包含我們的測試套件。在 `tests` 資料夾內有一個名為 `test_app.py` "
"的文件，其中包含以下內容："

#: docs/en/tutorial/topics/testing.md:23
msgid ""
"This is a [Pytest]{1} *test case* - a block of code that can be executed to "
"verify some behavior of your app. In this case, the test is a placeholder, "
"and doesn't test anything about our app - but it is a test that we can "
"perform."
msgstr ""
"這是一個 [Pytest]{1} 的 *測試範例* - "
"可以執行以驗證應用程式的某些行為的程式碼區塊。在本例中，測試僅是一個範例，不會測試有關我們應用程式的任何內容 - 但它是我們可以執行的測試。"

#: docs/en/tutorial/topics/testing.md:28
msgid ""
"We can run this test suite using the `--test` option to `briefcase dev`. As "
"this is the first time we are running tests, we also need to pass in the "
"`-r` option to ensure that the test requirements are also installed:"
msgstr ""
"我們可以使用 `briefcase dev` 的 `--test` 選項來執行這個測試套件。由於這是我們第一次執行測試，我們還需要傳入 `-r` "
"選項以確保測試要求也已安裝："

#: docs/en/tutorial/topics/testing.md:114
msgid ""
"Success! We've just executed a single test that verifies Python math works "
"in the way we'd expect (What a relief!)."
msgstr "成功了！我們剛剛執行了一個測試，證實了 Python 的數學按照我們期望的方式工作（真是鬆了一口氣！）。"

#: docs/en/tutorial/topics/testing.md:117
msgid ""
"Let's replace this placeholder test with a test to verify that our "
"`greeting()` method behaves the way we'd expect. Replace the contents of "
"`test_app.py` with the following:"
msgstr ""
"讓我們用一個測試來取代這個範例，以驗證我們的 `greeting()` 方法的行為是否符合我們的預期。將 `test_app.py` "
"的內容替換為以下內容："

#: docs/en/tutorial/topics/testing.md:137
msgid ""
"This defines two new tests, verifying the two behaviors we expect to see: "
"the output when a name is provided, and the output when the name is empty."
msgstr "這定義了兩個新的測試，驗證我們期望看到的兩個行為：提供名稱時的輸出，以及名稱為空時的輸出。"

#: docs/en/tutorial/topics/testing.md:141
msgid ""
"We can now re-run the test suite. This time, we don't need to provided the "
"`-r` option, as the test requirements have already been installed; we only "
"need to use the `--test` option:"
msgstr "我們現在可以重新運行測試套件。這次，我們不需要提供 `-r` 選項，因為測試要求已經安裝了；我們只需要使用 `--test` 選項："

#: docs/en/tutorial/topics/testing.md:202
msgid "Excellent! Our `greeting()` utility method is working as expected."
msgstr "非常好！我們的 `greeting()` 實用方法按預期工作。"

#: docs/en/tutorial/topics/testing.md:204
msgid "Test driven development"
msgstr "用測試來驅動開發"

#: docs/en/tutorial/topics/testing.md:206
msgid ""
"Now that we have a test suite, we can use it to drive the development of new"
" features. Let's modify our app to have a special greeting for one "
"particular user. We can start by adding a test case for the new behavior "
"that we'd like to see to the bottom of `test_app.py`:"
msgstr ""
"現在我們有了測試套件，我們可以用它來驅動新功能的開發。讓我們修改我們的應用程序，為某個特定用戶提供特殊的問候語。我們可以先為我們希望在 "
"`test_app.py` 底部看到的新行為新增一個測試案例:"

#: docs/en/tutorial/topics/testing.md:218
msgid "Then, run the test suite with this new test:"
msgstr "然後，使用這個新測試來執行測試套件："

#: docs/en/tutorial/topics/testing.md:324
msgid ""
"This time, we see a test failure - and the output explains the source of the"
" failure: the test is expecting the output \"BeeWare the IDEs of Python!\", "
"but our implementation of `greeting()` is returning \"Hello, Brutus\". Let's"
" modify the implementation of `greeting()` in `src/helloworld/app.py` to "
"have the new behavior:"
msgstr ""
"這次，我們看到測試失敗 - 輸出解釋了失敗的根源：測試期望輸出 `BeeWare the IDEs of Python!` ，但我們的 "
"`greeting()` 實現返回 `Hello, Brutus` 。讓我們修改 src/helloworld/app.py 中的 greeting()"
" 實作以獲得新的行為："

#: docs/en/tutorial/topics/testing.md:341
msgid "If we run the tests again, we'll now see our tests pass:"
msgstr "如果我們再次運行測試，我們現在將看到測試通過："

#: docs/en/tutorial/topics/testing.md:403
msgid "Runtime tests"
msgstr "運行時測試"

#: docs/en/tutorial/topics/testing.md:405
msgid ""
"So far, we've been running the tests in development mode. This is especially"
" useful when you're developing new features, as you can rapidly iterate on "
"adding tests, and adding code to make those tests pass. However, at some "
"point, you'll want to verify that your code also runs correctly when inside "
"the bundle app environment."
msgstr ""
"到目前為止，我們一直在開發模式下執行測試。當您開發新功能時，這特別有用，因為您可以快速迭代添加測試，並添加程式碼以使這些測試通過。但是，在某些時候，您需要驗證您的程式碼在部署的環境中是否也可以正確運行。"

#: docs/en/tutorial/topics/testing.md:411
msgid ""
"The `--test` and `-r` options can also be passed to the `run` command. If "
"you use `briefcase run --test -r`, the same test suite will run, but it will"
" run inside the packaged application bundle rather than your development "
"environment:"
msgstr ""
"`--test` 和 `-r` 選項也可以傳遞給 `run` 指令。如果您使用 `briefcase run --test -r` "
"，將運行相同的測試套件，但它將在部署的環境中運行，而不是在您的開發環境中運行："

#: docs/en/tutorial/topics/testing.md:534
msgid ""
"As with `briefcase dev --test`, the `-r` option is only needed the first "
"time you run the test suite to ensure that the test dependencies are "
"present. On subsequent runs, you can omit this option."
msgstr ""
"與 `briefcase dev --test` 一樣，僅在第一次執行測試套件時才需要 `-r` "
"選項，以確保測試依賴項存在。在後續運行中，您可以忽略此選項。"

#: docs/en/tutorial/topics/testing.md:538
msgid ""
"You can also use the `--test` option on mobile backends: - so `briefcase run"
" iOS --test` and `briefcase run android --test` will both work, running the "
"test suite on the mobile device you select."
msgstr ""
"您還可以在移動環境下使用 `--test` 選項： - 因此 `briefcase run iOS --test` 和 `briefcase run "
"android --test` 都可以工作，在您選擇的移動設備上運行測試套件。"

#: docs/en/tutorial/tutorial-0.md:1
#, fuzzy
msgid "Tutorial 0 - Let's get set up!"
msgstr "教學 0 - 讓我們開始設定吧！"

#: docs/en/tutorial/tutorial-0.md:3
msgid ""
"Before we build our first BeeWare app, we have to make sure we've got all "
"the prerequisites for running BeeWare."
msgstr "在建立第一個 BeeWare 應用程式之前，我們必須確保具備運行 BeeWare 的所有先決條件。"

#: docs/en/tutorial/tutorial-0.md:6
#, fuzzy
msgid "Install Python { id=\"install-python\" }"
msgstr "安裝 Python { id=\"install-python\" }"

#: docs/en/tutorial/tutorial-0.md:8
msgid "The first thing we'll need is a working Python interpreter."
msgstr "我們首先需要的是一個可用的 Python 直譯器。"

#: docs/en/tutorial/tutorial-0.md:12
#, fuzzy
msgid ""
"If you're on macOS, you can get an official Python installer from [the "
"Python website]{1}. You can use any version of Python from 3.10 or newer "
"(although you should avoid alphas, betas and release candidates). We "
"strongly recommend using Python 3.13 or newer."
msgstr ""
"如果您使用的是 Windows，則可以從 [Python 網站]{1} 取得官方安裝程式。您可以使用 3.8 及以上的任何穩定版本的 "
"Python。我們建議避免 alpha、beta 和候選版本，除非您 **真的** 知道自己在做什麼。"

#: docs/en/tutorial/tutorial-0.md:18
#, fuzzy
msgid ""
"You can also install Python through [Homebrew]{1}, use [pyenv]{2} to manage "
"multiple Python installs, or use [Anaconda]{3} or [Miniconda]{4}. It doesn't"
" matter *how* you've installed Python - it only matters that you can run "
"`python3` from your terminal and get a working, supported Python "
"interpreter."
msgstr ""
"安裝 Python 有很多不同的方法。您可以透過 [homebrew]{1} 安裝 Python。您可以使用 [pyenv]{2} "
"來管理同一台電腦上的多個 Python 安裝。 Windows 使用者可以從 Windows App Store 安裝 "
"Python。有數據科學背景的用戶可能希望使用 [Anaconda]{3} 或 [Miniconda]{4} 。"

#: docs/en/tutorial/tutorial-0.md:28
#, fuzzy
msgid ""
"Xcode and the Command-line Developer Tools provide a version of Python; "
"however that Python is version 3.9. Python 3.9 has reached end-of-life, and "
"is no longer supported by Python or BeeWare. You will *not* be able to the "
"Xcode-provided version of Python to run this tutorial."
msgstr ""
"Xcode 和 Command-line 開發者工具提供了 Python 版本，但該 Python 版本為 3.9。Python 3.9 "
"已經到了生命末期，Python 或 BeeWare 都不再支援。您將**無法使用 Xcode 提供的 Python 版本來執行本教學。"

#: docs/en/tutorial/tutorial-0.md:33
#, fuzzy
msgid ""
"To check the version of Python that you have installed, run the following "
"command:"
msgstr "若要檢查已安裝的 Python 版本，請執行下列指令："

#: docs/en/tutorial/tutorial-0.md:40
#, fuzzy
msgid "If Python is installed, you'll see its version number."
msgstr "如果已安裝 Python，您會看到它的版本號。"

#: docs/en/tutorial/tutorial-0.md:46
msgid ""
"If you're on Linux, you'll install Python using the system package manager "
"(`apt` on Debian/Ubuntu/Mint, `dnf` on Fedora, or `pacman` on Arch)."
msgstr ""
"如果您使用的是 Linux，則會使用系統套件管理器（Debian/Ubuntu/Mint 上的 `apt` 、Fedora 上的 `dnf` 或 "
"Arch 上的 `pacman` ）安裝 Python。"

#: docs/en/tutorial/tutorial-0.md:50
#, fuzzy
msgid ""
"You should ensure that the system Python is Python 3.10 or newer; if it "
"isn't (e.g., Ubuntu 20.04 ships with Python 3.8), you'll need to upgrade "
"your Linux distribution to something more recent."
msgstr ""
"您應該確保系統Python是Python 3.8或更高版本；如果不是（例如，Ubuntu 18.04 附帶 Python 3.6），則需要將 Linux"
" 發行版升級到更新的版本。"

#: docs/en/tutorial/tutorial-0.md:54
msgid "Support for Raspberry Pi is limited at this time."
msgstr "目前對 Raspberry Pi 的支援有限。"

#: docs/en/tutorial/tutorial-0.md:56
#, fuzzy
msgid ""
"**Important:** You *must* use the system Python provided by your operating "
"system. Alternative Python installations (pyenv, Anaconda, manually compiled"
" Python, etc.) will prevent you from successfully packaging your application"
" for distribution in later steps of this tutorial."
msgstr ""
"**重要：** 您**必須使用作業系統提供的系統 Python。其他 Python 安裝方式 (pyenv、Anaconda、手動編譯的 Python "
"等) 會讓您無法在本教學的後續步驟中成功將應用程式打包發行。"

#: docs/en/tutorial/tutorial-0.md:66
#, fuzzy
msgid ""
"If you're on Windows, you can get the official installer from [the Python "
"website]{1}. You can use any version of Python from 3.10 to 3.13 (although "
"you should avoid alphas, betas and release candidates). We strongly "
"recommend using Python 3.13."
msgstr ""
"如果您使用的是 Windows，則可以從 [Python 網站]{1} 取得官方安裝程式。您可以使用 3.8 及以上的任何穩定版本的 "
"Python。我們建議避免 alpha、beta 和候選版本，除非您 **真的** 知道自己在做什麼。"

#: docs/en/tutorial/tutorial-0.md:71
#, fuzzy
msgid "Support for Windows on ARM64 is limited at this time."
msgstr "目前對 Raspberry Pi 的支援有限。"

#: docs/en/tutorial/tutorial-0.md:73
#, fuzzy
msgid ""
"You can also install Python from the Windows App Store, or use [Anaconda]{1}"
" or [Miniconda]{2}. It doesn't matter *how* you've installed Python - it "
"only matters that you can run `python3` from your command prompt and get a "
"working, supported Python interpreter."
msgstr ""
"如果你在 macOS 或 Windows 上，你如何安裝 Python 並不重要 - 重要的是你可以從作業系統的命令提示字元/終端應用程式運行 "
"`python3` ，並獲得一個可用的 Python 直譯器。"

#: docs/en/tutorial/tutorial-0.md:82
#, fuzzy
msgid "Install dependencies { id=\"install-dependencies\" }"
msgstr "安裝依賴項目 { id=\"install-dependencies\" }"

#: docs/en/tutorial/tutorial-0.md:84
msgid ""
"Next, install the additional dependencies needed for your operating system:"
msgstr "接下來，安裝作業系統所需的其他依賴項："

#: docs/en/tutorial/tutorial-0.md:89
msgid "Building BeeWare apps on macOS requires:"
msgstr "在 macOS 上建立 BeeWare 應用程式需要："

#: docs/en/tutorial/tutorial-0.md:91
#, fuzzy
msgid ""
"**Git**, a version control system. This is included with Xcode or the "
"command line developer tools, which you installed above. You may need to "
"open Xcode for the first time in order for Git to work in your terminal "
"session. If it still doesn't register that Git is installed, you may need to"
" restart your terminal session."
msgstr ""
"**Git**，一個版本控制系統。它包含在您上面安裝的 Xcode 或命令列開發工具中。您可能需要首次打開 Xcode 才能讓 Git "
"在您的終端會話中運行。如果還是沒有註冊到 Git 已經安裝，您可能需要重新啟動您的終端會話。"

#: docs/en/tutorial/tutorial-0.md:101
msgid ""
"To support local development, you'll need to install some system packages. "
"The list of packages required varies depending on your distribution:"
msgstr "為了支援本地開發，您需要安裝一些系統軟體包。所需的軟體包清單因您的發行版而異："

#: docs/en/tutorial/tutorial-0.md:105
#, fuzzy
msgid "**Ubuntu / Debian**"
msgstr "**Ubuntu 20.04+ / Debian 10+**"

#: docs/en/tutorial/tutorial-0.md:112
msgid "**Fedora**"
msgstr "**Fedora**"

#: docs/en/tutorial/tutorial-0.md:118
#, fuzzy
msgid "**Arch / Manjaro**"
msgstr "**Arch, Manjaro**"

#: docs/en/tutorial/tutorial-0.md:124
#, fuzzy
msgid "**OpenSUSE Tumbleweed**"
msgstr "**OpenSUSE Tumbleweed**"

#: docs/en/tutorial/tutorial-0.md:134
msgid "Building BeeWare apps on Windows requires:"
msgstr "在 Windows 上建立 BeeWare 應用程式需要："

#: docs/en/tutorial/tutorial-0.md:136
#, fuzzy
msgid ""
"**Git**, a version control system. You can download Git from from {1}[git-"
"scm.com]{2}."
msgstr "**Git** ，版本控制系統。您可以從 [git-scm.com]{1} 下載 Git。"

#: docs/en/tutorial/tutorial-0.md:139
msgid ""
"After installing these tools, you should ensure you restart any terminal "
"sessions. Windows will only expose newly installed tools terminals started "
"*after* the install has completed."
msgstr "安裝這些工具後，您應該確保重新啟動所有終端會話。 Windows 只會公開安裝完成 *之後* 啟動的新安裝的工具終端。"

#: docs/en/tutorial/tutorial-0.md:145
msgid "Set up a virtual environment"
msgstr "設定虛擬環境"

#: docs/en/tutorial/tutorial-0.md:147
msgid ""
"We're now going to create a virtual environment - a \"sandbox\" that we can "
"use to isolate our work on this tutorial from our main Python installation. "
"If we install packages into the virtual environment, our main Python "
"installation (and any other Python projects on our computer) won't be "
"affected. If we make a complete mess of our virtual environment, we'll be "
"able to simply delete it and start again, without affecting any other Python"
" project on our computer, and without the need to re-install Python."
msgstr ""
"現在，我們將創建一個虛擬環境 - 一個 [沙箱` ，我們可以使用它來將本教程的工作與主 Python "
"安裝隔離。如果我們將套件安裝到虛擬環境中，我們的主要 Python 安裝（以及我們電腦上的任何其他 Python "
"專案）將不會受到影響。如果我們把虛擬環境弄得一團糟，我們只需刪除它並重新開始，就不會影響我們電腦上的任何其他 Python 項目，也不需要重新安裝 "
"Python。"

#: docs/en/tutorial/tutorial-0.md:187
#, fuzzy
msgid ""
"If you're not using Python 3.12, replace the `-3.12` in these instructions "
"with the version number that you are using."
msgstr "如果您使用的不是 Python 3.12，請將這些說明中的「-3.12」換成您正在使用的版本號碼。"

#: docs/en/tutorial/tutorial-0.md:190
#, fuzzy
msgid "/// admonition | Errors running PowerShell Scripts"
msgstr "/// admonition |執行 PowerShell 腳本的錯誤"

#: docs/en/tutorial/tutorial-0.md:192
msgid "If you're using PowerShell, and you receive the error:"
msgstr "如果您使用 PowerShell，並且收到錯誤:"

#: docs/en/tutorial/tutorial-0.md:198
msgid ""
"Your Windows account doesn't have permissions to run scripts. To fix this:"
msgstr "您的 Windows 帳戶沒有執行腳本的權限。要解決此問題："

#: docs/en/tutorial/tutorial-0.md:201
#, fuzzy
msgid "Run [Windows PowerShell as Administrator]{1}."
msgstr "以管理員身分執行 [Windows PowerShell]{1}。"

#: docs/en/tutorial/tutorial-0.md:202
msgid "Run `set-executionpolicy RemoteSigned`"
msgstr "運行 `set-executionpolicy RemoteSigned`"

#: docs/en/tutorial/tutorial-0.md:203
msgid "Select `Y` to change the execution policy."
msgstr "選擇 `Y` 更改執行策略。"

#: docs/en/tutorial/tutorial-0.md:205
msgid ""
"Once you've done this you can rerun `beeware-venv\\Scripts\\activate.ps1` in"
" your original PowerShell session (or a new session in the same directory)."
msgstr ""
"完成此操作後，您可以在原始 PowerShell 會話（或同一目錄中的新會話）中重新執行 `beeware-"
"venv\\Scripts\\activate.ps1` 。"

#: docs/en/tutorial/tutorial-0.md:213
msgid ""
"If this worked, your prompt should now be changed - it should have a "
"`(beeware-venv)` prefix. This lets you know that you're currently in your "
"BeeWare virtual environment. Whenever you're working on this tutorial, you "
"should make sure your virtual environment is activated. If it isn't, re-run "
"the last command (the `activate` command) to re-activate your environment."
msgstr ""
"如果這有效，你的提示現在應該改變 - 它應該有一個 `(beeware-venv)` 前綴。這可以讓您知道您目前處於 BeeWare "
"虛擬環境。每當您學習本教學時，您都應該確保您的虛擬環境已啟動。如果不是，請重新執行最後一個命令（ `activate` 命令）以啟動您的虛擬環境。"

#: docs/en/tutorial/tutorial-0.md:220
#, fuzzy
msgid "/// admonition | Alternative virtual environments"
msgstr "/// admonition |替代性虛擬環境"

#: docs/en/tutorial/tutorial-0.md:222
#, fuzzy
msgid ""
"If you're using Anaconda or miniconda, you may be more familiar with using "
"conda environments. You might also have heard of `virtualenv`, a predecessor"
" to Python's built in `venv` module. As with Python installs -if you're on "
"macOS or Windows, it doesn't matter *how* you create your virtual "
"environment, as long as you have one. If you're on Linux, you should stick "
"to `venv` and the system Python."
msgstr ""
"如果您正在使用 Anaconda 或 miniconda，您可能更熟悉使用 conda 環境。您可能也聽過 `virtualenv`，它是 Python"
" 內建的 `venv` 模組的前身。就像 Python 安裝一樣 - 如果您在 macOS 或 Windows "
"上，只要您有一個虛擬環境，以何種方式創建並不重要。如果您在 Linux 上，您應該堅持使用 `venv` 和系統 Python。"

#: docs/en/tutorial/tutorial-0.md:231 docs/en/tutorial/tutorial-1.md:258
#: docs/en/tutorial/tutorial-2.md:373 docs/en/tutorial/tutorial-3.md:597
#: docs/en/tutorial/tutorial-4.md:278
#: docs/en/tutorial/tutorial-5/android.md:408
#: docs/en/tutorial/tutorial-5/iOS.md:154 docs/en/tutorial/tutorial-6.md:174
#: docs/en/tutorial/tutorial-7.md:733 docs/en/tutorial/tutorial-8.md:375
msgid "Next steps"
msgstr "下一步"

#: docs/en/tutorial/tutorial-0.md:233
#, fuzzy
msgid ""
"We've now set up our environment. We're ready to [create our first BeeWare "
"application]{1}."
msgstr "我們現在已經設定好了我們的環境。我們準備好 [創建我們的第一個 BeeWare 應用程式<tutorial-1>[。"

#: docs/en/tutorial/tutorial-1.md:1
#, fuzzy
msgid "Tutorial 1 - Your first app"
msgstr "教學 1 - 您的第一個應用程式"

#: docs/en/tutorial/tutorial-1.md:3
msgid "We're ready to create our first application."
msgstr "我們已準備好創建我們的第一個應用程式。"

#: docs/en/tutorial/tutorial-1.md:5
msgid "Install the BeeWare tools"
msgstr "安裝 BeeWare 工具"

#: docs/en/tutorial/tutorial-1.md:7
#, fuzzy
msgid ""
"First, we need to install **Briefcase**. Briefcase is a BeeWare tool that "
"can be used to package your application for distribution to end users - but "
"it can also be used to bootstrap a new project. Make sure you're in the "
"`beeware-tutorial` directory you created in [Tutorial 0]{1}, with the "
"`beeware-venv` virtual environment activated, and run:"
msgstr ""
"首先，我們需要安裝 **Briefcase**。 它是一個 BeeWare 工具，可用於打包應用程式以分發給最終用戶 - "
"但它也可用於引導新專案。確保您位於 [教學 0]{1} 中建立的 `beeware-tutorial` 目錄中，啟動 `beeware-venv` "
"虛擬環境，然後執行："

#: docs/en/tutorial/tutorial-1.md:28 docs/en/tutorial/tutorial-1.md:44
#, fuzzy
msgid "/// admonition | Possible errors during installation"
msgstr "/// admonition |安裝時可能發生的錯誤"

#: docs/en/tutorial/tutorial-1.md:30
#, fuzzy
msgid ""
"If you see errors during installation, it's almost certainly because some of"
" the system requirements haven't been installed. Make sure you have "
"[installed all the platform pre-requisites][install-dependencies]."
msgstr ""
"如果您在安裝過程中看到錯誤，幾乎可以肯定是因為某些系統需求尚未安裝。請確定您已 [安裝所有平台先決條件][install-dependencies]。"

#: docs/en/tutorial/tutorial-1.md:46
msgid ""
"It is important that you use `python -m pip`, rather than a bare `pip`. "
"Briefcase needs to ensure that it has an up-to-date version of `pip` and "
"`setuptools`, and a bare invocation of `pip` can't self-update. If you want "
"to know more, [Brett Cannon has a detailed blog post about the issue]{1}."
msgstr ""
"使用 `python -m pip` ，而不是只有 `pip` ，這一點很重要。 Briefcase需要確保它有最新版本的 `pip` 和 "
"`setuptools` ，並且單純調用 `pip` 無法自我更新。如果您想了解更多信息，[Brett Cannon "
"有一篇關於該問題的詳細博客文章]{1} 。"

#: docs/en/tutorial/tutorial-1.md:56
msgid "Bootstrap a new project"
msgstr "開始一個新項目"

#: docs/en/tutorial/tutorial-1.md:58
#, fuzzy
msgid ""
"Let's start our first BeeWare project! We're going to use the Briefcase "
"`new` command to create an application called **Hello World**. Run the "
"following from your command prompt:"
msgstr ""
"讓我們開始第一個 BeeWare 專案！我們要使用 Briefcase `new` 指令來建立一個名為 **Hello World** "
"的應用程式。從您的命令提示符執行以下指令："

#: docs/en/tutorial/tutorial-1.md:86
msgid ""
"Briefcase will ask us for some details of our new application. For the "
"purposes of this tutorial, use the following:"
msgstr "Briefcase 將詢問我們新應用程式的一些詳細資訊。出於本教學的目的，請使用以下內容："

#: docs/en/tutorial/tutorial-1.md:89
msgid "**Formal Name** - Accept the default value: `Hello World`."
msgstr "**正式名稱** - 接受預設值： `Hello World` 。"

#: docs/en/tutorial/tutorial-1.md:90
msgid "**App Name** - Accept the default value: `helloworld`."
msgstr "**應用程式名稱** - 接受預設值： `helloworld` 。"

#: docs/en/tutorial/tutorial-1.md:91
#, fuzzy
msgid ""
"**Bundle Identifier** - If you own your own domain, enter that domain in "
"reversed order. (For example, if you own the domain \"cupcakes.com\", enter "
"`com.cupcakes` as the bundle). If you don't own your own domain, accept the "
"default bundle (`com.example`)."
msgstr ""
"**封裝名稱** - 如果您擁有自己的網域，請以相反的順序輸入該網域。 （例如，如果您擁有網域名稱 `cupcakes.com` ，請輸入 "
"`com.cupcakes` 作為捆綁包）。如果您不擁有自己的網域，請接受預設捆綁包（ `com.example` ）。"

#: docs/en/tutorial/tutorial-1.md:95
msgid "**Project Name** - Accept the default value: `Hello World`."
msgstr "**項目名稱** - 接受預設值： `Hello World` 。"

#: docs/en/tutorial/tutorial-1.md:96
msgid ""
"**Description** - Accept the default value (or, if you want to be really "
"creative, come up with your own description!)"
msgstr "**描述** - 接受預設值（或者，如果您想真正發揮創意，請提出您自己的描述！）"

#: docs/en/tutorial/tutorial-1.md:98
msgid "**Author** - Enter your own name here."
msgstr "**作者** - 在此輸入您自己的姓名。"

#: docs/en/tutorial/tutorial-1.md:99
#, fuzzy
msgid ""
"**Author's Email** - Enter your own email address. This will be used in the "
"configuration file, in help text, and anywhere that an email is required "
"when submitting the app to an app store."
msgstr "**作者的電子郵件** - 輸入您自己的電子郵件地址。這將用在設定檔、說明文字以及將應用程式提交到應用程式商店時需要電子郵件的任何地方。"

#: docs/en/tutorial/tutorial-1.md:102
#, fuzzy
msgid ""
"**Application URL** - The URL of the landing page for your application. "
"Again, if you own your own domain, enter a URL at that domain (including the"
" `https://`). Otherwise, just accept the default URL "
"(`https://example.com/helloworld`). This URL doesn't need to actually exist "
"(for now); it will only be used if you publish your application to an app "
"store."
msgstr ""
"**URL** - 您的應用程式的登入頁面的 URL。同樣，如果您擁有自己的網域，請輸入該網域的 URL（包括 `https://` "
"）。否則，只需接受預設 URL (`https://example.com/helloworld`)。該 URL "
"不需要實際存在（目前）；只有當您將應用程式發佈到應用程式商店時才會使用它。"

#: docs/en/tutorial/tutorial-1.md:108
#, fuzzy
msgid ""
"**Project License** - Accept the default license (BSD). This won't affect "
"anything about the operation of the tutorial, though - so if you have "
"particularly strong feelings about license choice, feel free to choose "
"another license."
msgstr ""
"**許可證** - 接受預設許可證 (BSD)。不過，這不會影響本教學的操作 - 因此，如果您對許可證選擇有特別強烈的感覺，請隨意選擇其他許可證。"

#: docs/en/tutorial/tutorial-1.md:112
msgid ""
"**GUI framework** - Accept the default option, Toga (BeeWare's own GUI "
"toolkit)."
msgstr "**GUI 框架** - 接受預設選項 Toga（BeeWare 自己的 GUI 工具）。"

#: docs/en/tutorial/tutorial-1.md:115
msgid ""
"Briefcase will then generate a project skeleton for you to use. If you've "
"followed this tutorial so far, and accepted the defaults as described, your "
"file system should look something like:"
msgstr "然後，Briefcase 將產生一個專案框架供您使用。如果您到目前為止已經遵循了本教學，並接受了所描述的預設設置，您的資料夾應該類似於："

#: docs/en/tutorial/tutorial-1.md:141
msgid ""
"This skeleton is actually a fully functioning application without adding "
"anything else. The `src` folder contains all the code for the application, "
"the `tests` folder contains an initial test suite, and the `pyproject.toml` "
"file describes how to package the application for distribution. If you open "
"`pyproject.toml` in an editor, you'll see the configuration details you just"
" provided to Briefcase."
msgstr ""
"這個框架實際上是一個功能齊全的應用程式，無需添加任何其他內容。 `src` 資料夾包含應用程式的所有程式碼， `tests` 資料夾包含初始測試套件， "
"`pyproject.toml` 檔案描述如何打包應用程式以進行分發。如果您在編輯器中開啟 `pyproject.toml` ，您將看到剛剛提供給 "
"`Briefcase` 的設定詳細資訊。"

#: docs/en/tutorial/tutorial-1.md:148
msgid ""
"Now that we have a stub application, we can use Briefcase to run the "
"application."
msgstr "現在我們有了一個未打包的應用程式，我們可以使用 Briefcase 來運行該應用程式。"

#: docs/en/tutorial/tutorial-1.md:151
msgid "Run the app in developer mode"
msgstr "在開發者模式下運行應用程式"

#: docs/en/tutorial/tutorial-1.md:153
msgid ""
"Move into the `helloworld` project directory and tell briefcase to start the"
" project in Developer (or `dev`) mode:"
msgstr "進入 `helloworld` 專案目錄並告訴公事包以開發人員（或 `dev` ）模式啟動專案："

#: docs/en/tutorial/tutorial-1.md:202 docs/en/tutorial/tutorial-2.md:332
msgid "This should open a GUI window:"
msgstr "這應該打開一個 GUI 視窗："

#: docs/en/tutorial/tutorial-1.md:206
#, fuzzy
msgid "![Hello World Tutorial 1 window, on macOS]{1}"
msgstr "![Hello World 教學 1 視窗，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-1.md:216
#, fuzzy
msgid "![Hello World Tutorial 1 window, on Linux]{1}"
msgstr "![Hello World 教學 1 視窗，在 Linux 上]{1}。"

#: docs/en/tutorial/tutorial-1.md:226
#, fuzzy
msgid "![Hello World Tutorial 1 window, on Windows]{1}"
msgstr "![Hello World 教學 1 視窗，在 Windows 上]{1}。"

#: docs/en/tutorial/tutorial-1.md:232
#, fuzzy
msgid "/// admonition | Invalid requirements or pip unable to connect"
msgstr "/// admonition |無效需求或 pip 無法連線"

#: docs/en/tutorial/tutorial-1.md:234
#, fuzzy
msgid "If you encounter the error:"
msgstr "如果遇到錯誤："

#: docs/en/tutorial/tutorial-1.md:242
#, fuzzy
msgid ""
"Confirm that you are running a [version of python that this tutorial "
"supports][install-python]."
msgstr "確認您正在執行 [本教學支援的 python 版本][install-python]。"

#: docs/en/tutorial/tutorial-1.md:245
#, fuzzy
msgid ""
"If your version of python is *not* a supported version, you will have to "
"restart the tutorial."
msgstr "如果您的 python 版本不是**支援的版本，您必須重新啟動教學。"

#: docs/en/tutorial/tutorial-1.md:252
#, fuzzy
msgid ""
"Close the application - either by pressing the close button on the "
"application window, by selecting Quit/Exit from the application's menu, or "
"by typing **Ctrl+C** in the terminal where you ran `briefcase dev` - and "
"you're done! Congratulations - you've just written a standalone, native "
"application in Python!"
msgstr "按下關閉按鈕（或從應用程式的選單中選擇退出），就完成了！恭喜 - 您剛剛用 Python 編寫了一個獨立的本機應用程式！"

#: docs/en/tutorial/tutorial-1.md:260
#, fuzzy
msgid ""
"We now have a working application, running in developer mode. Now we can add"
" some logic of our own to make our application do something a little more "
"interesting. In [Tutorial 2]{1}, we'll put a more useful user interface onto"
" our application."
msgstr ""
"我們現在有了一個可以運行的應用程序，在開發人員模式下運行。現在我們可以添加一些我們自己的邏輯，使我們的應用程式做一些更有趣的事情。在 :doc:`教程 "
"2 中<tutorial-2>`，我們將在我們的應用程式中放置一個更有用的使用者介面。"

#: docs/en/tutorial/tutorial-2.md:1
#, fuzzy
msgid "Tutorial 2 - Making it interesting"
msgstr "教學 2 - 讓它變得有趣"

#: docs/en/tutorial/tutorial-2.md:3
#, fuzzy
msgid ""
"In [Tutorial 1]{1}, we generated a stub project that was able to run, but we"
" didn't write any code ourselves. Let's take a look at what was generated "
"for us."
msgstr "在 [教程 1 中<tutorial-1>`，我們產生了一個能夠運行的存根項目，但我們自己沒有寫任何程式碼。讓我們看看為我們產生了什麼。"

#: docs/en/tutorial/tutorial-2.md:7
#, fuzzy
msgid "What was generated"
msgstr "生成了什麼"

#: docs/en/tutorial/tutorial-2.md:9
#, fuzzy
msgid ""
"In the `src/helloworld` directory, you should see 3 files: `__init__.py`, "
"`__main__.py` and `app.py`."
msgstr "在 src/helloworld 目錄中，您應該會看到 3 個檔案：__init__.py、__main__.py 和 app.py。"

#: docs/en/tutorial/tutorial-2.md:12
#, fuzzy
msgid ""
"`__init__.py` marks the `helloworld` directory as an importable Python "
"module. It is an empty file; the very fact it exists tells the Python "
"interpreter that the `helloworld` directory defines a module."
msgstr ""
"`__init__.py` 將`helloworld` 目錄標記為可匯入的Python 模組。這是一個空文件；它的存在告訴 Python "
"解釋器`helloworld`目錄定義了一個模組。"

#: docs/en/tutorial/tutorial-2.md:16
#, fuzzy
msgid ""
"`__main__.py` marks the `helloworld` module as a special kind of module -an "
"executable module. If you try to run the `helloworld` module using `python "
"-m helloworld`, the `__main__.py` file is where Python will start executing."
" The contents of `__main__.py` is relatively simple:"
msgstr ""
"`__main__.py` 將 `helloworld` 模組標示為一種特殊的模組 - 一個可執行的模組。如果您嘗試使用 `python -m "
"helloworld` 來執行 `helloworld` 模組，`__main__.py`檔就是 Python "
"開始執行的地方。`__main__.py` 的內容相對簡單："

#: docs/en/tutorial/tutorial-2.md:28
#, fuzzy
msgid "This file does two things:"
msgstr "此檔案有兩項功能："

#: docs/en/tutorial/tutorial-2.md:30
#, fuzzy
msgid "It imports the `main` method from the `helloworld` app."
msgstr "它從 `helloworld` 應用程式導入 `main` 方法。"

#: docs/en/tutorial/tutorial-2.md:31
#, fuzzy
msgid ""
"Then, it starts the application’s main loop. The main loop is the way a GUI "
"application listens for user input (like mouse clicks and keyboard presses)."
msgstr ""
"也就是說 - 它從`helloworld`應用程式導入`main`方法；如果它是作為入口點執行，則呼叫 main() "
"方法，並啟動應用程式的主循環。主循環是 GUI 應用程式偵聽使用者輸入（如滑鼠點擊和鍵盤按下）的方式。"

#: docs/en/tutorial/tutorial-2.md:35
#, fuzzy
msgid ""
"The more interesting file is `app.py` - this contains the logic that creates"
" our application window:"
msgstr "更有趣的檔案是`app.py`——它包含創建我們的應用程式視窗的邏輯:"

#: docs/en/tutorial/tutorial-2.md:54
#, fuzzy
msgid "Let's go through this line by line:"
msgstr "讓我們逐行瀏覽一下："

#: docs/en/tutorial/tutorial-2.md:61
#, fuzzy
msgid ""
"First, we import the `toga` widget toolkit, as well as some style-related "
"utility constants. Our code doesn't use these yet - but we'll make use of "
"them shortly."
msgstr "首先，我們匯入`toga`小工具工具包，以及一些與樣式相關的實用程式類別和常數。我們的程式碼尚未使用它們 - 但我們很快就會使用它們。"

#: docs/en/tutorial/tutorial-2.md:65
#, fuzzy
msgid "Then, we define a class:"
msgstr "然後，我們定義一個類別：："

#: docs/en/tutorial/tutorial-2.md:71
#, fuzzy
msgid ""
"Each Toga application has a single `toga.App` instance, representing the "
"running entity that is the application. The app may end up managing multiple"
" windows; but for simple applications, there will be a single main window."
msgstr ""
"每個 Toga "
"應用程式都有一個`toga.App`實例，代表應用程式的運作實體。該應用程式最終可能會管理多個視窗；但對於簡單的應用程序，將有一個主視窗。"

#: docs/en/tutorial/tutorial-2.md:76
#, fuzzy
msgid "Next, we define a `startup()` method:"
msgstr "接下來，我們定義一個`startup()`方法："

#: docs/en/tutorial/tutorial-2.md:83
#, fuzzy
msgid ""
"The first thing the startup method does is to define a main box. Toga's "
"layout scheme behaves similar to HTML. You build an application by "
"constructing a collection of boxes, each of which contains other boxes, or "
"actual widgets. You then apply styles to these boxes to define how they will"
" consume the available window space."
msgstr ""
"啟動方法所做的第一件事是定義一個主框。 Toga 的佈局方案的行為與 HTML "
"類似。您可以透過建立一組框來建立應用程序，每個框都包含其他框或實際的小部件。然後，您可以將樣式套用到這些方塊來定義它們將如何使用可用的視窗空間。"

#: docs/en/tutorial/tutorial-2.md:89
#, fuzzy
msgid ""
"In this application, we define a single box, but we don't put anything into "
"it."
msgstr "在此應用程式中，我們定義了一個框，但沒有在其中放入任何內容。"

#: docs/en/tutorial/tutorial-2.md:92
#, fuzzy
msgid "Next, we define a window into which we can put this empty box:"
msgstr "接下來，我們定義一個窗口，可以將這個空框放入其中："

#: docs/en/tutorial/tutorial-2.md:98
#, fuzzy
msgid ""
"This creates an instance of a `toga.MainWindow`, which will have a title "
"matching the application's name. A Main Window is a special kind of window "
"in Toga - it's a window that is closely bound to the life cycle of the app. "
"When the Main Window is closed, the application exits. The Main Window is "
"also the window that has the application's menu (if you're on a platform "
"like Windows where menu bars are part of the window)."
msgstr ""
"這將建立一個`toga.MainWindow`實例，它將具有與應用程式名稱相符的標題。主視窗是 Toga 中的一種特殊視窗 - "
"它是與應用程式的生命週期密切相關的視窗。當主視窗關閉時，應用程式退出。主視窗也是具有應用程式選單的視窗（如果您使用的是 Windows "
"等平台，其中功能表列是視窗的一部分）"

#: docs/en/tutorial/tutorial-2.md:106
#, fuzzy
msgid "/// admonition | Where is my window?"
msgstr "/// admonition |我的窗戶在哪裡？"

#: docs/en/tutorial/tutorial-2.md:108
#, fuzzy
msgid ""
"If you have made an error in your code, the main window of the app may not "
"display. If this happens, you can type **Ctrl+C** in the terminal where you "
"started the app. This will stop the app. You can then fix the error and "
"restart the app."
msgstr ""
"如果您的程式碼出錯，應用程式的主視窗可能無法顯示。如果發生這種情況，您可以在啟動應用程式的終端輸入 "
"**Ctrl+C**。這將會停止應用程式。然後您可以修正錯誤並重啟程式。"

#: docs/en/tutorial/tutorial-2.md:115
#, fuzzy
msgid ""
"We then add our empty box as the content of the main window, and instruct "
"the application to show our window:"
msgstr "然後，我們添加空框作為主視窗的內容，並指示應用程式顯示我們的視窗:"

#: docs/en/tutorial/tutorial-2.md:123
msgid ""
"Last of all, we define a `main()` function. This is what creates the "
"instance of our application:"
msgstr "最後，我們定義一個`main()`方法。這就是創建我們的應用程式實例的原因:"

#: docs/en/tutorial/tutorial-2.md:131
#, fuzzy
msgid ""
"This `main()` method is the one that is imported and invoked by "
"`__main__.py`. It creates and returns an instance of our `HelloWorld` "
"application."
msgstr "這個`main()`方法是由`__main__.py`導入和呼叫的方法。它創建並傳回我們的`HelloWorld`應用程式的實例。"

#: docs/en/tutorial/tutorial-2.md:135
#, fuzzy
msgid ""
"That's the simplest possible Toga application. Let's put some of our own "
"content into the application, and make the app do something interesting."
msgstr "這是最簡單的 Toga 應用程式。讓我們將一些我們自己的內容放入應用程式中，並使應用程式做一些有趣的事情。"

#: docs/en/tutorial/tutorial-2.md:138
#, fuzzy
msgid "Adding some content of our own"
msgstr "添加一些我們自己的內容"

#: docs/en/tutorial/tutorial-2.md:140
#, fuzzy
msgid "Let's do something more interesting with our `HelloWorld` app."
msgstr "讓我們用 `HelloWorld` 應用程式來做一些更有趣的事。"

#: docs/en/tutorial/tutorial-2.md:144
#, fuzzy
msgid ""
"When you make these changes, make sure you keep the imports at the top of "
"the file, and the `main()` at the bottom of the file. You only need to "
"update the `HelloWorld` class."
msgstr "不要刪除文件頂部的導入或底部的`main()`。您只需要更新`HelloWorld`類別。"

#: docs/en/tutorial/tutorial-2.md:150
#, fuzzy
msgid ""
"Modify your `HelloWorld` class inside `src/helloworld/app.py` so that it "
"looks like this:"
msgstr "修改`src/helloworld/app.py`中的`HelloWorld`類，使其看起來像這樣:"

#: docs/en/tutorial/tutorial-2.md:185
#, fuzzy
msgid "Let's look in detail at what has changed."
msgstr "讓我們詳細看看發生了什麼變化。"

#: docs/en/tutorial/tutorial-2.md:187
#, fuzzy
msgid "We're still creating a main box; however, we are now applying a style:"
msgstr "我們仍在創建一個主盒子；然而，我們現在正在應用一種風格:"

#: docs/en/tutorial/tutorial-2.md:193
#, fuzzy
msgid ""
"Toga's built-in layout system is called \"Pack\". It behaves a lot like CSS."
" You define objects in a hierarchy - in HTML, the objects are `<div>`, "
"`<span>`, and other DOM elements; in Toga, they're widgets and boxes. You "
"can then assign styles to the individual elements. In this case, we're "
"indicating that this is a `COLUMN` box - that is, it is a box that will "
"consume all the available width, and will expand its height as content is "
"added, but it will try to be as short as possible."
msgstr ""
"Toga 的內建佈局系統稱為`Pack`。它的行為很像 CSS。您可以在層次結構中定義物件 - 在 HTML "
"中，物件是`<div>`、`][span]` 和其他 DOM 元素；在 Toga "
"中，它們是小部件和盒子。然後，您可以為各個元素指定樣式。在這種情況下，我們表明這是一個`COLUMN`框 - "
"也就是說，它是一個將消耗所有可用寬度的框，並且會在添加內容時擴展其高度，但它會嘗試盡可能短。</span>"

#: docs/en/tutorial/tutorial-2.md:203
#, fuzzy
msgid ""
"For more advanced uses, Toga also supports a separate style object, which is"
" used like this:"
msgstr "對於更進階的用途，Toga 也支援獨立的樣式物件，使用方式如下："

#: docs/en/tutorial/tutorial-2.md:213
msgid "Next, we define a couple of widgets:"
msgstr "接下來，我們定義幾個小工具:"

#: docs/en/tutorial/tutorial-2.md:223
#, fuzzy
msgid ""
"Here, we define a Label and a TextInput. Both widgets have styles associated"
" with them; the label will have 5px of margin on its left and right, and no "
"margin on the top and bottom. The TextInput is marked as being flexible - "
"that is, it will absorb all available space in its layout axis."
msgstr ""
"在這裡，我們定義了一個 Label 和一個 TextInput。這兩個小部件都有與之相關的樣式；標籤的左側和右側將有 5 "
"個像素的內邊距，頂部和底部將沒有內邊距。 TextInput 被標記為靈活的 - 也就是說，它將吸收其佈局軸中的所有可用空間。"

#: docs/en/tutorial/tutorial-2.md:229
#, fuzzy
msgid ""
"The TextInput is assigned as an instance variable of the class. This gives "
"us easy access to the widget instance - something that we'll use in a "
"moment."
msgstr "TextInput 被指定為該類別的實例變數。這使我們可以輕鬆存取小部件實例 - 我們稍後將使用它。"

#: docs/en/tutorial/tutorial-2.md:233
#, fuzzy
msgid "Next, we define a box to hold these two widgets:"
msgstr "接下來，我們定義一個盒子來容納這兩個小工具："

#: docs/en/tutorial/tutorial-2.md:241
#, fuzzy
msgid ""
"The `name_box` is a box just like the main box; however, this time, it's a "
"`ROW` box. That means content will be added horizontally, and it will try to"
" make its width as narrow as possible. The box also has some margin - 5px on"
" all sides."
msgstr ""
"`name_box` "
"是一個像主盒子一樣的盒子；然而，這一次，它是一個`ROW`盒子。這意味著內容將水平添加，並且它將嘗試使其寬度盡可能窄。盒子還有一些內邊距 - 所有邊都是"
" 5px。"

#: docs/en/tutorial/tutorial-2.md:246
#, fuzzy
msgid "Now we define a button:"
msgstr "現在我們定義一個按鈕:"

#: docs/en/tutorial/tutorial-2.md:256
#, fuzzy
msgid ""
"The button also has 5px of margin on all sides. We also define a *handler* -"
" a method to invoke when the button is pressed."
msgstr "按鈕的四邊也有 5px 的邊距。我們也定義了一個 *handler* - 按鈕被按下時要呼叫的方法。"

#: docs/en/tutorial/tutorial-2.md:259
#, fuzzy
msgid "Then, we add the name box and the button to the main box:"
msgstr "然後，我們將名稱框和按鈕新增到主框："

#: docs/en/tutorial/tutorial-2.md:266
#, fuzzy
msgid ""
"This completes our layout; the rest of the startup method is as it was "
"previously - defining a `MainWindow`, and assigning the main box as the "
"window's content:"
msgstr "這樣就完成了我們的佈局；啟動方法的其餘部分與之前一樣 - 定義一個 MainWindow，並將主框指定為視窗的內容:"

#: docs/en/tutorial/tutorial-2.md:276
#, fuzzy
msgid ""
"The last thing we need to do is define the handler for the button. A handler"
" can be any method, generator, or asynchronous coroutine; it accepts the "
"widget that generated the event as an argument, and will be invoked whenever"
" the button is pressed:"
msgstr ""
"我們需要做的最後一件事是定義按鈕的處理程序。處理程序可以是任何方法、生成器或非同步協程；它接受生成事件的小部件作為參數，並且每當按下按鈕時就會調用:"

#: docs/en/tutorial/tutorial-2.md:286
#, fuzzy
msgid ""
"The body of the method is a simple print statement - however, it will "
"interrogate the current value of the name input, and use that content as the"
" text that is printed."
msgstr "該方法的主體是一個簡單的列印語句 - 但是，它將詢問名稱輸入的當前值，並使用該內容作為列印的文字。"

#: docs/en/tutorial/tutorial-2.md:290
#, fuzzy
msgid ""
"Now that we've made these changes we can see what they look like by starting"
" the application again. As before, we'll use developer mode:"
msgstr "現在我們已經進行了這些更改，我們可以透過再次啟動應用程式來查看它們的外觀。和以前一樣，我們將使用開發者模式："

#: docs/en/tutorial/tutorial-2.md:326
#, fuzzy
msgid ""
"You'll notice that this time, it *doesn't* install dependencies. Briefcase "
"can detect that the application has been run before, and to save time, will "
"only run the application. If you add new dependencies to your app, you need "
"to make sure that they're installed by passing in a `-r` option when you run"
" `briefcase dev`."
msgstr ""
"您會注意到，這一次，它`不`安裝依賴項。公文包可以檢測到該應用程式之前已經運行過，為了節省時間，只會運行該應用程式。如果您為應用程式新增的依賴項，則可以在執行`briefcase"
" dev`時傳入`-r`選項來確保它們已安裝。"

#: docs/en/tutorial/tutorial-2.md:336
#, fuzzy
msgid "![Hello World Tutorial 2 window, on macOS]{1}"
msgstr "![Hello World 教學 2 視窗，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-2.md:346
#, fuzzy
msgid "![Hello World Tutorial 2 window, on Linux]{1}"
msgstr "![Hello World 教學 2 視窗，在 Linux 上]{1}。"

#: docs/en/tutorial/tutorial-2.md:356
#, fuzzy
msgid "![Hello World Tutorial 2 window, on Windows]{1}"
msgstr "![Hello World 教學 2 視窗，在 Windows 上]{1}。"

#: docs/en/tutorial/tutorial-2.md:364
#, fuzzy
msgid ""
"If you enter a name in the text box, and press the GUI button, you should "
"see output appear in the console where you started the application."
msgstr "如果您在文字方塊中輸入名稱，然後按 GUI 按鈕，您應該會看到啟動應用程式的控制台中出現輸出。"

#: docs/en/tutorial/tutorial-2.md:368
#, fuzzy
msgid ""
"Before continuing, close the app. As with Tutorial 1, you can do this by "
"pressing the close button on the application window, by selecting Quit/Exit "
"from the application's menu, or by typing **Ctrl+C** in the terminal where "
"you ran `briefcase dev`."
msgstr ""
"繼續之前，請關閉應用程式。與教學 1 一樣，您可以按下應用程式視窗的關閉按鈕、從應用程式的功能表中選擇 Quit/Exit，或在執行 "
"`briefcase dev` 的終端機中輸入 **Ctrl+C**。"

#: docs/en/tutorial/tutorial-2.md:375
#, fuzzy
msgid ""
"We've now got an application that does something a little more interesting. "
"But it only runs on our own computer. Let's package this application for "
"distribution. In [Tutorial 3]{1}, we'll wrap our application up as a "
"standalone installer that we could send to a friend, a customer, or upload "
"to an App Store."
msgstr ""
"我們現在有了一個可以做一些更有趣的事情的應用程式。但它只能在我們自己的計算機上運行。讓我們打包這個應用程式以進行分發。在 :doc:`教程 3 "
"中<tutorial-3>`，我們將把我們的應用程式打包為一個獨立的安裝程序，我們可以將其發送給朋友、客戶，或上傳到應用程式商店。"

#: docs/en/tutorial/tutorial-3.md:1
#, fuzzy
msgid "Tutorial 3 - Packaging for distribution"
msgstr "教學 3 - 分發包裝"

#: docs/en/tutorial/tutorial-3.md:3
#, fuzzy
msgid ""
"So far, we've been running our application in \"Developer mode\". This makes"
" it easy for us to run our application locally - but what we really want is "
"to be able to give our application to others."
msgstr ""
"到目前為止，我們一直在`開發人員模式`下運行我們的應用程式。這使我們可以輕鬆地在本地運行我們的應用程式 - "
"但我們真正想要的是能夠將我們的應用程式提供給其他人。"

#: docs/en/tutorial/tutorial-3.md:7
#, fuzzy
msgid ""
"However, we don't want to have to teach our users how to install Python, "
"create a virtual environment, clone a git repository, and run Briefcase in "
"developer mode. We'd rather just give them an installer, and have the "
"application Just Work."
msgstr ""
"但是，我們不想教導使用者如何安裝 Python、建立虛擬環境、複製 git 儲存庫以及在開發人員模式下執行 "
"Briefcase。我們寧願只給他們一個安裝程序，然後讓應用程式正常工作。"

#: docs/en/tutorial/tutorial-3.md:12
#, fuzzy
msgid ""
"Briefcase can be used to package your application for distribution in this "
"way."
msgstr "公文包可用於打包您的應用程式以透過這種方式進行分發。"

#: docs/en/tutorial/tutorial-3.md:15
#, fuzzy
msgid "Creating your application scaffold"
msgstr "創建您的應用程式支架"

#: docs/en/tutorial/tutorial-3.md:17
#, fuzzy
msgid ""
"Since this is the first time we're packaging our application, we need to "
"create some configuration files and other scaffolding to support the "
"packaging process. From the `helloworld` directory, run:"
msgstr "由於這是我們第一次打包應用程序，因此我們需要創建一些配置文件和其他腳手架來支援打包過程。從`helloworld`目錄中，運行："

#: docs/en/tutorial/tutorial-3.md:83
#, fuzzy
msgid "/// admonition | Errors about Python versions"
msgstr "/// admonition |有關 Python 版本的錯誤"

#: docs/en/tutorial/tutorial-3.md:85
#, fuzzy
msgid "If you receive an error that reads something like:"
msgstr "如果您收到類似以下的錯誤："

#: docs/en/tutorial/tutorial-3.md:87
#, fuzzy
msgid ""
"The version of Python being used to run Briefcase (3.12) is not the system "
"python3 (3.10)."
msgstr "執行 Briefcase 所使用的 Python 版本 (3.12) 並非系統 python3 (3.10)。"

#: docs/en/tutorial/tutorial-3.md:90
#, fuzzy
msgid ""
"You will need to recreate your virtual environment using the system "
"`python3`. Using the system Python is a requirement for packaging your "
"application."
msgstr "您需要使用系統 `python3`重新建立虛擬環境。使用系統 Python 是打包應用程式的必要條件。"

#: docs/en/tutorial/tutorial-3.md:124
#, fuzzy
msgid ""
"You've probably just seen pages of content go past in your terminal... so "
"what just happened? Briefcase has done the following:"
msgstr "您可能剛剛在終端機中看到了內容頁面……那麼剛剛發生了什麼？公事包做了以下事情："

#: docs/en/tutorial/tutorial-3.md:127
#, fuzzy
msgid ""
"It **generated an application template**. There's a lot of files and "
"configurations required to build a native installer, above and beyond the "
"code of your actual application. This extra scaffolding is almost the same "
"for every application on the same platform, except for the name of the "
"actual application being constructed - so Briefcase provides an application "
"template for each platform it supports. This step rolls out the template, "
"substituting the name of your application, bundle ID, and other properties "
"of your configuration file as required to support the platform you're "
"building on."
msgstr ""
"它**生成了一個應用程式模板**。建立本機安裝程式需要大量檔案和配置，超出了實際應用程式的程式碼。對於同一平台上的每個應用程式來說，這個額外的腳手架幾乎都是相同的，除了正在構建的實際應用程式的名稱之外-"
" 因此，Briefcase 為其支援的每個平台提供了一個應用程式模板。此步驟將推出模板，根據需要替換應用程式的名稱、捆綁 ID "
"和設定檔的其他屬性，以支援您正在建置的平台。"

#: docs/en/tutorial/tutorial-3.md:127
#, fuzzy
msgid ""
"If you're not happy with the template provided by Briefcase, you can provide"
" your own. However, you probably don't want to do this until you've got a "
"bit more experience using Briefcase's default template."
msgstr "如果您對公文包提供的範本不滿意，您可以提供自己的範本。但是，在使用公文包的預設範本有更多經驗之前，您可能不想這樣做。"

#: docs/en/tutorial/tutorial-3.md:142
#, fuzzy
msgid ""
"It **downloaded and installed a support package**. The packaging approach "
"taken by Briefcase is best described as \"the simplest thing that could "
"possibly work\" - it ships a complete, isolated Python interpreter as part "
"of every application it builds (except for Linux native system package "
"builds). This is slightly space inefficient - if you have 5 applications "
"packaged with Briefcase, you'll have 5 copies of the Python interpreter. "
"However, this approach guarantees that every application is completely "
"independent, using a specific version of Python that is known to work with "
"the application."
msgstr ""
"它**下載並安裝了支援包**。公事包採用的打包方法最好被描述為`可能有效的最簡單的方法`——它提供了一個完整的、獨立的 Python "
"解釋器，作為它構建的每個應用程式的一部分。這在空間效率方面稍顯低下 - 如果您有 5 個使用 Briefcase 打包的應用程序，那麼您將擁有 5 個 "
"Python 解釋器副本。然而，這種方法保證每個應用程式都是完全獨立的，使用已知可與該應用程式配合使用的特定 Python 版本。"

#: docs/en/tutorial/tutorial-3.md:142
#, fuzzy
msgid ""
"Again, Briefcase provides a default support package for each platform; if "
"you want, you can provide your own support package, and have that package "
"included as part of the build process. You may want to do this if you have "
"particular options in the Python interpreter that you need to have enabled, "
"or if you want to strip modules out of the standard library that you don't "
"need at runtime."
msgstr ""
"同樣，Briefcase 為每個平台提供了預設的支援包；如果需要，您可以提供自己的支援包，並將該包包含在建置過程中。如果您需要啟用 Python "
"解釋器中的特定選項，或者想要從標準庫中刪除執行時間不需要的模組，您可能需要執行此操作。"

#: docs/en/tutorial/tutorial-3.md:142
#, fuzzy
msgid ""
"Briefcase maintains a local cache of support packages, so once you've "
"downloaded a specific support package, that cached copy will be used on "
"future builds."
msgstr "公文包維護支援包的本機緩存，因此一旦您下載了特定的支援包，該快取的副本將在未來的版本中使用。"

#: docs/en/tutorial/tutorial-3.md:142
#, fuzzy
msgid ""
"As noted above, when Briefcase packages an app as a native Linux system "
"package (the default package format for Linux), a support package is not "
"included with the app. Instead, the app will use the Python that is provided"
" by the distribution of Linux being targeted."
msgstr ""
"如上所述，當 Briefcase 將應用程式打包為原生 Linux 系統套件 (Linux 的預設套件格式) "
"時，該應用程式不會包含支援套件。相反，應用程式會使用目標 Linux 發行版所提供的 Python。"

#: docs/en/tutorial/tutorial-3.md:168
#, fuzzy
msgid ""
"It **installed application requirements**. Your application can specify any "
"third-party modules that are required at runtime. These will be installed "
"using `pip` into your application's installer."
msgstr "它**安裝了應用程式要求**。您的應用程式可以指定運行時所需的任何第三方模組。這些將使用`pip`安裝到應用程式的安裝程式中。"

#: docs/en/tutorial/tutorial-3.md:172
#, fuzzy
msgid ""
"It **Installed your application code**. Your application will have its own "
"code and resources (e.g., images that are needed at runtime); these files "
"are copied into the installer."
msgstr "它**安裝了您的應用程式代碼**。您的應用程式將擁有自己的程式碼和資源（例如，運行時所需的映像）；這些檔案被複製到安裝程式中。"

#: docs/en/tutorial/tutorial-3.md:176
#, fuzzy
msgid ""
"It **installed your resources needed by your application.** Lastly, it adds "
"any additional resources that are needed by the installer itself. This "
"includes things like icons that need to be attached to the final application"
" and splash screen images."
msgstr ""
"它 **安裝了應用程式所需的資源。** 最後，它添加了安裝程式本身所需的任何其他資源。這包括需要附加到最終應用程式的圖示和啟動螢幕圖像等內容。"

#: docs/en/tutorial/tutorial-3.md:181
#, fuzzy
msgid ""
"Once this completes, if you look in the project directory, you should now "
"see a directory corresponding to your platform (`macOS`, `linux`, or "
"`windows`) that contains additional files. This is the platform-specific "
"packaging configuration for your application."
msgstr ""
"完成後，如果您查看專案目錄，您現在應該會看到與您的平台（`macOS`、`linux`或`windows`）相對應的目錄，其中包含其他檔案。這是您的應用程式的特定於平台的打包配置。"

#: docs/en/tutorial/tutorial-3.md:186
#, fuzzy
msgid "Building your application"
msgstr "建立您的應用程式"

#: docs/en/tutorial/tutorial-3.md:188
#, fuzzy
msgid ""
"You can now compile your application. This step performs any binary "
"compilation that is necessary for your application to be executable on your "
"target platform."
msgstr "現在您可以編譯您的應用程式。此步驟執行應用程式在目標平台上可執行所需的任何二進位編譯。"

#: docs/en/tutorial/tutorial-3.md:205
#, fuzzy
msgid ""
"On macOS, the `build` command doesn't need to *compile* anything, but it "
"does need to sign the contents of binary so that it can be executed. This "
"signature is an *ad hoc* signature - it will only work on *your* machine; if"
" you want to distribute the application to others, you'll need to provide a "
"full signature."
msgstr ""
"在 macOS 上，`build` 命令不需要 *編譯* 任何內容，但它確實需要對二進位內容進行簽名，以便可以執行。此簽名是 *臨時* 簽名 - "
"它僅適用於 *您的* 機器；如果您想將應用程式分發給其他人，則需要提供完整的簽名。"

#: docs/en/tutorial/tutorial-3.md:239
#, fuzzy
msgid ""
"Once this step completes, the `build` folder will contain a "
"`helloworld-0.0.1` folder that contains a mirror of a Linux `/usr` file "
"system. This file system mirror will contain a `bin` folder with a "
"`helloworld` binary, plus `lib` and `share` folders needed to support the "
"binary."
msgstr ""
"此步驟完成後，`build`資料夾將包含一個`helloworld-0.0.1`資料夾，其中包含 "
"Linux`/usr`檔案系統的鏡像。該檔案系統鏡像將包含一個包含`helloworld`二進位檔案的`bin`資料夾，以及支援該二進位檔案所需的`lib`和`share`資料夾。"

#: docs/en/tutorial/tutorial-3.md:256
#, fuzzy
msgid ""
"On Windows, the `build` command doesn't need to *compile* anything, but it "
"does need to write some metadata so that the application knows its name, "
"version, and so on."
msgstr "在 Windows 上，`build` 命令不需要 *編譯* 任何內容，但它確實需要編寫一些元數據，以便應用程式知道其名稱、版本等。"

#: docs/en/tutorial/tutorial-3.md:260
#, fuzzy
msgid "/// admonition | Triggering antivirus"
msgstr "/// admonition |觸發防毒軟體"

#: docs/en/tutorial/tutorial-3.md:262
#, fuzzy
msgid ""
"Since this metadata is being written directly in to the pre-compiled binary "
"rolled out from the template during the `create` command, this may trigger "
"antivirus software running on your machine and prevent the metadata from "
"being written. In that case, instruct the antivirus to allow the tool (named"
" `rcedit-x64.exe`) to run and re-run the command above."
msgstr ""
"由於此元資料在`create`命令期間直接寫入從範本推出的預編譯二進位檔案中，因此這可能會觸發電腦上執行的防毒軟體並阻止寫入元資料。在這種情況下，指示防毒軟體允許該工具（名為`rcedit-x64.exe`）運行並重新執行上述命令。"

#: docs/en/tutorial/tutorial-3.md:273
#, fuzzy
msgid "Running your app"
msgstr "運行您的應用程式"

#: docs/en/tutorial/tutorial-3.md:275
#, fuzzy
msgid "You can now use Briefcase to run your application:"
msgstr "現在您可以使用 Briefcase 來運行您的應用程式："

#: docs/en/tutorial/tutorial-3.md:354
#, fuzzy
msgid ""
"This will start to run your native application, using the app bundle created"
" by the `build` command."
msgstr "這將開始使用`build`命令的輸出來執行您的本機應用程式。"

#: docs/en/tutorial/tutorial-3.md:357
#, fuzzy
msgid ""
"You might notice some small differences in the way your application looks "
"when it's running. For example, icons and the name displayed by the "
"operating system may be slightly different to those you saw when running "
"under developer mode. This is also because you're using the packaged "
"application, not just running Python code. From the operating system's "
"perspective, you're now running \"an app\", not \"a Python program\", and "
"this is reflected in how the application appears."
msgstr ""
"您可能會注意到應用程式運行時的外觀存在一些細微的差異。例如，作業系統顯示的圖示和名稱可能與您在開發人員模式下運行時看到的圖示略有不同。這也是因為您正在使用打包的應用程序，而不僅僅是運行"
" Python 程式碼。從作業系統的角度來看，您現在運行的是`應用程式`，而不是`Python 程式`，這反映在應用程式的顯示方式上。"

#: docs/en/tutorial/tutorial-3.md:365
#, fuzzy
msgid ""
"Before continuing, close the app. As with previous tutorial steps, you can "
"do this by pressing the close button on the application window, by selecting"
" Quit/Exit from the application's menu, or by typing **Ctrl+C** in the "
"terminal where you ran `briefcase run`."
msgstr ""
"繼續之前，請關閉應用程式。與之前的教學步驟一樣，您可以按下應用程式視窗上的關閉按鈕、從應用程式的功能表中選擇 "
"Quit/Exit，或在執行「briefcase run」的終端輸入 **Ctrl+C**。"

#: docs/en/tutorial/tutorial-3.md:370
#, fuzzy
msgid "Building your installer"
msgstr "建立您的安裝程式"

#: docs/en/tutorial/tutorial-3.md:372
#, fuzzy
msgid ""
"You can now package your application for distribution, using the `package` "
"command. The package command does any compilation that is required to "
"convert the scaffolded project into a final, distributable product. "
"Depending on the platform, this may involve compiling an installer, "
"performing code signing, or doing other pre-distribution tasks."
msgstr ""
"現在，您可以使用`package`命令打包您的應用程式以進行分發。 package "
"命令執行將鷹架專案轉換為最終的可分發產品所需的任何編譯。根據平台的不同，這可能涉及編譯安裝程式、執行程式碼簽署或執行其他預分發任務。"

#: docs/en/tutorial/tutorial-3.md:410
#, fuzzy
msgid ""
"The `dist` folder will contain a file named `Hello World-0.0.1.dmg`. If you "
"locate this file in the Finder, and double-click on its icon, you'll mount "
"the DMG, giving you a copy of the Hello World app, and a link to your "
"Applications folder for easy installation. Drag the app file into "
"Applications, and you've installed your application. Send the DMG file to a "
"friend, and they should be able to do the same."
msgstr ""
"`dist` 資料夾將包含一個名為`Hello World-0.0.1.dmg` 的檔案。如果您在 Finder 中找到此文件，然後雙擊其圖標，您將安裝"
" DMG，為您提供 Hello World "
"應用程式的副本以及指向您的應用程式資料夾的鏈接，以便於安裝。將應用程式檔案拖曳到應用程式中，您就已經安裝了應用程式。將 DMG "
"檔案發送給朋友，他們應該能夠執行相同的操作。"

#: docs/en/tutorial/tutorial-3.md:417
#, fuzzy
msgid ""
"In this example, we've used the `--adhoc-sign` option - that is, we're "
"signing our application with *ad hoc* credentials - temporary credentials "
"that will only work on your machine. We've done this to keep the tutorial "
"simple. Setting up code signing identities is a little fiddly, and they're "
"only *required* if you're intending to distribute your application to "
"others. If we were publishing a real application for others to use, we would"
" need to specify real credentials."
msgstr ""
"在此範例中，我們使用了`--adhoc-sign`選項 - 也就是說，我們使用 *ad hoc* 憑證簽署我們的應用程式 - "
"只能在您的電腦上使用的臨時憑證。我們這樣做是為了讓教程簡單。設定程式碼簽署身分有點繁瑣，並且只有在您打算將應用程式分發給其他人時才`需要`它們。如果我們要發布真實的應用程式供其他人使用，我們需要指定真實的憑證。"

#: docs/en/tutorial/tutorial-3.md:425
#, fuzzy
msgid ""
"When you're ready to publish a real application, check out the Briefcase "
"How-To guide on [Setting up a macOS code signing identity]{1}."
msgstr "當您準備好發布實際應用程式時，請查看有關`設定 macOS 代碼簽署身分 [的公文包操作指南]{1}"

#: docs/en/tutorial/tutorial-3.md:433
#, fuzzy
msgid ""
"The output of the package step will be slightly different depending on your "
"Linux distribution. If you're on a Debian-derived distribution, you'll see:"
msgstr "根據您的 Linux 發行版，打包步驟的輸出將略有不同。如果您使用的是 Debian 派生的發行版，您將看到："

#: docs/en/tutorial/tutorial-3.md:455
#, fuzzy
msgid "The `dist` folder will contain the `.deb` file that was generated."
msgstr "`dist` 資料夾將包含產生的`.deb` 檔案。"

#: docs/en/tutorial/tutorial-3.md:457
#, fuzzy
msgid "If you're on a RHEL-based distribution, you'll see:"
msgstr "如果您使用的是基於 RHEL 的發行版，您將看到："

#: docs/en/tutorial/tutorial-3.md:484
#, fuzzy
msgid "The `dist` folder will contain the `.rpm` file that was generated."
msgstr "`dist` 資料夾將包含產生的`.rpm` 檔案。"

#: docs/en/tutorial/tutorial-3.md:486
#, fuzzy
msgid "If you're on an Arch-based distribution, you'll see:"
msgstr "如果您使用的是基於 Arch 的發行版，您將看到："

#: docs/en/tutorial/tutorial-3.md:504
#, fuzzy
msgid ""
"The `dist` folder will contain the `.pkg.tar.zst` file that was generated."
msgstr "`dist` 資料夾將包含產生的`.pkg.tar.zst` 檔案。"

#: docs/en/tutorial/tutorial-3.md:507
#, fuzzy
msgid "Other Linux distributions aren't currently supported for packaging."
msgstr "目前不支援打包其他 Linux 發行版。"

#: docs/en/tutorial/tutorial-3.md:509
#, fuzzy
msgid ""
"If you want to build a package for a Linux distribution other than the one "
"you're using, Briefcase can also help - but you'll need to install Docker."
msgstr "如果您想為您正在使用的 Linux 發行版以外的發行版建立軟體包，Briefcase 也可以提供協助 - 但您需要安裝 Docker。"

#: docs/en/tutorial/tutorial-3.md:513
#, fuzzy
msgid ""
"Official installers for [Docker Engine]{1} are available for a range of Unix"
" distributions. Follow the instructions for your platform; however, ensure "
"you don't install Docker in \"rootless\" mode."
msgstr ""
"[Docker Engine]{1} 的官方安裝程式可用於一系列 Unix 發行版。請遵循適合您平台的說明；但是，請確保不要以`無根`模式安裝 "
"Docker。"

#: docs/en/tutorial/tutorial-3.md:517
#, fuzzy
msgid ""
"Once you've installed Docker, you should be able to start an Linux container"
" - for example:"
msgstr "安裝 Docker 後，您應該能夠啟動 Linux 容器 - 例如："

#: docs/en/tutorial/tutorial-3.md:524
#, fuzzy
msgid ""
"will show you a Unix prompt (something like `root@84444e31cff9:/#`) inside "
"an Ubuntu 22.04 Docker container. Type Ctrl-D to exit Docker and return to "
"your local shell."
msgstr ""
"將在 Ubuntu 22.04 Docker 容器內向您顯示 Unix 提示字元（類似`root@844444e31cff9:/#`）。鍵入 "
"Ctrl-D 退出 Docker 並返回本機 shell。"

#: docs/en/tutorial/tutorial-3.md:528
#, fuzzy
msgid ""
"Once you've got Docker installed, you can use Briefcase to build a package "
"for any Linux distribution that Briefcase supports by passing in a Docker "
"image as an argument. For example, to build a DEB package for Ubuntu 22.04 "
"(Jammy), regardless of the operating system you're on, you can run:"
msgstr ""
"安裝 Docker 後，您可以透過傳入 Docker 映像作為參數，使用 Briefcase 為 Briefcase 支援的任何 Linux "
"發行版建置套件。例如，要為 Ubuntu 22.04 (Jammy) 建立 DEB 包，無論您使用什麼作業系統，都可以運行："

#: docs/en/tutorial/tutorial-3.md:538
#, fuzzy
msgid ""
"This will download the Docker image for your selected operating system, "
"create a container that is able to run Briefcase builds, and build the app "
"package inside the image. Once it's completed, the `dist` folder will "
"contain the package for the target Linux distribution."
msgstr ""
"這將為您選擇的作業系統下載 Docker 映像，建立一個能夠運行 Briefcase 建置的容器，並在映像內建置應用程式包。完成後，`dist` "
"資料夾將包含目標 Linux 發行版的軟體包。"

#: docs/en/tutorial/tutorial-3.md:575
#, fuzzy
msgid ""
"In this example, we're not signing our app. As a result, when you use the "
"installer, you'll get a system warning that the application comes from an "
"unknown developer. We've done this to keep the tutorial simple. Setting up "
"code signing identities is a little fiddly, and they're only *required* if "
"you're intending to distribute your application to others. If we were "
"publishing a real application for others to use, we would need to specify a "
"real signing identity; when that signed app is installed, the system will "
"notify the user that the application is from the known identity associated "
"with the certificate."
msgstr ""
"在此範例中，我們使用了`--adhoc-sign`選項 - 也就是說，我們使用 *ad hoc* 憑證簽署我們的應用程式 - "
"只能在您的電腦上使用的臨時憑證。我們這樣做是為了讓教程簡單。設定程式碼簽署身分有點繁瑣，並且只有在您打算將應用程式分發給其他人時才`需要`它們。如果我們要發布真實的應用程式供其他人使用，我們需要指定真實的憑證。"

#: docs/en/tutorial/tutorial-3.md:585
#, fuzzy
msgid ""
"When you're ready to publish a real application, check out the Briefcase "
"How-To guide on [Setting up a Windows code signing identity]{1}."
msgstr "當您準備好發布實際應用程式時，請查看有關`設定 macOS 代碼簽署身分 [的公文包操作指南]{1}"

#: docs/en/tutorial/tutorial-3.md:589
#, fuzzy
msgid ""
"Once this step completes, the `dist` folder will contain a file named "
"`Hello_World-0.0.1.msi`. If you double click on this installer to run it, "
"you should go through a familiar Windows installation process. Once this "
"installation completes, there will be a \"Hello World\" entry in your start "
"menu."
msgstr ""
"此步驟完成後，`dist`資料夾將包含一個名為 `Hello_World-0.0.1.msi` 的檔案。如果您雙擊此安裝程式來運行它，您應該經歷熟悉的 "
"Windows 安裝過程。安裝完成後，開始功能表中將出現一個 \"Hello World\" 項目。"

#: docs/en/tutorial/tutorial-3.md:599
#, fuzzy
msgid ""
"We now have our application packaged for distribution on desktop platforms. "
"But what happens when we need to update the code in our application? How do "
"we get those updates into our packaged application? Turn to [Tutorial 4]{1} "
"to find out..."
msgstr ""
"我們現在已將應用程式打包，以便在桌面平台上發行。但是，當我們需要更新應用程式中的程式碼時該怎麼辦？我們該如何將這些更新置入已打包的應用程式中？請參閱 "
"[教學 4]{1} 來找出答案..."

#: docs/en/tutorial/tutorial-4.md:1
#, fuzzy
msgid "Tutorial 4 - Updating your application"
msgstr "教程 4 - 更新您的應用程式"

#: docs/en/tutorial/tutorial-4.md:3
#, fuzzy
msgid ""
"In the last tutorial, we packaged our application as a native application. "
"If you're dealing with a real-world app, that isn't going to be the end of "
"the story - you'll likely do some testing, discover problems, and need to "
"make some changes. Even if your application is perfect, you'll eventually "
"want to publish version 2 of your application with improvements."
msgstr ""
"在上一個教程中，我們將應用程式打包為本機應用程式。如果您正在處理現實世界的應用程序，這不會是故事的結局 - "
"您可能會進行一些測試，發現問題，並需要進行一些更改。即使您的應用程式非常完美，您最終也會希望發布經過改進的應用程式的第 2 版。"

#: docs/en/tutorial/tutorial-4.md:10
#, fuzzy
msgid "So - how do you update your installed app when you make code changes?"
msgstr "那麼 - 當您更改程式碼時如何更新已安裝的應用程式？"

#: docs/en/tutorial/tutorial-4.md:12
#, fuzzy
msgid "Updating application code"
msgstr "更新應用程式程式碼"

#: docs/en/tutorial/tutorial-4.md:14
#, fuzzy
msgid ""
"Our application currently prints to the console when you press the button. "
"However, GUI applications shouldn't really use the console for output. They "
"need to use dialogs to communicate with users."
msgstr ""
"目前，當您按下按鈕時，我們的應用程式會列印到控制台。然而，GUI 應用程式不應該真正使用控制台進行輸出。他們需要使用對話框與使用者進行交流。"

#: docs/en/tutorial/tutorial-4.md:18
#, fuzzy
msgid ""
"Let's add a dialog box to say hello, instead of writing to the console. "
"Modify the `say_hello` callback so it looks like this:"
msgstr "讓我們新增一個對話框來打招呼，而不是寫入控制台。修改`say_hello`回調，使其看起來像這樣:"

#: docs/en/tutorial/tutorial-4.md:31
#, fuzzy
msgid ""
"We need to make the method `async` so that when we display the dialog, the "
"rest of the application continues to run. Don't worry about this detail too "
"much right now - we'll give a more detailed explanation in [Tutorial 8]{1}."
msgstr ""
"我們需要讓方法 `async` 這樣當我們顯示對話框時，應用程式的其他部分會繼續執行。現在不要太在意這個細節 - 我們會在 [Tutorial "
"8]{1} 中做更詳細的說明。"

#: docs/en/tutorial/tutorial-4.md:36
#, fuzzy
msgid ""
"This directs Toga to open a modal dialog box when the button is pressed."
msgstr "這會指示 Toga 在按下按鈕時開啟模式對話方塊。"

#: docs/en/tutorial/tutorial-4.md:38
#, fuzzy
msgid ""
"If you run `briefcase dev`, enter a name, and press the button, you'll see "
"the new dialog box:"
msgstr "如果執行`briefcase dev`，輸入名稱，然後按按鈕，您將看到新的對話方塊："

#: docs/en/tutorial/tutorial-4.md:43
#, fuzzy
msgid "![Hello World Tutorial 4 dialog, on macOS]{1}"
msgstr "![Hello World 教學 4 對話框，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-4.md:53
#, fuzzy
msgid "![Hello World Tutorial 4 dialog, on Linux]{1}"
msgstr "![Hello World Tutorial 4 dialog, on Linux]{1}"

#: docs/en/tutorial/tutorial-4.md:63
#, fuzzy
msgid "![Hello World Tutorial 4 dialog, on Windows]{1}"
msgstr "![Hello World 教程 4 對話，在 Windows 上]{1}。"

#: docs/en/tutorial/tutorial-4.md:71
#, fuzzy
msgid "However, if you run `briefcase run`, the dialog box won't appear."
msgstr "但是，如果執行`briefcase run`，則不會出現該對話方塊。"

#: docs/en/tutorial/tutorial-4.md:73
#, fuzzy
msgid ""
"Why is this? Well, `briefcase dev` operates by running your code in place - "
"it tries to produce as realistic runtime environment for your code as "
"possible, but it doesn't provide or use any of the platform infrastructure "
"for wrapping your code as an application. Part of the process of packaging "
"your app involves copying your code *into* the application bundle - and at "
"the moment, your application still has the old code in it."
msgstr ""
"為什麼會這樣？那麼，\"briefcase dev \"的運作方式是在原地執行您的程式碼 - "
"它嘗試為您的程式碼製作盡可能逼真的執行環境，但它不提供或使用任何平台基礎架構來將您的程式碼包裝成應用程式。打包應用程式的部分過程包括將您的程式碼複製到應用程式包中"
" - 目前，您的應用程式中仍有舊程式碼。"

#: docs/en/tutorial/tutorial-4.md:81
#, fuzzy
msgid ""
"So - we need to tell briefcase to update your app, copying in the new "
"version of the code. We *could* do this by deleting the old platform "
"directory and starting from scratch. However, Briefcase provides an easier "
"way - you can update the code for your existing bundled application:"
msgstr ""
"因此 - 我們需要告訴公文包更新您的應用程序，複製新版本的代碼。我們*可以*透過刪除舊平台目錄並從頭開始來做到這一點。但是，Briefcase "
"提供了一種更簡單的方法 - 您可以更新現有捆綁應用程式的程式碼："

#: docs/en/tutorial/tutorial-4.md:142
#, fuzzy
msgid ""
"If Briefcase can't find the scaffolded template, it will automatically "
"invoke `create` to generate a fresh scaffold."
msgstr "如果Briefcase找不到鷹架模板，它會自動呼叫`create`來產生一個新的鷹架。"

#: docs/en/tutorial/tutorial-4.md:145
#, fuzzy
msgid ""
"Now that we've updated the installer code, we can then run `briefcase build`"
" to re-compile the app, `briefcase run` to run the updated app, and "
"`briefcase package` to repackage the application for distribution."
msgstr ""
"現在我們已經更新了安裝程式碼，然後我們可以運行`briefcase build`來重新編譯應用程序，運行`briefcase "
"run`來運行更新後的應用程序，以及運行`briefcase package`來重新打包應用程式用於分發。"

#: docs/en/tutorial/tutorial-4.md:152
#, fuzzy
msgid ""
"macOS users, remember that as noted in [Tutorial 3]{1}, for the tutorial we "
"recommend running `briefcase package` with the `--adhoc-sign` flag to avoid "
"the complexity of setting up a code signing identity and keep the tutorial "
"as simple as possible."
msgstr ""
"（macOS 用戶，請記住，如 [教學 3 所述<tutorial-3>`，對於本教程，我們建議使用`--adhoc-"
"sign`標誌運行`briefcase package`，以避免設置代碼簽名身份的複雜性，並使教程盡可能簡單。）"

#: docs/en/tutorial/tutorial-4.md:159
#, fuzzy
msgid "Update and run in one step"
msgstr "一步更新並運行"

#: docs/en/tutorial/tutorial-4.md:161
#, fuzzy
msgid ""
"If you're rapidly iterating code changes, you'll likely want to make a code "
"change, update the application, and immediately re-run your application. For"
" most purposes, developer mode (`briefcase dev`) will be the easiest way to "
"do this sort of rapid iteration; however, if you're testing something about "
"how your application runs as a native binary, or hunting a bug that only "
"manifests when your application is in packaged form, you may need to use "
"repeated calls to `briefcase run`. To simplify the process of updating and "
"running the bundled app, Briefcase has a shortcut to support this usage "
"pattern - the `-u` (or `--update`) option on the `run` command."
msgstr ""
"如果您快速迭代程式碼更改，您可能需要更改程式碼、更新應用程序，然後立即重新執行您的應用程式。對於大多數目的，開發人員模式（`briefcase "
"dev`）將是進行這種快速迭代的最簡單方法；但是，如果您正在測試應用程式如何作為本機二進位檔案運行，或者尋找僅在應用程式處於打包形式時才會出現的錯誤，則可能需要重複調用`briefcase"
" run`。為了簡化更新和執行捆綁應用程式的過程，Briefcase 有一個快捷方式來支援這種使用模式 - `run` "
"命令上的`-u`（或`--update`）選項。"

#: docs/en/tutorial/tutorial-4.md:172
#, fuzzy
msgid ""
"Let's try making another change. You may have noticed that if you don't type"
" a name in the text input box, the dialog will say \"Hello, \". Let's modify"
" the `say_hello` function again to handle this edge case."
msgstr ""
"讓我們嘗試進行另一個更改。您可能已經注意到，如果您不在文字輸入方塊中鍵入姓名，則對話方塊將顯示 \"Hello，\"。讓我們再次修改 "
"`say_hello` 函數來處理這種邊緣情況。"

#: docs/en/tutorial/tutorial-4.md:176
#, fuzzy
msgid ""
"At the top of the file, between the imports and the `class HelloWorld` "
"definition, add a utility method to generate an appropriate greeting "
"depending on the value of the name that has been provided:"
msgstr "在檔案頂部的匯入和`class HelloWorld`定義之間，新增實用程式方法以根據已提供的名稱值產生適當的問候語："

#: docs/en/tutorial/tutorial-4.md:188
#, fuzzy
msgid "Then, modify the `say_hello` callback to use this new utility method:"
msgstr "然後，修改`say_hello`回調以使用這個新的實用方法："

#: docs/en/tutorial/tutorial-4.md:200
#, fuzzy
msgid ""
"Run your app in development mode (with `briefcase dev`) to confirm that the "
"new logic works; then update, build and run the app with one command:"
msgstr "在開發模式下運行您的應用程式（使用`briefcase dev`）以確認新邏輯有效；然後使用一個命令更新、建置和運行應用程式："

#: docs/en/tutorial/tutorial-4.md:274
#, fuzzy
msgid ""
"The package command also accepts the `-u` argument, so if you make a change "
"to your application code and want to repackage immediately, you can run "
"`briefcase package -u`."
msgstr ""
"package 命令也接受`-u`參數，因此如果您對應用程式程式碼進行了更改並希望立即重新打包，則可以運行`briefcase package -u`。"

#: docs/en/tutorial/tutorial-4.md:280
#, fuzzy
msgid ""
"We now have our application packaged for distribution on desktop platforms, "
"and we've been able to update the code in our application."
msgstr "現在，我們已經將應用程式打包以便在桌面平台上分發，並且我們已經能夠更新應用程式中的程式碼。"

#: docs/en/tutorial/tutorial-4.md:283
#, fuzzy
msgid ""
"But what about mobile? In [Tutorial 5]{1}, we'll convert our application "
"into a mobile application, and deploy it onto a device simulator, and onto a"
" phone."
msgstr "但是手機呢？在 [教學 5]{1}，我們將把應用程式轉換為行動應用程式，並部署到裝置模擬器和手機上。"

#: docs/en/tutorial/tutorial-5/android.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it mobile: Android"
msgstr "教學 5 - 行動裝置：Android"

#: docs/en/tutorial/tutorial-5/android.md:3
#, fuzzy
msgid ""
"Now, we're going to take our application, and deploy it as an Android "
"application."
msgstr "現在，我們將獲取我們的應用程序，並將其部署為 Android 應用程式。"

#: docs/en/tutorial/tutorial-5/android.md:6
#, fuzzy
msgid ""
"The process of deploying an application to Android is very similar to the "
"process for deploying as a desktop application. Briefcase handles installing"
" dependencies for Android, including the Android SDK, the Android emulator, "
"and a Java compiler."
msgstr ""
"將應用程式部署到 Android 的過程與部署為桌面應用程式的過程非常相似。 Briefcase 負責安裝 Android 依賴項，包括 Android"
" SDK、Android 模擬器和 Java 編譯器。"

#: docs/en/tutorial/tutorial-5/android.md:11
#, fuzzy
msgid "Create an Android app and compile it"
msgstr "創建一個 Android 應用程式並編譯它"

#: docs/en/tutorial/tutorial-5/android.md:13
#, fuzzy
msgid ""
"First, run the `create` command. This downloads an Android app template and "
"adds your Python code to it."
msgstr "首先，執行`create`命令。這將下載 Android 應用程式模板並向其中添加您的 Python 程式碼。"

#: docs/en/tutorial/tutorial-5/android.md:104
#, fuzzy
msgid ""
"When you run `briefcase create android` for the first time, Briefcase "
"downloads a Java JDK, and the Android SDK. File sizes and download times can"
" be considerable; this may take a while (10 minutes or longer, depending on "
"the speed of your Internet connection). When the download has completed, you"
" will be prompted to accept Google's Android SDK license. There's a number "
"of licenses you'll need to agree too - keep entering `y` at the prompt to "
"review and accept each of the necessary the license agreements."
msgstr ""
"當您第一次執行`briefcase create android`時，Briefcase 會下載 Java JDK 和 Android "
"SDK。文件大小和下載時間可能相當大；這可能需要一段時間（10 分鐘或更長時間，具體取決於您的 Internet "
"連線速度）。下載完成後，系統會提示您接受 Google 的 Android SDK 授權。"

#: docs/en/tutorial/tutorial-5/android.md:113
#, fuzzy
msgid ""
"Once this completes, we'll have a `build\\helloworld\\android\\gradle` "
"directory in our project, which will contain an Android project with a "
"Gradle build configuration. This project will contain your application code,"
" and a support package containing the Python interpreter."
msgstr ""
"完成後，我們的專案中將有一個 `build\\helloworld\\android\\gradle` 目錄，其中包含具有 Gradle 建置配置的 "
"Android 專案。該專案將包含您的應用程式程式碼以及包含 Python 解釋器的支援套件。"

#: docs/en/tutorial/tutorial-5/android.md:118
#, fuzzy
msgid ""
"We can then use Briefcase's `build` command to compile this into an Android "
"APK app file."
msgstr "然後我們可以使用 Briefcase 的 `build` 命令將其編譯成 Android APK 應用程式檔案。"

#: docs/en/tutorial/tutorial-5/android.md:182
#, fuzzy
msgid "/// admonition | Gradle may look stuck"
msgstr "/// admonition |Gradle 可能看起來卡住了"

#: docs/en/tutorial/tutorial-5/android.md:184
#, fuzzy
msgid ""
"During the `briefcase build android` step, Gradle (the Android platform "
"build tool) will print `CONFIGURING: 100%`, and appear to be doing nothing. "
"Don't worry, it's not stuck - it's downloading more Android SDK components. "
"Depending on your Internet connection speed, this may take another 10 "
"minutes (or longer). This lag should only happen the very first time you run"
" `build`; the tools are cached, and on your next build, the cached versions "
"will be used."
msgstr ""
"在`briefcase build android`步驟中，Gradle（Android 平台建置工具）將列印`CONFIGURING: "
"100%`，似乎什麼也沒做。別擔心，它並沒有卡住 - 它正在下載更多 Android SDK 組件。根據您的網路連線速度，這可能還需要 10 "
"分鐘（或更長）。這種滯後應該只在你第一次執行`build`時發生；這些工具會被緩存，並且在您的下一個建置中，將使用快取的版本。"

#: docs/en/tutorial/tutorial-5/android.md:194
#, fuzzy
msgid "Run the app on a virtual device"
msgstr "在虛擬設備上運行應用程式"

#: docs/en/tutorial/tutorial-5/android.md:196
#, fuzzy
msgid ""
"We're now ready to run our application. You can use Briefcase's `run` "
"command to run the app on an Android device. Let's start by running on an "
"Android emulator."
msgstr ""
"現在我們已經準備好運行我們的應用程式了。您可以使用 Briefcase 的`run`命令在 Android 裝置上執行該應用程式。讓我們從在 "
"Android 模擬器上運行開始。"

#: docs/en/tutorial/tutorial-5/android.md:200
#, fuzzy
msgid ""
"To run your application, run `briefcase run android`. When you do this, "
"you'll be prompted with a list of devices that you could run the app on. The"
" last item will always be an option to create a new Android emulator."
msgstr ""
"要運行您的應用程序，請運行`briefcase run "
"android`。當您執行此操作時，系統會提示您提供可以執行該應用程式的裝置清單。最後一項始終是建立新 Android 模擬器的選項。"

#: docs/en/tutorial/tutorial-5/android.md:246
#, fuzzy
msgid ""
"We can now choose our desired device. Select the \"Create a new Android "
"emulator\" option, and accept the default choice for the device name "
"(`beePhone`)."
msgstr "我們現在可以選擇我們想要的設備。選擇`建立新的 Android 模擬器`選項，並接受裝置名稱的預設選擇 (`beePhone`)。"

#: docs/en/tutorial/tutorial-5/android.md:250
#, fuzzy
msgid ""
"Briefcase `run` will automatically boot the virtual device. When the device "
"is booting, you will see the Android logo:"
msgstr "公事包`run`將自動啟動虛擬設備。當裝置啟動時，您將看到 Android 標誌："

#: docs/en/tutorial/tutorial-5/android.md:253
#, fuzzy
msgid "![Android virtual device booting]{1}"
msgstr "Android虛擬裝置啟動]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:257
#, fuzzy
msgid "Android virtual device booting"
msgstr "Android 虛擬裝置開機"

#: docs/en/tutorial/tutorial-5/android.md:261
#, fuzzy
msgid ""
"Once the device has finished booting, Briefcase will install your app on the"
" device. You will briefly see a launcher screen:"
msgstr "裝置完成啟動後，Briefcase 將在裝置上安裝您的應用程式。您將短暫地看到一個啟動器畫面："

#: docs/en/tutorial/tutorial-5/android.md:264
#, fuzzy
msgid "![Android virtual device fully started, on the launcher screen]{1}"
msgstr "![Android虛擬裝置已完全啟動，在啟動畫面中]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:268
#, fuzzy
msgid "Android virtual device fully started, on the launcher screen"
msgstr "Android 虛擬裝置已完全啟動，在啟動畫面中"

#: docs/en/tutorial/tutorial-5/android.md:272
#, fuzzy
msgid ""
"The app will then start. You'll see a splash screen while the app starts up:"
msgstr "然後該應用程式將啟動。應用程式啟動時您將看到啟動畫面："

#: docs/en/tutorial/tutorial-5/android.md:275
#, fuzzy
msgid "![App splash screen]{1}"
msgstr "[應用程式閃屏]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:279
#, fuzzy
msgid "App splash screen"
msgstr "應用程式閃屏"

#: docs/en/tutorial/tutorial-5/android.md:283
#, fuzzy
msgid "/// admonition | The emulator didn't start!"
msgstr "/// admonition |模擬器沒有啟動！"

#: docs/en/tutorial/tutorial-5/android.md:285
#, fuzzy
msgid ""
"The Android emulator is a complex piece of software that relies on a number "
"of hardware and operating system features - features that may not be "
"available or enabled on older machines. If you experience any difficulties "
"starting the Android emulator, consult the [Requirements and "
"recommendations]{1} section of the Android developer documentation."
msgstr ""
"Android 模擬器是一款複雜的軟體，依賴許多硬體和作業系統功能 - 這些功能在舊機器上可能無法使用或啟用。如果您在啟動 Android "
"模擬器時遇到任何困難，請參閱 Android 開發人員文件的 [要求與建議]{1} 部分。"

#: docs/en/tutorial/tutorial-5/android.md:295
#, fuzzy
msgid ""
"The first time the app starts, it needs to unpack itself onto the device. "
"This may take a few seconds. Once it's unpacked, you'll see the Android "
"version of our desktop app:"
msgstr "應用程式第一次啟動時，需要將自身解壓縮到裝置上。這可能需要幾秒鐘。解壓縮後，您將看到我們桌面應用程式的 Android 版本："

#: docs/en/tutorial/tutorial-5/android.md:299
#, fuzzy
msgid "![Demo app fully launched]{1}"
msgstr "![演示應用程式完全啟動]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:303
#, fuzzy
msgid "Demo app fully launched"
msgstr "示範應用程式全面啟動"

#: docs/en/tutorial/tutorial-5/android.md:307
#, fuzzy
msgid ""
"If you fail to see your app launching, you may need to check your terminal "
"where you ran `briefcase run` and look for any error messages."
msgstr "如果您無法看到應用程式啟動，您可能需要檢查執行`briefcase run`的終端並查找任何錯誤訊息。"

#: docs/en/tutorial/tutorial-5/android.md:310
#, fuzzy
msgid ""
"While the app is running, you'll see a lot of messages being streamed in the"
" console. This is a stream of the application's logs from the emulator. "
"Typing Ctrl+C into the terminal will halt the streamed information in the "
"console, but it will not close the emulator. This is so you can test new "
"changes without restarting the emulator."
msgstr ""
"當應用程式執行時，您會在控制台中看到大量的訊息流。這是來自模擬器的應用程式日誌串流。在終端機中輸入 Ctrl+C "
"將停止控制台中的串流資訊，但不會關閉模擬器。這樣您就可以測試新的變更，而無需重新啟動模擬器。"

#: docs/en/tutorial/tutorial-5/android.md:316
#, fuzzy
msgid ""
"In future, if you want to run on this device without using the menu, you can"
" provide the emulator's name to Briefcase, using `briefcase run android -d "
"\"@beePhone\"` to run on the virtual device directly."
msgstr ""
"將來，如果您想在該裝置上運行而不使用選單，您可以將模擬器的名稱提供給Briefcase，使用`briefcase run android -d "
"@beePhone`直接在虛擬裝置上執行。"

#: docs/en/tutorial/tutorial-5/android.md:321
#, fuzzy
msgid "Run the app on a physical device"
msgstr "在物理設備上運行應用程式"

#: docs/en/tutorial/tutorial-5/android.md:323
#, fuzzy
msgid ""
"If you have a physical Android phone or tablet, you can connect it to your "
"computer with a USB cable, and then use the Briefcase to target your "
"physical device."
msgstr "如果您有實體 Android 手機或平板電腦，則可以使用 USB 電纜將其連接到計算機，然後使用公文包定位您的實體設備。"

#: docs/en/tutorial/tutorial-5/android.md:327
#, fuzzy
msgid ""
"Android requires that you prepare your device before it can be used for "
"development. You will need to make 2 changes to the options on your device:"
msgstr "Android 要求您先準備好設備，然後才能用於開發。您需要對裝置上的選項進行 2 項變更："

#: docs/en/tutorial/tutorial-5/android.md:331
#, fuzzy
msgid "Enable developer options"
msgstr "啟用開發者選項"

#: docs/en/tutorial/tutorial-5/android.md:332
#, fuzzy
msgid "Enable USB debugging"
msgstr "啟用USB調試"

#: docs/en/tutorial/tutorial-5/android.md:334
#, fuzzy
msgid ""
"Details on how to make these changes can be found [in the Android developer "
"documentation]{1}."
msgstr "有關如何進行這些更改的詳細信息，請參閱 [Android 開發人員文件]{1}。"

#: docs/en/tutorial/tutorial-5/android.md:337
#, fuzzy
msgid ""
"Once these steps have been completed, your device should appear in the list "
"of available devices when you run `briefcase run android`."
msgstr "完成這些步驟後，當您執行`briefcase run android`時，您的裝置應該會出現在可用裝置清單中。"

#: docs/en/tutorial/tutorial-5/android.md:388
#, fuzzy
msgid ""
"Here we can see a new physical device with it's serial number on the "
"deployment list - in this case, a Pixel 3a. In the future, if you want to "
"run on this device without using the menu, you can provide the phone's "
"serial number to Briefcase (in this case, `briefcase run android -d "
"94ZZY0LNE8`). This will run on the device directly, without prompting."
msgstr ""
"在這裡，我們可以在部署清單中看到一個新的實體設備及其序號 - 在本例中為 Pixel "
"3a。將來，如果您想在該裝置上運行而不使用選單，您可以向Briefcase提供手機的序號（在本例中為`briefcase run android -d "
"94ZZY0LNE8`）。這將直接在設備上運行，無需提示。"

#: docs/en/tutorial/tutorial-5/android.md:395
#, fuzzy
msgid "/// admonition | My device doesn't appear!"
msgstr "/// admonition |我的裝置沒有出現！"

#: docs/en/tutorial/tutorial-5/android.md:397
#, fuzzy
msgid ""
"If your device doesn't appear on this list at all, either you haven't "
"enabled USB debugging, (or the device isn't plugged in!)."
msgstr "如果您的裝置完全沒有出現在此清單中，則可能是您尚未啟用 USB 偵錯（或裝置未插入！）。"

#: docs/en/tutorial/tutorial-5/android.md:400
#, fuzzy
msgid ""
"If your device appears, but is listed as \"Unknown device (not authorized "
"for development)\", developer mode hasn't been correctly enabled. Re-run "
"[the steps to enable developer options]{1}, and re-run `briefcase run "
"android`."
msgstr ""
"如果您的裝置出現，但被列為`未知裝置（未授權開發）`，則表示開發者模式尚未正確啟用。重新執行 "
"[啟用開發人員選項的步驟]{1}，並重新執行`briefcase run android``。"

#: docs/en/tutorial/tutorial-5/android.md:410
#: docs/en/tutorial/tutorial-5/iOS.md:156
#, fuzzy
msgid ""
"We've now got an application on our phone! Is there anywhere else we can "
"deploy a BeeWare app? Turn to [Tutorial 6]{1} to find out..."
msgstr "我們現在已經在手機上安裝了應用程式！還有其他地方可以部署BeeWare應用程式嗎？請參考 [教學 6]{1} 來找出答案..."

#: docs/en/tutorial/tutorial-5/iOS.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it mobile: iOS"
msgstr "教學 5 - 行動裝置：iOS"

#: docs/en/tutorial/tutorial-5/iOS.md:3
#, fuzzy
msgid ""
"To compile iOS applications we'll need Xcode, which is available for free "
"from [the macOS App Store]{1}. Once Xcode is installed, launch it from "
"Applications and accept the Xcode License Agreement. Next, Xcode will show "
"which components are built-in, and which components you may download. Select"
" the checkbox next to iOS (followed by the current version number), and then"
" click \"Download and Install\" to install it. Xcode will install the system"
" components, followed by the iOS Simulator."
msgstr ""
"要編譯 iOS 應用程式，我們需要 Xcode，它可以從 [macOS App Store]{1} 免費下載。安裝 Xcode 後，從 "
"Applications 啟動它，並接受 Xcode License Agreement。接下來，Xcode "
"會顯示哪些是內建元件，哪些是您可以下載的元件。選擇 iOS 旁邊的核取方塊（後面跟著目前的版本號碼），然後按一下「Download and "
"Install」（下載並安裝）進行安裝。Xcode 將安裝系統元件，接著安裝 iOS 模擬器。"

#: docs/en/tutorial/tutorial-5/iOS.md:13
#, fuzzy
msgid ""
"Once we've got Xcode and the iOS simulator installed, we can take our "
"application and deploy it as an iOS app."
msgstr "一旦我們安裝了 Xcode，我們就可以將我們的應用程式部署為 iOS 應用程式。"

#: docs/en/tutorial/tutorial-5/iOS.md:16
#, fuzzy
msgid ""
"The process of deploying an application to iOS is very similar to the "
"process for deploying as a desktop application. First, you run the `create` "
"command - but this time, we specify that we want to create an iOS "
"application:"
msgstr ""
"將應用程式部署到 iOS 的流程與部署為桌面應用程式的流程非常相似。首先，執行 `create` 指令，但這次我們指定要建立 iOS 應用程式："

#: docs/en/tutorial/tutorial-5/iOS.md:46
#, fuzzy
msgid ""
"Once this completes, we'll have a `build/helloworld/ios/xcode` directory "
"containing an Xcode project, as well as the support libraries and the "
"application code needed for the application."
msgstr ""
"完成後，我們將擁有一個`build/helloworld/ios/xcode`目錄，其中包含 Xcode 專案以及應用程式所需的支援庫和應用程式程式碼。"

#: docs/en/tutorial/tutorial-5/iOS.md:50
#, fuzzy
msgid ""
"You can then use Briefcase to compile your app using `briefcase build iOS`:"
msgstr "然後，您可以使用`briefcase build iOS`來使用 Briefcase 來編譯您的應用程式："

#: docs/en/tutorial/tutorial-5/iOS.md:66
#, fuzzy
msgid ""
"We're now ready to run our application, using `briefcase run iOS`. You'll be"
" prompted to select a device to compile for; if you've got simulators for "
"multiple iOS SDK versions installed, you may also be asked which iOS version"
" you want to target. The options you are shown may differ from the options "
"show in this output - at the very least, the list of devices will likely be "
"different. For our purposes, it doesn't matter which simulator you pick."
msgstr ""
"現在我們已經準備好使用`briefcase run iOS`來運行我們的應用程式。系統會提示您選擇要編譯的設備；如果您安裝了多個 iOS SDK "
"版本的模擬器，系統也可能會詢問您要定位哪個 iOS 版本。您顯示的選項可能與此輸出中顯示的選項不同 - "
"至少，設備清單可能會有所不同。就我們的目的而言，您選擇哪個模擬器並不重要。"

#: docs/en/tutorial/tutorial-5/iOS.md:116
#, fuzzy
msgid ""
"This will start the iOS simulator, install your app, and start it. You "
"should see the simulator start, and eventually open your iOS application:"
msgstr "這將啟動 iOS 模擬器、安裝您的應用程式並啟動它。您應該會看到模擬器啟動，並最終打開您的 iOS 應用程式："

#: docs/en/tutorial/tutorial-5/iOS.md:120
#, fuzzy
msgid "![Hello World Tutorial 5 window, on iOS]{1}"
msgstr "![Hello World 教學 5 視窗，在 iOS 上]{1}。"

#: docs/en/tutorial/tutorial-5/iOS.md:126
#, fuzzy
msgid ""
"While the app is running, you'll see a series of Simulator log output "
"messages in the console. Typing Ctrl+C into the terminal will halt the "
"messages in the console, but it will not close the simulator. This is so you"
" can test new changes without restarting the simulator."
msgstr ""
"當應用程式執行時，您會在控制台看到一系列模擬器日誌輸出訊息。在終端機中輸入 Ctrl+C "
"將停止控制台中的訊息，但不會關閉模擬器。這樣您就可以測試新的變更，而無需重新啟動模擬器。"

#: docs/en/tutorial/tutorial-5/iOS.md:131
#, fuzzy
msgid ""
"If you know ahead of time which iOS simulator you want to target, you can "
"tell Briefcase to use that simulator by providing a `-d` (or `--device`) "
"option. Using the name of the device you selected when you built your "
"application, run:"
msgstr ""
"如果您事先知道要定位哪個 iOS 模擬器，則可以透過提供`-d`（或`--device`）選項來告訴 Briefcase "
"使用該模擬器。使用您在建立應用程式時選擇的設備名稱，運行："

#: docs/en/tutorial/tutorial-5/iOS.md:140
#, fuzzy
msgid ""
"If you have multiple iOS versions available, Briefcase will pick the highest"
" iOS version; if you want to pick a particular iOS version, you tell it to "
"use that specific version:"
msgstr "如果您有多個可用的 iOS 版本，公事包將選擇最高的 iOS 版本；如果你想選擇一個特定的 iOS 版本，你可以告訴它使用該特定版本："

#: docs/en/tutorial/tutorial-5/iOS.md:148
#, fuzzy
msgid "Or, you can name a specific device UDID:"
msgstr "或者，您可以命名特定設備 UDID："

#: docs/en/tutorial/tutorial-5/index.md:1
#, fuzzy
msgid "Tutorial 5 - Taking it Mobile"
msgstr "教程 5 - 移動使用"

#: docs/en/tutorial/tutorial-5/index.md:3
#, fuzzy
msgid ""
"So far, we've been running and testing our application on the desktop. "
"However, BeeWare also supports mobile platforms - and the application we've "
"written can be deployed to your mobile device, too!"
msgstr ""
"到目前為止，我們已經在桌面上運行和測試我們的應用程式。但是，BeeWare 還支援行動平台 - 我們編寫的應用程式也可以部署到您的行動裝置！"

#: docs/en/tutorial/tutorial-5/index.md:7
#, fuzzy
msgid "[Android]{1}"
msgstr "[Android]{1}"

#: docs/en/tutorial/tutorial-5/index.md:9
#, fuzzy
msgid "Android applications can be compiled on macOS, Windows or Linux."
msgstr "Android 應用程式可以在 macOS、Windows 或 Linux 上編譯。"

#: docs/en/tutorial/tutorial-5/index.md:11
#, fuzzy
msgid "[iOS]{1}"
msgstr "[iOS]{1}"

#: docs/en/tutorial/tutorial-5/index.md:13
#, fuzzy
msgid "iOS applications can only be compiled on macOS."
msgstr "iOS 應用程式只能在 macOS 上編譯。"

#: docs/en/tutorial/tutorial-6.md:1
#, fuzzy
msgid "Tutorial 6 - Put it on the web!"
msgstr "教程 6 - 將其放在網路上！"

#: docs/en/tutorial/tutorial-6.md:3
msgid ""
"In addition to supporting mobile platforms, the Toga widget toolkit also "
"supports the web! Using the same API that you used to deploy your desktop "
"and mobile applications, you can deploy your application as a single-page "
"web app."
msgstr "除了支援行動平台外，Toga 還支援網頁！使用與部署桌面和行動應用程式相同的 API，您可以將應用程式部署為單頁 Web 應用程式。"

#: docs/en/tutorial/tutorial-6.md:8
#, fuzzy
msgid "/// admonition | Proof of Concept"
msgstr "/// admonition |概念驗證"

#: docs/en/tutorial/tutorial-6.md:10
msgid ""
"The Toga Web backend is the least mature of all the Toga backends. It's "
"mature enough to show off a few features, but it's likely to be buggy, and "
"will be missing many of the widgets that are available on other platforms. "
"At this point in time, Web deployment should be considered a \"Proof of "
"Concept\" - enough to demonstrate what can be done, but not enough to be "
"relied on for serious development."
msgstr ""
"Toga Web 後端是所有 Toga "
"後端中最不成熟的。它已經足夠成熟，可以展示一些功能，但它可能有缺陷，並且會缺少其他平台上可用的許多小部件。此時，Web 部署應被視為 `概念驗證` - "
"足以演示可以做什麼，但不足以依賴認真的開發。"

#: docs/en/tutorial/tutorial-6.md:17
msgid ""
"If you have problems with this step of the tutorial, you can skip to the "
"next page."
msgstr "如果您對本教學的這一步有疑問，可以跳到下一頁。"

#: docs/en/tutorial/tutorial-6.md:22
msgid "Deploying as a web app"
msgstr "部署為 Web 應用程式"

#: docs/en/tutorial/tutorial-6.md:24
msgid ""
"The process of deploying as a single-page web app follows the same familiar "
"pattern - you create the application, then build the application, then run "
"it. However, Briefcase can be a little bit smart; if you attempt to run an "
"application, and Briefcase determines that it hasn't been created or built "
"for the platform being targeted, it will do the create and build steps for "
"you. Since this is our first time running the app for the web, we can "
"perform all three steps with one command:"
msgstr ""
"部署為單頁 Web 應用程式的過程遵循相同的熟悉模式 - 建立應用程序，然後建立應用程序，然後運行它。然而，Briefcase "
"有點聰明，如果您嘗試運行應用程序，並且 Briefcase "
"確定該應用程式尚未針對目標平台創建或構建，它將為您執行創建和構建步驟。由於這是我們第一次運行該應用程式的網絡，我們可以使用一個命令執行所有三個步驟："

#: docs/en/tutorial/tutorial-6.md:152
#, fuzzy
msgid "This will open a web browser, pointing at {1}:"
msgstr "這會開啟網頁瀏覽器，指向 {1}："

#: docs/en/tutorial/tutorial-6.md:154
#, fuzzy
msgid "![Hello World Tutorial 6 dialog, in a browser]{1}"
msgstr "![瀏覽器中的 Hello World Tutorial 6 對話]{1}。"

#: docs/en/tutorial/tutorial-6.md:156
msgid "If you enter your name and click the button, a dialog will appear."
msgstr "如果您輸入您的姓名並按一下該按鈕，將會出現一個對話方塊。"

#: docs/en/tutorial/tutorial-6.md:158
msgid "How does this work?"
msgstr "這個怎麼用？"

#: docs/en/tutorial/tutorial-6.md:160
msgid ""
"This web app is a static website - a single HTML source page, with some CSS "
"and other resources. Briefcase has started a local web server to serve this "
"page so your browser can view the page. If you wanted to put this web page "
"into production, you could copy the contents of the `www` folder onto any "
"web server that can serve static content."
msgstr ""
"此 Web 應用程式是一個靜態網站 - 單一 HTML 來源頁面，帶有一些 CSS 和其他資源。 Briefcase 已啟動本機 Web "
"伺服器來提供此頁面，以便您的瀏覽器可以查看該頁面。如果您想將此網頁投入生產，您可以將 `www` 資料夾的內容複製到任何可以提供靜態內容的 Web "
"伺服器上。"

#: docs/en/tutorial/tutorial-6.md:166
#, fuzzy
msgid ""
"But when you press the button, you're running Python code... how does that "
"work? Toga uses [PyScript]{1} to provide a Python interpreter in the "
"browser. Briefcase packages your app's code as wheels that PyScript can load"
" in the browser. When the page is loaded, the application code runs in the "
"browser, building the UI using the browser DOM. When you click a button, "
"that button runs the event handling code in the browser."
msgstr ""
"但是當您按下按鈕時，您正在執行 Python 程式碼......這是如何運作的呢？Toga 使用 [PyScript]{1} 在瀏覽器中提供 "
"Python 解譯器。Briefcase 將您應用程式的程式碼打包成 PyScript 可以在瀏覽器中載入的 "
"wheels。載入頁面時，應用程式程式碼會在瀏覽器中執行，並使用瀏覽器 DOM 建立使用者介面。當您按一下按鈕，該按鈕會在瀏覽器中執行事件處理程式碼。"

#: docs/en/tutorial/tutorial-6.md:176
#, fuzzy
msgid ""
"Although we've now deployed this app on desktop, mobile and the web, the app"
" is fairly simple, and doesn't involve any third-party libraries. Can we "
"include libraries from the Python Package Index (PyPI) in our app? Turn to "
"[Tutorial 7]{1} to find out..."
msgstr ""
"雖然我們現在已經在桌面、行動和網路上部署了這個應用程序，但該應用程式相當簡單，並且不涉及任何第三方程式庫。我們可以在我們的應用程式中包含 Python "
"套件索引 (PyPI) 中的函式庫嗎？前往 :doc:`教學 7<tutorial-7>` 找出..."

#: docs/en/tutorial/tutorial-7.md:1
#, fuzzy
msgid "Tutorial 7 - Get this (third-)party started"
msgstr "教學 7 - 啟動此（第三方）"

#: docs/en/tutorial/tutorial-7.md:3
#, fuzzy
msgid ""
"So far, the app we've built has only used our own code, plus the code "
"provided by BeeWare. However, in a real-world app, you'll likely want to use"
" a third-party library, downloaded from the Python Package Index (PyPI)."
msgstr ""
"到目前為止，我們建立的應用程式只使用了我們自己的程式碼，加上 BeeWare 提供的程式碼。但是，在現實應用程式中，您可能需要使用從 Python "
"Package Index (PyPI) 下載的第三方程式庫。"

#: docs/en/tutorial/tutorial-7.md:8
#, fuzzy
msgid "Let's modify our app to include a third-party library."
msgstr "讓我們修改我們的應用程式以包含第三方程式庫。"

#: docs/en/tutorial/tutorial-7.md:10
#, fuzzy
msgid "Adding a package"
msgstr "新增套件"

#: docs/en/tutorial/tutorial-7.md:12
#, fuzzy
msgid ""
"Let's modify our application to say a little bit more than just \"Hi, "
"there!\"."
msgstr "讓我們修改應用程式，讓它不只是說「嗨，你好！」。"

#: docs/en/tutorial/tutorial-7.md:15
#, fuzzy
msgid ""
"To generate some more interesting text for the dialog, we're going to use a "
"library called [Faker]{1}. Faker is a Python package that generates fake "
"content, including names and text blocks. The names and words in the text "
"block are generated from an arbitrary list of words provided by Faker. We're"
" going to use Faker to construct a fake message, as if someone is responding"
" to the user."
msgstr ""
"要為對話框產生一些更有趣的文字，我們要使用一個叫做 [Faker]{1} 的函式庫。Faker 是一個 Python "
"套件，可以產生虛假內容，包括名稱和文字區塊。文字區塊中的名稱和字詞是由 Faker 提供的任意字詞清單產生的。我們要使用 Faker "
"來建構一個虛假的訊息，就好像有人在回應使用者一樣。"

#: docs/en/tutorial/tutorial-7.md:23
#, fuzzy
msgid ""
"We start by adding `faker` to our app. Add an import to the top of the "
"`app.py` to import `faker`:"
msgstr "讓我們為我們的應用程式新增一個`httpx` API 呼叫。將導入新增至`app.py`頂部以導入`httpx`:"

#: docs/en/tutorial/tutorial-7.md:30 docs/en/tutorial/tutorial-8.md:65
#, fuzzy
msgid "Then modify the `say_hello()` callback so it looks like this:"
msgstr "要使我們的教程異步，請修改 `say_hello()` 事件處理程序，使其如下所示："

#: docs/en/tutorial/tutorial-7.md:43
#, fuzzy
msgid ""
"Let's run our updated app in Briefcase developer mode to check that our "
"change has worked."
msgstr "讓我們在公文包開發者模式下運行更新後的應用程序，以檢查我們的更改是否有效。"

#: docs/en/tutorial/tutorial-7.md:114 docs/en/tutorial/tutorial-7.md:186
#: docs/en/tutorial/tutorial-8.md:164
#, fuzzy
msgid ""
"You can't run an Android app in developer mode - use the instructions for "
"your chosen desktop platform."
msgstr "您無法在開發者模式下執行 Android 應用程式 - 請使用您所選擇的桌面平台說明。"

#: docs/en/tutorial/tutorial-7.md:121 docs/en/tutorial/tutorial-7.md:193
#: docs/en/tutorial/tutorial-8.md:171
#, fuzzy
msgid ""
"You can't run an iOS app in developer mode - use the instructions for your "
"chosen desktop platform."
msgstr "您無法在開發者模式下執行 iOS 應用程式 - 請使用您所選擇的桌面平台說明。"

#: docs/en/tutorial/tutorial-7.md:126
#, fuzzy
msgid ""
"What happened? We've added `faker` to our *code*, but we haven't added it to"
" our development virtual environment. We can fix this by installing `faker` "
"with `pip`, and then re-running `briefcase dev`:"
msgstr ""
"發生了什麼事？我們已將`httpx`新增至我們的*程式碼*中，但我們尚未將其新增至我們的開發虛擬環境。我們可以透過用`pip`安裝`httpx`來解決這個問題，然後重新執行`briefcase"
" dev`："

#: docs/en/tutorial/tutorial-7.md:137 docs/en/tutorial/tutorial-7.md:155
#: docs/en/tutorial/tutorial-7.md:173 docs/en/tutorial/tutorial-8.md:107
#: docs/en/tutorial/tutorial-8.md:129 docs/en/tutorial/tutorial-8.md:151
#, fuzzy
msgid ""
"When you enter a name and press the button, you should see a dialog that "
"looks something like:"
msgstr "當您輸入名稱並按下按鈕時，您應該會看到一個類似以下內容的對話框："

#: docs/en/tutorial/tutorial-7.md:140
#, fuzzy
msgid "![Hello World Tutorial 7 dialog, on macOS]{1}"
msgstr "![Hello World 教學 7 對話框，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:158
#, fuzzy
msgid "![Hello World Tutorial 7 dialog, on Linux]{1}"
msgstr "![Hello World Tutorial 7 dialog, on Linux]{1}"

#: docs/en/tutorial/tutorial-7.md:176
#, fuzzy
msgid "![Hello World Tutorial 7 dialog, on Windows]{1}"
msgstr "![Hello World 教程 7 對話框，在 Windows 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:198
#, fuzzy
msgid ""
"We've now got a working app, using a third party library, running in "
"development mode!"
msgstr "我們現在有了一個可以使用的應用程序，使用第三方庫，在開發模式下運行！"

#: docs/en/tutorial/tutorial-7.md:201
#, fuzzy
msgid "Running the updated app"
msgstr "運行更新的應用程式"

#: docs/en/tutorial/tutorial-7.md:203
#, fuzzy
msgid ""
"Let's get this updated application code packaged as a standalone app. Since "
"we've made code changes, we need to follow the same steps as in [Tutorial "
"4]{1}:"
msgstr "讓我們將此更新的應用程式程式碼打包為獨立應用程式。由於我們已經更改了程式碼，因此我們需要遵循 [教程 4]{1} 中的相同步驟："

#: docs/en/tutorial/tutorial-7.md:209 docs/en/tutorial/tutorial-7.md:251
#: docs/en/tutorial/tutorial-7.md:306 docs/en/tutorial/tutorial-7.md:348
#: docs/en/tutorial/tutorial-7.md:423
#, fuzzy
msgid "Update the code in the packaged app:"
msgstr "更新打包應用程式中的程式碼："

#: docs/en/tutorial/tutorial-7.md:220 docs/en/tutorial/tutorial-7.md:262
#: docs/en/tutorial/tutorial-7.md:317 docs/en/tutorial/tutorial-7.md:359
#: docs/en/tutorial/tutorial-7.md:434
#, fuzzy
msgid "Rebuild the app:"
msgstr "重建應用程式："

#: docs/en/tutorial/tutorial-7.md:229 docs/en/tutorial/tutorial-7.md:276
#: docs/en/tutorial/tutorial-7.md:326
#, fuzzy
msgid "And finally, run the app:"
msgstr "最後，運行應用程式："

#: docs/en/tutorial/tutorial-7.md:238 docs/en/tutorial/tutorial-7.md:335
#, fuzzy
msgid ""
"However, when the app runs, you'll see an error in the console, plus a crash"
" dialog:"
msgstr "但是，當應用程式運行時，您會在控制台中看到錯誤，以及崩潰對話框："

#: docs/en/tutorial/tutorial-7.md:241
#, fuzzy
msgid "![Hello World Tutorial 7 app crash, on macOS]{1}"
msgstr "Hello World Tutorial 7 應用程式當機，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:285 docs/en/tutorial/tutorial-7.md:378
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console:"
msgstr "但是，當應用程式運行時，您會在控制台中看到錯誤："

#: docs/en/tutorial/tutorial-7.md:338
#, fuzzy
msgid "![Hello World Tutorial 7 app crash, on Windows]{1}"
msgstr "Hello World Tutorial 7 應用程式當機，在 Windows 上]{1}。"

#: docs/en/tutorial/tutorial-7.md:369 docs/en/tutorial/tutorial-7.md:444
#, fuzzy
msgid "And finally, run the app (selecting a simulator when prompted):"
msgstr "最後，執行應用程式（在提示時選擇模擬器）："

#: docs/en/tutorial/tutorial-7.md:454
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console"
msgstr "但是，當應用程式運行時，您會在控制台中看到錯誤："

#: docs/en/tutorial/tutorial-7.md:469
#, fuzzy
msgid ""
"Once again, the app has failed to start because `faker` has not been "
"installed - but why? Haven't we already installed `faker`?"
msgstr "又一次，應用程式無法啟動，因為`faker`尚未安裝 - 但為什麼呢？我們不是已經安裝`faker`了嗎？"

#: docs/en/tutorial/tutorial-7.md:472
#, fuzzy
msgid ""
"We have - but only in the development environment. Your development "
"environment is entirely local to your machine - and is only enabled when you"
" explicitly activate it. Although Briefcase has a development mode, the main"
" reason you'd use Briefcase is to package up your code so you can give it to"
" someone else."
msgstr ""
"我們有 - 但僅限於開發環境。您的開發環境完全位於您的電腦本機 - 並且僅在您明確啟動它時才啟用。儘管Briefcase "
"有開發模式，但您使用Briefcase 的主要原因是打包您的程式碼，以便提供給其他人。"

#: docs/en/tutorial/tutorial-7.md:478
#, fuzzy
msgid ""
"The only way to guarantee that someone else will have a Python environment "
"that contains everything it needs is to build a completely isolated Python "
"environment. This means there's a completely isolated Python install, and a "
"completely isolated set of dependencies. This is what Briefcase is building "
"when you run `briefcase build` - an isolated Python environment. This also "
"explains why `faker` isn't installed - it has been installed in your "
"*development* environment, but not in the packaged app."
msgstr ""
"確保其他人擁有一個包含其所需一切的Python環境的唯一方法是建立一個完全隔離的Python環境。這意味著有一個完全隔離的 Python "
"安裝和一組完全隔離的依賴項。這就是當您執行`briefcase build`時，Briefcase 正在建置的內容—一個獨立的 Python "
"環境。這也解釋了為什麼未安裝`httpx` - 它已安裝在您的*開發*環境中，但未安裝在打包的應用程式中。"

#: docs/en/tutorial/tutorial-7.md:487
#, fuzzy
msgid ""
"So - we need to tell Briefcase that our app has an external dependency."
msgstr "因此 - 我們需要告訴 Briefcase 我們的應用程式具有外部相依性。"

#: docs/en/tutorial/tutorial-7.md:489
#, fuzzy
msgid "Updating dependencies"
msgstr "更新依賴項"

#: docs/en/tutorial/tutorial-7.md:491
#, fuzzy
msgid ""
"In the root directory of your app, there is a file named `pyproject.toml`. "
"This file contains all the app configuration details that you provided when "
"you originally ran `briefcase new`."
msgstr ""
"在應用程式的根目錄中，有一個名為`pyproject.toml`的檔案。該檔案包含您最初執行`briefcase "
"new`時提供的所有應用程式設定詳細資訊。"

#: docs/en/tutorial/tutorial-7.md:495
#, fuzzy
msgid ""
"`pyproject.toml` is broken up into sections; one of the sections describes "
"the settings for your app:"
msgstr "`pyproject.toml` 被分成幾個部分；其中一節描述了您的應用程式的設定：："

#: docs/en/tutorial/tutorial-7.md:508
#, fuzzy
msgid ""
"The `requires` option describes the dependencies of our application. It is a"
" list of strings, specifying libraries (and, optionally, versions) of "
"libraries that you want to be included with your app."
msgstr "`requires` 選項描述了我們應用程式的依賴關係。它是一個字串列表，指定您想要包含在應用程式中的庫（以及可選的版本）。"

#: docs/en/tutorial/tutorial-7.md:512
#, fuzzy
msgid "Modify the `requires` setting so that it reads:"
msgstr "修改`requires`設置，使其顯示為："

#: docs/en/tutorial/tutorial-7.md:520
#, fuzzy
msgid ""
"By adding this setting, we're telling Briefcase \"when you build my app, run"
" `pip install faker` into the application bundle\". Anything that would be "
"legal input to `pip install` can be used here - so, you could specify:"
msgstr ""
"透過添加此設置，我們告訴 Briefcase`當您建立我的應用程式時，在應用程式包中執行`pip install httpx``。任何可以作為`pip "
"install`合法輸入的內容都可以在這裡使用 - 因此，您可以指定："

#: docs/en/tutorial/tutorial-7.md:525
#, fuzzy
msgid "A specific library version (e.g., `\"faker==37.3.0\"`);"
msgstr "特定的庫版本（例如`httpx==0.19.0`）；"

#: docs/en/tutorial/tutorial-7.md:526
#, fuzzy
msgid "A range of library versions (e.g., `\"faker>=37\"`);"
msgstr "一系列庫版本（例如`httpx>=0.19`）；"

#: docs/en/tutorial/tutorial-7.md:527
#, fuzzy
msgid ""
"A path to a git repository (e.g., "
"`\"git+https://github.com/joke2k/faker/\"`); or"
msgstr "git 儲存庫的路徑（例如，`\"git+https://github.com/encode/httpx\"`）；或者"

#: docs/en/tutorial/tutorial-7.md:529
#, fuzzy
msgid ""
"A local file path (However - be warned: if you give your code to someone "
"else, this path probably won't exist on their machine!)"
msgstr "本機檔案路徑（但是 - 請注意：如果您將程式碼提供給其他人，則該路徑可能不會存在於他們的電腦上！）"

#: docs/en/tutorial/tutorial-7.md:532
#, fuzzy
msgid ""
"Further down in `pyproject.toml`, you'll notice other sections that are "
"operating system dependent, like `[tool.briefcase.app.helloworld.macOS]` and"
" `[tool.briefcase.app.helloworld.windows]`. These sections *also* have a "
"`requires` setting. These settings allow you to define additional platform-"
"specific dependencies - so, for example, if you need a platform-specific "
"library to handle some aspect of your app, you can specify that library in "
"the platform-specific `requires` section, and that setting will only be used"
" for that platform. You will notice that the `toga` libraries are all "
"specified in the platform-specific `requires` section - this is because the "
"libraries needed to display a user interface are platform specific."
msgstr ""
"在`pyproject.toml`中，您會注意到與作業系統相關的其他部分，例如`[tool.briefcase.app.helloworld.macOS]`和`[tool.briefcase.app.helloworld`.windows]`"
" 。這些部分*也*有一個`requires`設定。這些設定允許您定義其他特定於平台的依賴項 - "
"因此，例如，如果您需要特定於平台的庫來處理應用程式的某些方面，您可以在特定於平台的`requires`部分中指定該庫，並且該設定將僅用於該平台。您會注意到`toga`庫都是在特定於平台的`requires`部分中指定的"
" - 這是因為顯示使用者介面所需的庫是特定於平台的。"

#: docs/en/tutorial/tutorial-7.md:544
#, fuzzy
msgid ""
"In our case, we want `faker` to be installed on all platforms, so we use the"
" app-level `requires` setting. The app-level dependencies will always be "
"installed; the platform-specific dependencies are installed *in addition* to"
" the app-level ones."
msgstr ""
"在我們的例子中，我們希望在所有平台上安裝`httpx`，因此我們使用應用程式層級`requires`設定。應用程式級相依性將始終被安裝；除了*應用程式層級的依賴項之外，還會安裝特定於平台的依賴項。"

#: docs/en/tutorial/tutorial-7.md:549
#, fuzzy
msgid ""
"Now that we've told Briefcase about our additional requirements, we can try "
"packaging our app again. Ensure that you've saved your changes to "
"`pyproject.toml`, and then update your app again - this time, passing in the"
" `-r` flag. This tells Briefcase to update requirements in the packaged app:"
msgstr ""
"現在我們已經告訴 Briefcase "
"我們的附加要求，我們可以嘗試再次打包我們的應用程式。確保您已將變更儲存到`pyproject.toml`，然後再次更新您的應用程式 - "
"這次傳入`-r`標誌。這告訴 Briefcase 更新打包應用程式中的要求："

#: docs/en/tutorial/tutorial-7.md:673
#, fuzzy
msgid ""
"Once you've updated, you can run `briefcase build` and `briefcase run` - and"
" you should see your packaged app, with the new dialog behavior."
msgstr "更新後，您可以運行`briefcase build`和`briefcase run` - 您應該會看到打包的應用程序，具有新的對話框行為。"

#: docs/en/tutorial/tutorial-7.md:678
#, fuzzy
msgid ""
"The `-r` option for updating requirements is also honored by the `build` and"
" `run` command, so if you want to update, build, and run in one step, you "
"could use `briefcase run -u -r`."
msgstr ""
"用於更新需求的`-r`選項也受到`build`和`run`命令的支持，因此如果您想一步更新、構建和運行，您可以使用`briefcase`運行-u "
"-r`。"

#: docs/en/tutorial/tutorial-7.md:684
#, fuzzy
msgid "Third-Party Python Packages for Mobile and Web"
msgstr "適用於行動和網頁的第三方 Python 套件"

#: docs/en/tutorial/tutorial-7.md:686
#, fuzzy
msgid ""
"Faker is just one example of a third-party Python package - a collection of "
"code that isn't part what Python provides out of the box. These third-party "
"packages are most commonly distributed using the [Python Package Index "
"(PyPI)]{1}, and installed into your local virtual environment. We've been "
"using `pip` in this tutorial, but there are other options."
msgstr ""
"Faker 只是協力廠商 Python 套件的一個範例，它是 Python 開箱即用之外的程式碼集合。這些第三方套件最常使用 [Python "
"Package Index (PyPI)]{1} 來散佈，並安裝到您的本機虛擬環境中。我們在本教程中使用 `pip`，但也有其他選擇。"

#: docs/en/tutorial/tutorial-7.md:693
#, fuzzy
msgid ""
"On desktop platforms (macOS, Windows, Linux), essentially any package on "
"PyPI package can be installed into your virtual environment, or added to "
"your app's requirements. However, when building an app for mobile or web "
"platforms, [your options are slightly limited]{1}."
msgstr ""
"在桌面平台（macOS、Windows、Linux）上，任何可安裝的`pip`都可以加入您的需求。在行動和網路平台上，[您的選擇略有限制]{1}。"

#: docs/en/tutorial/tutorial-7.md:699
#, fuzzy
msgid ""
"In short; any *pure Python* package (i.e. any package created from a project"
" written *only* in Python) can be used without difficulty. Some packages, "
"though, are created from projects that contain both Python and other "
"languages (e.g. C, C++, Rust, etc). Code written in those languages needs to"
" be compiled to platform-specific binary modules before it can be used, and "
"those pre-compiled binary modules are only available on specific platforms. "
"Mobile and web platforms have very different requirements than \"standard\" "
"desktop platforms. At this time, most Python packages don't provide pre-"
"compiled binaries for mobile and web platforms."
msgstr ""
"簡而言之；任何 *pure Python* 套件 (即任何從 *only* 以 Python 撰寫的專案所建立的套件) "
"都可以毫無困難地使用。不過，有些套件是由包含 Python 與其他語言 (例如 C、C++、Rust 等) "
"的專案所建立的。以這些語言寫成的程式碼需要編譯成特定平台的二進位模組才能使用，而這些預先編譯好的二進位模組只能在特定平台上使用。行動和網頁平台的需求與「標準」桌上型平台有很大的不同。目前，大多數"
" Python 套件都不提供行動和網頁平台的預先編譯二進位模組。"

#: docs/en/tutorial/tutorial-7.md:710
#, fuzzy
msgid ""
"On PyPI, packages are often provided in a pre-built distribution format "
"called *wheels*. To check whether a package is pure Python, look at the PyPI"
" downloads page for the project. If the wheels provided have a `-py3-none-"
"any.whl` suffix (e.g., [Faker]{1}), then they are pure Python wheels. "
"However, if the wheels have version and platform-specific extensions (e.g., "
"[Pillow]{2}, which has wheels with suffixes like "
"`-cp313-cp313-macosx_11_0_arm64.whl` and `-cp39-cp39-win_amd64.whl`), then "
"the wheel *contains a binary component*. That package cannot be installed on"
" mobile or web platforms unless a wheel compatible with those platforms has "
"been provided."
msgstr ""
"在 PyPI 上，套件通常以預先建立的發行版格式提供，稱為 *wheels*。要檢查一個套件是否是純 Python，請查看專案的 PyPI "
"下載頁面。如果提供的 wheels 有 `-py3-none-any.whl` 後綴 (例如 [Faker]{1})，那麼它們就是純 Python "
"wheels。但是，如果這些 wheels 有特定版本和平台的擴充套件 (例如 [Pillow]{2}，它的 wheels 後綴是 "
"`-cp313-cp313-macosx_11_0_arm64.whl` 和 `cp39-cp39-win_amd64.whl`)，那麼這個 "
"wheels * 包含一個二進位元件*。該套件無法安裝在行動或網頁平台上，除非已提供與這些平台相容的滾輪。"

#: docs/en/tutorial/tutorial-7.md:723
#, fuzzy
msgid ""
"At this time, *most* binary packages on PyPI don't provide mobile- or web-"
"compatible wheels. To fill this gap, BeeWare provides binaries for some "
"popular binary modules (including `numpy`, `pandas`, and `cryptography`). "
"These wheels are *not* distributed on PyPI, but Briefcase will install those"
" wheels if they're available."
msgstr ""
"目前，PyPI 上*多的二進位套件並沒有提供行動或網頁相容的輪子。為了填補這個缺口，BeeWare 提供了一些熱門二進位模組的二進位檔 (包括 "
"`numpy`、`pandas` 和 `cryptography`)。這些輪子 ** 並沒有散佈在 PyPI 上，但如果有的話，Briefcase "
"會安裝這些輪子。"

#: docs/en/tutorial/tutorial-7.md:729
#, fuzzy
msgid ""
"It's *usually* possible to compile binary packages for mobile platforms, but"
" it's not easy to set up -- well outside the scope of an introductory "
"tutorial like this one."
msgstr ""
"BeeWare 可以為一些流行的二進位模組（包括`numpy`、`pandas`和`cryptography`）提供二進位檔案。 *通常* "
"可以為行動平台編譯軟體包，但設定起來並不容易——這遠遠超出了像本教程這樣的介紹性教程的範圍。"

#: docs/en/tutorial/tutorial-7.md:735
#, fuzzy
msgid ""
"We've now got an app that uses a third-party library! In [Tutorial 8]{1} "
"we'll learn how to ensure our app remains responsive as we add more complex "
"application logic."
msgstr ""
"我們現在有了一個使用第三方函式庫的應用程式！在 [教學 8]{1} 中，我們將學習如何在添加更複雜的應用程式邏輯時，確保我們的應用程式保持反應靈敏。"

#: docs/en/tutorial/tutorial-8.md:1
#, fuzzy
msgid "Tutorial 8 - Making it Smooooth"
msgstr "教學 8 - 使其順～暢"

#: docs/en/tutorial/tutorial-8.md:3
#, fuzzy
msgid ""
"So far, our application has been relatively simple - displaying GUI widgets,"
" calling a simple third-party library, and displaying output in a dialog. "
"All these operations happen very quickly, and our application remains "
"responsive."
msgstr ""
"到目前為止，我們的應用程式相對簡單 - 顯示 GUI "
"widget、呼叫一個簡單的第三方函式庫，以及在對話框中顯示輸出。所有這些操作都發生得非常快，而且我們的應用程式仍然反應迅速。"

#: docs/en/tutorial/tutorial-8.md:8
#, fuzzy
msgid ""
"However, in a real world application, we'll need to perform complex tasks or"
" calculations that may take a while to complete - and as those tasks are "
"performed, we want our application to remain responsive. Let's make a change"
" to our application that might take a little time to complete, and see the "
"changes that need to be made to accommodate that behavior."
msgstr ""
"但是，在現實世界的應用程式中，我們需要執行複雜的任務或計算，這些任務或計算可能需要一段時間才能完成 - "
"而在執行這些任務時，我們希望應用程式能保持反應迅速。讓我們對應用程式做一個可能需要花點時間才能完成的變更，看看需要做哪些變更來適應這種行為。"

#: docs/en/tutorial/tutorial-8.md:15
#, fuzzy
msgid "Accessing an API"
msgstr "存取 API"

#: docs/en/tutorial/tutorial-8.md:17
#, fuzzy
msgid ""
"A common time-consuming task an app will need to perform is to make a "
"request on a web API to retrieve data, and display that data to the user. "
"Web APIs sometimes take a second or two to respond, so if we're calling an "
"API like that, we need to ensure our application doesn't become unresponsive"
" while we wait for the web API to return an answer."
msgstr ""
"應用程式需要執行的一項常見耗時任務是向 Web API 提出擷取資料的請求，並將資料顯示給使用者。Web API "
"有時需要一、兩秒的時間來回應，因此如果我們要呼叫這樣的 API，就必須確保在等待 Web API 回覆時，應用程式不會變得毫無反應。"

#: docs/en/tutorial/tutorial-8.md:23
#, fuzzy
msgid ""
"This is a toy app, so we don't have a *real* API to work with, so we'll use "
"the [{JSON} Placeholder API]{1} as a source of data. The {JSON} Placeholder "
"API has a number of \"fake\" API endpoints you can use as test data. One of "
"those APIs is the `/posts/` endpoint, which returns fake blog posts. If you "
"open `https://jsonplaceholder.typicode.com/posts/42` in your browser, you'll"
" get a JSON payload describing a single post - some [Lorum ipsum]{2} content"
" for a blog post with ID 42."
msgstr ""
"這是一個玩具應用程式，所以我們沒有*真實的 API 可用，因此我們會使用 [{JSON} Placeholder API]{1} "
"作為資料來源。{JSON}占位符 API 有許多「偽造」的 API 端點，您可以將其用作測試資料。其中一個 API 是 `/posts/` "
"端點，它會傳回虛假的部落格文章。如果您在瀏覽器中開啟 "
"`https://jsonplaceholder.typicode.com/posts/42`，您會得到一個描述單篇文章的 JSON 有效載荷 - ID"
" 為 42 的部落格文章的一些 [Lorum ipsum]{2} 內容。"

#: docs/en/tutorial/tutorial-8.md:33
#, fuzzy
msgid ""
"The Python standard library contains all the tools you'd need to access an "
"API. However, the built-in APIs are very low level. They are good "
"implementations of the HTTP protocol - but they require the user to manage "
"lots of low-level details, like URL redirection, sessions, authentication, "
"and payload encoding. As a \"normal browser user\" you're probably used to "
"taking these details for granted, as a browser manages them for you."
msgstr ""
"Python 標準函式庫包含了存取 API 所需的所有工具。然而，內建的 API 是非常低階的。它們是 HTTP 通訊協定的良好實作 - "
"但需要使用者管理許多低階的細節，像是 URL "
"重定向、會話、驗證和有效載荷編碼。身為「一般瀏覽器使用者」，您可能習慣將這些細節視為理所當然，因為瀏覽器會替您管理這些細節。"

#: docs/en/tutorial/tutorial-8.md:41
#, fuzzy
msgid ""
"As a result, people have developed third-party libraries that wrap the "
"built-in APIs and provide a simpler API that is a closer match for the "
"everyday browser experience. We're going to use one of those libraries to "
"access the {JSON} Placeholder API - a library called [`httpx`]{1}. Briefcase"
" uses `httpx` internally, so it's already in your local environment - you "
"don't need to install it separately to use it here."
msgstr ""
"因此，人們開發了第三方函式庫來包裝內建的 API，並提供更簡單的 API，更貼近日常的瀏覽器體驗。我們要使用其中一個函式庫來存取 {JSON}占位符 "
"API - 一个名为 [`httpx`]{1} 的库。Briefcase 內部使用了 `httpx`，所以它已經在您的本機環境中了 - "
"您不需要另外安裝就可以在這裡使用它。"

#: docs/en/tutorial/tutorial-8.md:49
#, fuzzy
msgid ""
"Let's add a `httpx` API call to our app. Modify the `requires` setting in "
"our `pyproject.toml` to include the new requirement:"
msgstr ""
"讓我們在應用程式中加入 `httpx` API 呼叫。修改我們的 `pyproject.toml` 中的 `requires` 設定，以包含新的需求："

#: docs/en/tutorial/tutorial-8.md:59
#, fuzzy
msgid "Add an import to the top of the `app.py` to import `httpx`:"
msgstr "在 `app.py` 的頂端加入 import 來匯入 `httpx`："

#: docs/en/tutorial/tutorial-8.md:83
#, fuzzy
msgid ""
"This will change the `say_hello()` callback so that when it is invoked, it "
"will:"
msgstr "這將會變更「say_hello()」回呼，因此當它被呼叫時，它將會："

#: docs/en/tutorial/tutorial-8.md:86
#, fuzzy
msgid "make a GET request on the JSON placeholder API to obtain post 42;"
msgstr "在 JSON 占位符 API 上進行 GET 請求，以取得 Post 42；"

#: docs/en/tutorial/tutorial-8.md:87
#, fuzzy
msgid "decode the response as JSON;"
msgstr "將回應解碼成 JSON；"

#: docs/en/tutorial/tutorial-8.md:88
#, fuzzy
msgid "extract the body of the post; and"
msgstr "提取文章的正文；以及"

#: docs/en/tutorial/tutorial-8.md:89
#, fuzzy
msgid ""
"include the body of that post as the text of the \"message\" dialog, in "
"place of the text generated by Faker."
msgstr "包含該文章的正文作為「訊息」對話方塊的文字，以取代 Faker 產生的文字。"

#: docs/en/tutorial/tutorial-8.md:92
#, fuzzy
msgid ""
"Lets run our updated app in Briefcase developer mode to check that our "
"change has worked. As we've added a new requirement, we need to tell "
"developer mode to reinstall requirements, by using the `-r` argument:"
msgstr ""
"讓我們在 Briefcase 開發者模式中執行更新後的應用程式，檢查我們的變更是否成功。由於我們新增了新的需求，我們需要使用 `-r` "
"參數告訴開發人員模式重新安裝需求："

#: docs/en/tutorial/tutorial-8.md:110
#, fuzzy
msgid "![Hello World Tutorial 8 dialog, on macOS]{1}"
msgstr "![Hello World 教學 8 對話框，在 macOS 上]{1}。"

#: docs/en/tutorial/tutorial-8.md:132
#, fuzzy
msgid "![Hello World Tutorial 8 dialog, on Linux]{1}"
msgstr "![Hello World Tutorial 8 dialog, on Linux]{1}"

#: docs/en/tutorial/tutorial-8.md:154
#, fuzzy
msgid "![Hello World Tutorial 8 dialog, on Windows]{1}"
msgstr "![Hello World 教程 8 對話框，在 Windows 上]{1}。"

#: docs/en/tutorial/tutorial-8.md:176
#, fuzzy
msgid ""
"Unless you've got a *really* fast internet connection, you may notice that "
"when you press the button, the GUI for your app locks up for a little bit. "
"The operating system may even manifest this with a \"beachball\" or "
"\"spinner\" cursor to indicate that the app is being unresponsive."
msgstr ""
"除非您的網路連線速度非常快，否則您可能會發現按下按鈕時，應用程式的圖形使用者介面會稍微鎖定一下。作業系統甚至可能會以「beachball」或「spinner」游標來表示應用程式反應不良。"

#: docs/en/tutorial/tutorial-8.md:182
#, fuzzy
msgid ""
"This is because the web request we have made is *synchronous*. When our "
"application makes the web request, it waits for the API to return a response"
" before continuing. While it's waiting, it *isn't* allowing the application "
"to redraw - and as a result, the application locks up."
msgstr ""
"除非您擁有 **真正** 快速的網路連接，否則您可能會注意到，當您按下按鈕時，應用程式的 GUI 會鎖定一點。這是因為我們發出的 Web 請求是 "
"**同步** 的。當我們的應用程式發出 Web 請求時，它會等待 API 回傳回應，然後再繼續。在等待時，它 **不允許** 應用程式重繪 - "
"結果，應用程式停止回應。"

#: docs/en/tutorial/tutorial-8.md:187
msgid "GUI Event Loops"
msgstr "GUI 事件循環(Event loop)"

#: docs/en/tutorial/tutorial-8.md:189
msgid ""
"To understand why this happens, we need to dig into the details of how a GUI"
" application works. The specifics vary depending on the platform; but the "
"high level concepts are the same, no matter the platform or GUI environment "
"you're using."
msgstr ""
"為了理解為什麼會發生這種情況，我們需要深入研究 GUI 應用程式如何運作的細節。具體情況因平台而異；但無論您使用什麼平台或 GUI "
"環境，概念都是相同的。"

#: docs/en/tutorial/tutorial-8.md:194
msgid "A GUI app is, fundamentally, a single loop that looks something like:"
msgstr "從根本上來說，GUI 應用程式是一個看起來像這樣的循環:"

#: docs/en/tutorial/tutorial-8.md:202
#, fuzzy
msgid ""
"This loop is called the *Event Loop*. (These aren't actual method names - "
"it's an illustration of what is going on using \"pseudo-code\")."
msgstr "此循環稱為 *事件循環* 。 （這些不是實際的方法名稱 - 它是 `偽代碼` 中發生的情況的說明）。"

#: docs/en/tutorial/tutorial-8.md:205
msgid ""
"When you click on a button, or drag a scroll bar, or type a key, you are "
"generating an \"event\". That \"event\" is put onto a queue, and the app "
"will process the queue of events when it next has the opportunity to do so. "
"The user code that is triggered in response to the event is called an *event"
" handler*. These event handlers are invoked as part of the "
"`process_events()` call."
msgstr ""
"當您按一下按鈕、拖曳捲軸或按下按鍵時，代表你產生一個 `事件` 。該 `事件` "
"被放入佇列中，應用程式將在下次有機會處理事件佇列時處理該事件。響應事件而觸發的程式碼稱為 `event handler` 。這些事件處理程序作為 "
"`process_events()` 呼叫的一部分被呼叫。"

#: docs/en/tutorial/tutorial-8.md:212
msgid ""
"Once an app has processed all the available events, it will `redraw()` the "
"GUI. This takes into account any changes that the events have caused to the "
"display of the app, as well as anything else that is going on in the "
"operating system - for example, the windows of another app may obscure or "
"reveal part of our app's window, and our app's redraw will need to reflect "
"the portion of the window that is currently visible."
msgstr ""
"一旦應用程式處理完所有可用事件，它將 `redraw()` GUI。這考慮了事件對應用程式顯示造成的任何變化，以及作業系統中發生的任何其他變化 - "
"例如，另一個應用程式的視窗可能會遮蓋或顯示我們應用程式視窗的一部分，我們的應用程式的重繪需要反映目前可見的視窗部分。"

#: docs/en/tutorial/tutorial-8.md:219
msgid ""
"The important detail to notice: while an application is processing an event,"
" *it can't redraw*, and *it can't process other events*."
msgstr "需要注意的重要細節：當應用程式正在處理事件時， *它無法重繪* ，並且 *它無法處理其他事件* 。"

#: docs/en/tutorial/tutorial-8.md:222
msgid ""
"This means any user logic contained in an event handler needs to complete "
"quickly. Any delay in completing the event handler will be observed by the "
"user as a slowdown (or stop) in GUI updates. If this delay is long enough, "
"your operating system may report this as a problem - the macOS \"beachball\""
" and Windows \"spinner\" icons are the operating system telling you that "
"your app is taking too long in an event handler."
msgstr ""
"這意味著事件處理程序中包含的任何使用者邏輯都需要快速完成。使用者將觀察到完成事件處理程序的任何延遲，因為 GUI "
"更新速度會減慢（或停止）。如果延遲足夠長，您的作業系統可能會將此報告為問題 - macOS `beachball` 和 Windows "
"`spinner` 圖示是作業系統告訴您您的應用程式在事件處理程序中花費的時間太長。"

#: docs/en/tutorial/tutorial-8.md:230
msgid ""
"Simple operations like \"update a label\", or \"recompute the total of the "
"inputs\" are easy to complete quickly. However, there are a lot of "
"operations that can't be completed quickly. If you're performing a complex "
"mathematical calculation, or indexing all the files on a file system, or "
"performing a large network request, you can't \"just do it quickly\" - the "
"operations are inherently slow."
msgstr ""
"`更新標籤` 或 `重新計算輸入總數` "
"等簡單操作很容易快速完成。然而，有許多操作無法快速完成。如果您正在執行複雜的數學計算，或對檔案系統上的所有檔案進行索引，或執行網路請求，則您無法 "
"`快速完成` - 那些操作本質上很慢。"

#: docs/en/tutorial/tutorial-8.md:237
msgid "So - how do we perform long-lived operations in a GUI application?"
msgstr "那麼，我們如何在 GUI 應用程式中執行耗時的操作呢？"

#: docs/en/tutorial/tutorial-8.md:239
msgid "Asynchronous programming"
msgstr "非同步程式設計"

#: docs/en/tutorial/tutorial-8.md:241
msgid ""
"What we need is a way to tell an app in the middle of a long-lived event "
"handler that it is OK to temporarily release control back to the event loop,"
" as long as we can resume where we left off. It's up to the app to determine"
" when this release can occur; but if the app releases control to the event "
"loop regularly, we can have a long-running event handler *and* maintain a "
"responsive UI."
msgstr ""
"我們需要的是一種方法讓耗時的event "
"handler執行時告訴應用程序，只要可以從中斷的地方恢復，就可以暫時將控制權釋放回事件循環。由應用程式決定何時釋放它；但如果應用程式定期釋放對事件循環的控制，我們就可以擁有一個長時間運行的事件處理程序"
" *並* 維護一個響應式 UI。"

#: docs/en/tutorial/tutorial-8.md:248
msgid ""
"We can do this by using *asynchronous programming*. Asynchronous programming"
" is a way to describe a program that allows the interpreter to run multiple "
"functions at the same time, sharing resources between all the concurrently "
"running functions."
msgstr ""
"我們可以透過使用 `非同步程式設計` 來做到這一點。非同步程式設計是一種描述程式的方式，允許解釋器同時運行多個函數，在所有並發運行的函數之間共用資源。"

#: docs/en/tutorial/tutorial-8.md:253
#, fuzzy
msgid ""
"Asynchronous functions (known as *coroutines*) need to be explicitly "
"declared as being asynchronous. They also need to internally declare when an"
" opportunity exists to change context to another coroutine."
msgstr "非同步函數（稱為 *協程* ）需要明確宣告為非同步。他們還需要在內部聲明何時存在將上下文更改為另一個協程的機會。"

#: docs/en/tutorial/tutorial-8.md:257
#, fuzzy
msgid ""
"In Python, asynchronous programming is implemented using the `async` and "
"`await` keywords, and the [asyncio]{1} module in the standard library. The "
"`async` keyword allows us to declare that a function is an asynchronous "
"coroutine. The `await` keyword provides a way to declare when an opportunity"
" exists to change context to another coroutine. The [asyncio]{2} module "
"provides some other useful tools and primitives for asynchronous coding."
msgstr ""
"在Python中，非同步程式設計是使用 `async` 和 `await` 關鍵字以及 [asyncio]{1} 中的模組來實現的。標準庫。 "
"`async` 關鍵字允許我們宣告函數是非同步協同例程。 `await` 關鍵字提供了一種聲明何時存在將上下文更改為另一個協同例程的機會的方法。 "
"[asyncio]{2} 模組為非同步程式設計提供了一些其他有用的工具和語法。"

#: docs/en/tutorial/tutorial-8.md:267
#, fuzzy
msgid "Making the tutorial asynchronous"
msgstr "使教學異步"

#: docs/en/tutorial/tutorial-8.md:269
msgid ""
"To make our tutorial asynchronous, modify the `say_hello()` event handler so"
" it looks like this:"
msgstr "要使我們的教程異步，請修改 `say_hello()` 事件處理程序，使其如下所示："

#: docs/en/tutorial/tutorial-8.md:288
#, fuzzy
msgid ""
"There are only three changes to this callback from the previous version:"
msgstr "與先前的版本相比，此程式碼僅發生了 4 處變更："

#: docs/en/tutorial/tutorial-8.md:290
msgid ""
"The client that is created is an asynchronous `AsyncClient()`, rather than a"
" synchronous `Client()`. This tells `httpx` that it should operate in "
"asynchronous mode, rather than synchronous mode."
msgstr ""
"建立的客戶端是異步 `AsyncClient()` ，而不是同步 `Client()` 。這告訴 `httpx` "
"它應該以非同步模式運行，而不是同步模式。"

#: docs/en/tutorial/tutorial-8.md:293
msgid ""
"The context manager used to create the client is marked as `async`. This "
"tells Python that there is an opportunity to release control as the context "
"manager is entered and exited."
msgstr "用於建立客戶端的上下文管理器被標記為 `async` 。這告訴Python，當進入和退出上下文管理器時，有機會釋放控制權。"

#: docs/en/tutorial/tutorial-8.md:296
#, fuzzy
msgid ""
"The `get` call is made with an `await` keyword. This instructs the app that "
"while we are waiting for the response from the network, the app can release "
"control to the event loop. We've seen this keyword before - we also use "
"`await` when displaying the dialog box. The reason for that usage is the "
"same as it is for the HTTP request - we need to tell the app that while the "
"dialog is displayed, and we're waiting for the user to push a button, it's "
"OK to release control back to the event loop."
msgstr ""
"在 `get` 呼叫中使用了 `await` 關鍵字。這會指示應用程式，當我們等待網路的回應時，應用程式可以釋放控制權給事件循環。我們以前見過這個關鍵字"
" - 當顯示對話方塊時，我們也使用了 `await`。使用這個關鍵字的原因與 HTTP 請求相同 - "
"我們需要告訴應用程式，當顯示對話方塊，並且我們正在等待使用者按下按鈕的時候，可以將控制權釋放回事件循環。"

#: docs/en/tutorial/tutorial-8.md:305
#, fuzzy
msgid ""
"It's also important to note that the handler itself is defined as `async "
"def`, rather than just `def`. This tells Python that the method is an "
"asynchronous coroutine. We made this change back in Tutorial 3 when we added"
" the dialog box. You can only use `await` statements inside a method that is"
" declared as `async def`."
msgstr ""
"同樣重要的是，處理程式本身被定義為 `async def`，而不只是 `def`。這會告訴 Python 這個方法是一個異步的 "
"coroutine。我們在教學 3 加入對話方塊時做了這個改變。您只能在宣告為 `async def` 的方法裡面使用 `await` 語句。"

#: docs/en/tutorial/tutorial-8.md:311
#, fuzzy
msgid ""
"Toga allows you to use regular methods or asynchronous coroutines as "
"handlers; Toga manages everything behind the scenes to make sure the handler"
" is invoked or awaited as required."
msgstr "Toga 允許您使用常規方法或非同步協同例程作為處理程序； Toga 管理幕後的一切，以確保根據需要呼叫或等待處理程序。"

#: docs/en/tutorial/tutorial-8.md:315
#, fuzzy
msgid ""
"If you save these changes and re-run the app in development mode, there "
"won't be any obvious changes to the app. However, when you click on the "
"button to trigger the dialog, you may notice a number of subtle "
"improvements:"
msgstr ""
"如果您儲存這些變更並重新執行應用程式（在開發模式下使用 `briefcase dev` "
"，或透過更新並重新執行打包的應用程式），應用程式不會有任何明顯的變更。但是，當您單擊按鈕觸發對話框時，您可能會注意到一些細微的改進："

#: docs/en/tutorial/tutorial-8.md:320
msgid ""
"The button returns to an \"unclicked\" state, rather than being stuck in a "
"\"clicked\" state."
msgstr "該按鈕返回到 `未單擊` 狀態，而不是停留在 `單擊` 狀態。"

#: docs/en/tutorial/tutorial-8.md:322
#, fuzzy
msgid "The \"beachball\"/\"spinner\" icon won't appear."
msgstr "不會出現「沙灘球」/「旋轉器」圖示。"

#: docs/en/tutorial/tutorial-8.md:323
msgid ""
"If you move/resize the app window while waiting for the dialog to appear, "
"the window will redraw."
msgstr "如果您在等待對話方塊出現時移動/調整應用程式視窗的大小，則該視窗將會重新繪製。"

#: docs/en/tutorial/tutorial-8.md:325
msgid "If you try to open an app menu, the menu will appear immediately."
msgstr "如果您嘗試開啟應用程式選單，該選單將立即出現。"

#: docs/en/tutorial/tutorial-8.md:327
#, fuzzy
msgid ""
"We can now run the full app. However, as we've added an extra requirement "
"(`httpx`) we also need to update our app's requirements; we can do this by "
"passing `-r` to `briefcase run`. This will update our app's requirements, "
"then re-build the app, then launch the app:"
msgstr ""
"現在我們可以執行完整的應用程式了。然而，由於我們增加了一個額外的需求 (`httpx`)，我們也需要更新應用程式的需求；我們可以將 `-r` 傳給 "
"`briefcase run` 來做到這一點。這將更新應用程式的需求，然後重新建立應用程式，再啟動應用程式："

#: docs/en/tutorial/tutorial-8.md:372
#, fuzzy
msgid ""
"You should see you app running, and remaining responsive when you press the "
"button and network content is retrieved."
msgstr "您應該會看到您的應用程式正在執行，並且在您按下按鈕及擷取網路內容時保持回應。"

#: docs/en/tutorial/tutorial-8.md:377
#, fuzzy
msgid ""
"This has been a taste for what you can do with the tools provided by the "
"BeeWare project. Over the course of this tutorial, you have:"
msgstr "本教學讓您了解 BeeWare 專案所提供的工具。在本教程中，您將："

#: docs/en/tutorial/tutorial-8.md:380
#, fuzzy
msgid "Created a new GUI app project;"
msgstr "建立一個新的 GUI 應用程式專案；"

#: docs/en/tutorial/tutorial-8.md:381
#, fuzzy
msgid "Run that app in development mode;"
msgstr "在開發者模式下運行應用程式"

#: docs/en/tutorial/tutorial-8.md:382
#, fuzzy
msgid "Built the app as a standalone binary for a desktop operating system;"
msgstr "將應用程式建立為桌上型電腦作業系統的獨立二進位檔案；"

#: docs/en/tutorial/tutorial-8.md:383
#, fuzzy
msgid "Packaged that project for distribution to others;"
msgstr "將該專案打包分發給其他人；"

#: docs/en/tutorial/tutorial-8.md:384
#, fuzzy
msgid "Run the app on a mobile simulator and/or device;"
msgstr "在行動模擬器和/或裝置上執行應用程式；"

#: docs/en/tutorial/tutorial-8.md:385
#, fuzzy
msgid "Run the app as a web app;"
msgstr "以 Web 應用程式的方式執行應用程式；"

#: docs/en/tutorial/tutorial-8.md:386
#, fuzzy
msgid "Added a third-party dependency to your app; and"
msgstr "為您的應用程式新增第三方依賴；以及"

#: docs/en/tutorial/tutorial-8.md:387
#, fuzzy
msgid "Modified the app so that it remains responsive."
msgstr "修改應用程式，使其保持反應靈敏。"

#: docs/en/tutorial/tutorial-8.md:389
#, fuzzy
msgid "So - where to from here?"
msgstr "那麼--何去何從？"

#: docs/en/tutorial/tutorial-8.md:391
#, fuzzy
msgid ""
"If you'd like to go further, there are some additional [topic tutorials]{1} "
"that go into detail on specific aspects of application development."
msgstr "如果您想深入瞭解，還有一些額外的 [主題教學]{1}，會詳細介紹應用程式開發的特定方面。"

#: docs/en/tutorial/tutorial-8.md:394
#, fuzzy
msgid ""
"If you'd like to know more about how to build complex user interfaces with "
"Toga, you can dive into [Toga's documentation]{1}. Toga also has its own "
"tutorial [demonstrating how to use various features of the widget "
"toolkit]{2}."
msgstr ""
"如果您想進一步瞭解如何使用 Toga 建立複雜的使用者介面，您可以深入閱讀 [Toga 的說明文件]{1}。Toga 也有自己的教學 [示範如何使用 "
"widget 工具套件的各種功能]{2}。"

#: docs/en/tutorial/tutorial-8.md:399
#, fuzzy
msgid ""
"If you'd like to know more about the capabilities of Briefcase, you can dive"
" into [Briefcase's documentation]{1}."
msgstr "如果您想瞭解更多關於 Briefcase 的功能，可以深入閱讀 [Briefcase 的說明文件]{1}。"

#~ msgid "Install Python"
#~ msgstr "安裝Python"

#~ msgid "Install dependencies"
#~ msgstr "安裝依賴項"
